//YgorMath.cc - DICOMautomaton.

#include <cmath>       //Needed for fabs, signbit, sqrt, etc...
#include <iostream>
#include <fstream>
#include <algorithm>   //Needed for std::reverse.
#include <map>
#include <list>
#include <iterator>
#include <functional>  //Needed for passing kernel functions to integration schemes.

#include "YgorMath.h"
#include "YgorMisc.h"    //For the FUNC* and PERCENT_ERR macro functions.

#include "YgorPlot.h"    //A wrapper used for producing plots of contours.
class Plotter;

#ifndef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    #define YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
#endif

//Forward declaration. Needed due to mixing of classes (find point where line and plane intersect, etc..)
template <class T> class vec3;
template <class T> class vec2;
template <class T> class line;
template <class T> class line_segment;
template <class T> class plane;
template <class T> class contour_of_points;



//---------------------------------------------------------------------------------------------------------------------------
//---------------------------------------- vec3: A three-dimensional vector -------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------
//Constructors.
template <class T>    vec3<T>::vec3(){   x=(T)(0);   y=(T)(0);   z=(T)(0);  }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int>::vec3(void);
    template vec3<long int>::vec3(void);
    template vec3<float>::vec3(void);
    template vec3<double>::vec3(void);
#endif

template <class T>    vec3<T>::vec3(T a, T b, T c) : x(a), y(b), z(c) { }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int>::vec3(int, int, int);
    template vec3<long int>::vec3(long int, long int, long int);
    template vec3<float>::vec3(float, float, float);
    template vec3<double>::vec3(double, double, double);
#endif
    
template <class T>    vec3<T>::vec3( const vec3<T> &in ) : x(in.x), y(in.y), z(in.z) { }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int>::vec3( const vec3<int> & );
    template vec3<long int>::vec3( const vec3<long int> & );
    template vec3<float>::vec3( const vec3<float> & );
    template vec3<double>::vec3( const vec3<double> & );
#endif
    
    
//More general: (but is it needed?)
//template<class Ch,class Tr,class T>     std::basic_ostream<Ch,Tr> & operator<<( std::basic_ostream<Ch,Tr> &&out, const vec3<T> &L ){
//    out << "(" << L.x << ", " << L.y << ", " << L.z << ")";
//    return out;
//}
template <class T>    std::ostream & operator<<( std::ostream &out, const vec3<T> &L ) {
    out << "(" << L.x << ", " << L.y << ", " << L.z << ")";
    return out;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template std::ostream & operator<<(std::ostream &out, const vec3<int> &L );
    template std::ostream & operator<<(std::ostream &out, const vec3<long int> &L );
    template std::ostream & operator<<(std::ostream &out, const vec3<float> &L );
    template std::ostream & operator<<(std::ostream &out, const vec3<double> &L );
#endif
    
    
template <class T> vec3<T> vec3<T>::Cross(const vec3<T> &in) const {
    const T thex = (*this).y * in.z - (*this).z * in.y;
    const T they = (*this).z * in.x - (*this).x * in.z;
    const T thez = (*this).x * in.y - (*this).y * in.x;
    return vec3<T>( thex, they, thez );
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<float>  vec3<float>::Cross(const vec3<float> &in) const ;
    template vec3<double> vec3<double>::Cross(const vec3<double> &in) const ;
#endif
    
    
template <class T> T vec3<T>::Dot(const vec3<T> &in) const {
    return (*this).x * in.x + (*this).y * in.y + (*this).z * in.z;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float vec3<float>::Dot(const vec3<float> &in) const;
    template double vec3<double>::Dot(const vec3<double> &in) const;
#endif
    
    
template <class T> vec3<T> vec3<T>::unit(void) const {
    const T tot = sqrt(x*x + y*y + z*z);
    return vec3<T>(x/tot, y/tot, z/tot);
} 
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<float> vec3<float>::unit(void) const;
    template vec3<double> vec3<double>::unit(void) const;
#endif
    
    
template <class T> T vec3<T>::length(void) const {
    const T tot = sqrt(x*x + y*y + z*z);
    return tot;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float vec3<float>::length(void) const;
    template double vec3<double>::length(void) const;
#endif
    
    
template <class T>  T vec3<T>::distance(const vec3<T> &rhs) const {
    const T dist = sqrt((x-rhs.x)*(x-rhs.x) + (y-rhs.y)*(y-rhs.y) + (z-rhs.z)*(z-rhs.z));
    return dist;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float vec3<float>::distance(const vec3<float> &rhs) const;
    template double vec3<double>::distance(const vec3<double> &rhs) const;
#endif
    
/*
template <class T>  T vec3<T>::distance(vec3 rhs){
    const T dist = sqrt((x-rhs.x)*(x-rhs.x) + (y-rhs.y)*(y-rhs.y) + (z-rhs.z)*(z-rhs.z));
    return dist;
}
    
template float vec3<float>::distance(vec3<float> rhs);
template double vec3<double>::distance(vec3<double> rhs);
*/
    
template <class T>    std::istream &operator>>( std::istream &in, vec3<T> &L ) {
    //... << "("  << L.x << ", " << L.y << ", " <<  L.z  <<  ")";
    //We have at least TWO options here. We can use a method which is compatible
    // with the ( , , ) notation, or we can ask for straight-up numbers. 
    //We will discriminate here based on what 'in' is.
    if(in != std::cin){
        char grbg;
        //... << "("  << L.x << ", " << L.y << ", " <<  L.z  <<  ")";
        in    >> grbg >> L.x >> grbg >> L.y >> grbg >>  L.z  >> grbg;
    }else  in >> L.x >> L.y >> L.z;
    return in;
}
        
    
template <class T>    vec3<T> & vec3<T>::operator=(const vec3<T> &rhs) {
    //Check if it is itself.
    if (this == &rhs) return *this; 
    (*this).x = rhs.x;    (*this).y = rhs.y;    (*this).z = rhs.z;
     return *this;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int> & vec3<int>::operator=(const vec3<int> &rhs);
    template vec3<long int> & vec3<long int>::operator=(const vec3<long int> &rhs);
    template vec3<float> & vec3<float>::operator=(const vec3<float> &rhs);
    template vec3<double> & vec3<double>::operator=(const vec3<double> &rhs);
#endif
    
    
template <class T>    vec3<T> vec3<T>::operator+(const vec3<T> &rhs) const {
    return vec3<T>( (*this).x + rhs.x, (*this).y + rhs.y, (*this).z + rhs.z);
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int> vec3<int>::operator+(const vec3<int> &rhs) const;
    template vec3<long int> vec3<long int>::operator+(const vec3<long int> &rhs) const;
    template vec3<float> vec3<float>::operator+(const vec3<float> &rhs) const;
    template vec3<double> vec3<double>::operator+(const vec3<double> &rhs) const;
#endif

    
template <class T>    vec3<T> & vec3<T>::operator+=(const vec3<T> &rhs) {
    (*this).x += rhs.x;    (*this).y += rhs.y;    (*this).z += rhs.z;
    return *this;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int> & vec3<int>::operator+=(const vec3<int> &rhs);
    template vec3<long int> & vec3<long int>::operator+=(const vec3<long int> &rhs);
    template vec3<float> & vec3<float>::operator+=(const vec3<float> &rhs);
    template vec3<double> & vec3<double>::operator+=(const vec3<double> &rhs);
#endif
    
    
template <class T> vec3<T> vec3<T>::operator-(const vec3<T> &rhs) const {
    return vec3<T>( (*this).x - rhs.x, (*this).y - rhs.y, (*this).z - rhs.z);
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int> vec3<int>::operator-(const vec3<int> &rhs) const;
    template vec3<long int> vec3<long int>::operator-(const vec3<long int> &rhs) const;
    template vec3<float> vec3<float>::operator-(const vec3<float> &rhs) const;
    template vec3<double> vec3<double>::operator-(const vec3<double> &rhs) const;
#endif

    
template <class T>    vec3<T> & vec3<T>::operator-=(const vec3<T> &rhs) {
    (*this).x -= rhs.x;    (*this).y -= rhs.y;    (*this).z -= rhs.z;
    return *this;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int> & vec3<int>::operator-=(const vec3<int> &rhs);
    template vec3<long int> & vec3<long int>::operator-=(const vec3<long int> &rhs);
    template vec3<float> & vec3<float>::operator-=(const vec3<float> &rhs);
    template vec3<double> & vec3<double>::operator-=(const vec3<double> &rhs);
#endif
    
//------------------------------ overloaded native-types -----------------------------

/*
template <class T>    vec3<T> vec3<T>::operator*(const T rhs) {
    return vec3<T>(x*rhs,y*rhs,z*rhs);
}
template <class T>    vec3<T> & vec3<T>::operator*=(const T rhs) {
    (*this).x *= rhs;    (*this).y *= rhs;    (*this).z *= rhs;
     return *this;
}
template vec3<int> & vec3<int>::operator*=(const int rhs);
template vec3<float> & vec3<float>::operator*=(const float rhs);
template vec3<double> & vec3<double>::operator*=(const double rhs);



template <class T>    vec3<T> vec3<T>::operator/(const T rhs) {
    return vec3<T>(x/rhs,y/rhs,z/rhs);
}
template <class T>    vec3<T> & vec3<T>::operator/=(const T rhs) {
    (*this).x /= rhs;    (*this).y /= rhs;    (*this).z /= rhs;
     return *this;
}
template vec3<int> & vec3<int>::operator/=(const int rhs);
template vec3<float> & vec3<float>::operator/=(const float rhs);
template vec3<double> & vec3<double>::operator/=(const double rhs);
*/

//--------

template <class T>    vec3<T> vec3<T>::operator*(const T &rhs) const {
    return vec3<T>(x*rhs,y*rhs,z*rhs);
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int> vec3<int>::operator*(const int &rhs) const;
    template vec3<long int> vec3<long int>::operator*(const long int &rhs) const;
    template vec3<float> vec3<float>::operator*(const float &rhs) const;
    template vec3<double> vec3<double>::operator*(const double &rhs) const;
#endif
    
template <class T>    vec3<T> & vec3<T>::operator*=(const T &rhs) {
    (*this).x *= rhs;    (*this).y *= rhs;    (*this).z *= rhs;
    return *this;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int> & vec3<int>::operator*=(const int &rhs);
    template vec3<long int> & vec3<long int>::operator*=(const long int &rhs);
    template vec3<float> & vec3<float>::operator*=(const float &rhs);
    template vec3<double> & vec3<double>::operator*=(const double &rhs);
#endif
    
    
    
template <class T>    vec3<T> vec3<T>::operator/(const T &rhs) const {
    return vec3<T>(x/rhs,y/rhs,z/rhs);
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int> vec3<int>::operator/(const int &rhs) const;
    template vec3<long int> vec3<long int>::operator/(const long int &rhs) const;
    template vec3<float> vec3<float>::operator/(const float &rhs) const;
    template vec3<double> vec3<double>::operator/(const double &rhs) const;
#endif
    
template <class T>    vec3<T> & vec3<T>::operator/=(const T &rhs) {
    (*this).x /= rhs;    (*this).y /= rhs;    (*this).z /= rhs;
    return *this;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<int> & vec3<int>::operator/=(const int &rhs);
    template vec3<long int> & vec3<long int>::operator/=(const long int &rhs);
    template vec3<float> & vec3<float>::operator/=(const float &rhs);
    template vec3<double> & vec3<double>::operator/=(const double &rhs);
#endif
    
    
    
template <class T>    bool vec3<T>::operator==(const vec3<T> &rhs) const {
    return ( (x == rhs.x) && (y == rhs.y) && (z == rhs.z) );
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template bool vec3<int>::operator==(const vec3<int> &rhs) const;
    template bool vec3<long int>::operator==(const vec3<long int> &rhs) const;
    template bool vec3<float>::operator==(const vec3<float> &rhs) const;
    template bool vec3<double>::operator==(const vec3<double> &rhs) const;
#endif
    
    
template <class T>    bool vec3<T>::operator<(const vec3<T> &rhs) const {
    return (*this).length() < rhs.length();  // NOTE: Although this is a fairly "unsatisfying" result, it appears to properly allow vec3's to be placed in std::maps, whereas more intuitive methods (x<rhs.x, etc..) do NOT. 
                                             // If an actual operator< is to be defined, please do NOT overwrite this one (so that we can continue to put vec3's into std::map and not have garbled output and weird bugs!) 
//    return ( (y < rhs.y) ); //  <--- BAD! (See previous note above ^)
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template bool vec3<int>::operator<(const vec3<int> &rhs) const;
    template bool vec3<long int>::operator<(const vec3<long int> &rhs) const;
    template bool vec3<float>::operator<(const vec3<float> &rhs) const;
    template bool vec3<double>::operator<(const vec3<double> &rhs) const;
#endif
    
//-------------------------------------------------------------------------------------------------------------------------------------
//This is a function for rotation unit vectors in some plane. It requires angles to describe the plane of rotation, angle of rotation. 
// It alo requires a unit vector with which to rotate the plane about.
vec3<double> rotate_unit_vector_in_plane(const vec3<double> &A, const double &theta, const double &R){
    // A    --- The unit vector which defines the central axis of the plane. We rotate about this vector to make a plane.
    // theta -- The angle of rotation for a unit vector within the plane.
    // R    --- An angle from [0:2*pi] which specifies the second axis of the plane (along with A.)

    //###########################################################################################
    //## This method is NOT ideal. It is expensive AND brittle. Fix it with a better solution. ##    ---> it came from "Project - Transport"
    //###########################################################################################

    std::complex<double> a1 = (fabs(A.x) > 1E-11) ? ( (fabs(A.x) < (1.0-1E-10)) ? A.x :  A.x - 1E-10 ) : 1E-11 + A.x;    // ~~ A.x
    std::complex<double> a2 = (fabs(A.y) > 1E-11) ? ( (fabs(A.y) < (1.0-1E-10)) ? A.y :  A.y - 1E-10 ) : 1E-11 + A.y;    // ~~ A.y
    std::complex<double> a3 = (fabs(A.z) > 1E-11) ? ( (fabs(A.z) < (1.0-1E-10)) ? A.z :  A.z - 1E-10 ) : 1E-11 + A.z;    // ~~ A.z

    static const std::complex<double> i(0.0,1.0);

    std::complex<double> p, t; //Angles.

    if(fabs(A.z) < 0.75){ //Handles special cases. Doesn't do so safely, though!

    //Now, given the rotation angle and the unit vector coordinates of A, we generate a unit vector in the plane orthogonal to A.   
    p  = (R > 1E-11) ? R : 1E-11 + R;  // ~~ R

    //Two solutions for t when fixing p. Pick one (I think they correspond to the plus/minus orientation, which should be irrelevant here.)
    t  = -i*log(-1.0*pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0)*pow(pow(a3,2.0)*pow(M_E,4.0*i*p)+pow(a2,2.0)*pow(M_E,4.0*i*p)+pow(a1,2.0)*pow(M_E,4.0*i*p)+2.0*pow(a3,2.0)*pow(M_E,2.0*i*p)-2.0*pow(a2,2.0)*pow(M_E,2.0*i*p)-2.0*pow(a1,2.0)*pow(M_E,2.0*i*p)+pow(a3,2.0)+pow(a2,2.0)+pow(a1,2.0),0.5)+a3*pow(M_E,2.0*i*p)*pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0)+a3*pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0));

    //t  = -i*log(pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0)*pow(pow(a3,2.0)*pow(M_E,4.0*i*p)+pow(a2,2.0)*pow(M_E,4.0*i*p)+pow(a1,2.0)*pow(M_E,4.0*i*p)+2.0*pow(a3,2.0)*pow(M_E,2.0*i*p)-2.0*pow(a2,2.0)*pow(M_E,2.0*i*p)-2.0*pow(a1,2.0)*pow(M_E,2.0*i*p)+pow(a3,2.0)+pow(a2,2.0)+pow(a1,2.0),0.5)+a3*pow(M_E,2.0*i*p)*pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0)+a3*pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0));


    }else{
    
        t = R;

        //We are going to use least-significant bit selection here. Ugh... Of COURSE this is not portable. Endianness breaks it, if not something else.
        union {
            double the_number;
            char   asChars[sizeof(double)];
        };
        the_number = R;

        //This time we cannot simply ignore one of the solutions, lest we have a one-sided universe...
     
        // http://stackoverflow.com/questions/4743115/how-do-i-use-bitwise-operators-on-a-double-on-c
 
        //if(asChars[sizeof(double) - 1] & 0x1){
        if(asChars[0] & 0x1){  //Least significant bit selection. Sorry, if you are reading this, for such a shit solution :(
            p = -i*log(-1.0*pow(a2*pow(M_E,2.0*i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+i*a1*pow(M_E,2.0*i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+2.0*a3*pow(M_E,i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)-1.0*a2*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+i*a1*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0),0.5));
        }else{
            p = -0.5*i*log(a2*pow(M_E,2.0*i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+i*a1*pow(M_E,2.0*i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+2.0*a3*pow(M_E,i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)-1.0*a2*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+i*a1*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0));
        }
    }

    double u1;
    double u2;
    double u3;

    u1 = ( cos(t)*sin(p) ).real();
    u2 = ( sin(t)*sin(p) ).real();
    u3 = ( cos(p) ).real();

    //Note that taking the real part messes up the normalization, leading to some fairly funky 'strands' in the rotated vector.
    // If you sample theta but leave A and R static, you should see these strands if you remove the following renormalization.
    const double utot = sqrt( u1*u1 + u2*u2 + u3*u3 );
    u1 /= utot;
    u2 /= utot;
    u3 /= utot;

    //Now we rotate by the angle provided.
    const double out_x = cos(theta)*A.x + sin(theta)*u1;
    const double out_y = cos(theta)*A.y + sin(theta)*u2;
    const double out_z = cos(theta)*A.z + sin(theta)*u3;

    //Now we ship out the vector.
    return vec3<double>( out_x, out_y, out_z );

}

//---------------------------------------------------------------------------------------------------------------------------
//---------------------------------------- vec2: A three-dimensional vector -------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------
//Constructors.
template <class T>    vec2<T>::vec2(){   x=(T)(0);   y=(T)(0); }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int>::vec2(void);
    template vec2<long int>::vec2(void);
    template vec2<float>::vec2(void);
    template vec2<double>::vec2(void);
#endif

template <class T>    vec2<T>::vec2(T a, T b) : x(a), y(b) { }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int>::vec2(int, int);
    template vec2<long int>::vec2(long int, long int);
    template vec2<float>::vec2(float, float);
    template vec2<double>::vec2(double, double);
#endif
    
template <class T>    vec2<T>::vec2( const vec2<T> &in ) : x(in.x), y(in.y) { }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int>::vec2( const vec2<int> & );
    template vec2<long int>::vec2( const vec2<long int> & );
    template vec2<float>::vec2( const vec2<float> & );
    template vec2<double>::vec2( const vec2<double> & );
#endif
    
    
//More general: (but is it needed?)
//template<class Ch,class Tr,class T>     std::basic_ostream<Ch,Tr> & operator<<( std::basic_ostream<Ch,Tr> &&out, const vec2<T> &L ){
//    out << "(" << L.x << ", " << L.y << ", " << L.z << ")";
//    return out;
//}
template <class T>    std::ostream & operator<<( std::ostream &out, const vec2<T> &L ) {
    out << "(" << L.x << ", " << L.y << ")";
    return out;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template std::ostream & operator<<(std::ostream &out, const vec2<int> &L );
    template std::ostream & operator<<(std::ostream &out, const vec2<long int> &L );
    template std::ostream & operator<<(std::ostream &out, const vec2<float> &L );
    template std::ostream & operator<<(std::ostream &out, const vec2<double> &L );
#endif
    
    
template <class T> T vec2<T>::Dot(const vec2<T> &in) const {
    return (*this).x * in.x + (*this).y * in.y;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float vec2<float>::Dot(const vec2<float> &in) const;
    template double vec2<double>::Dot(const vec2<double> &in) const;
#endif
    
    
template <class T> vec2<T> vec2<T>::unit(void) const {
    const T tot = sqrt(x*x + y*y);
    return vec2<T>(x/tot, y/tot);
} 
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<float> vec2<float>::unit(void) const;
    template vec2<double> vec2<double>::unit(void) const;
#endif
    
    
template <class T> T vec2<T>::length(void) const {
    const T tot = sqrt(x*x + y*y);
    return tot;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float vec2<float>::length(void) const;
    template double vec2<double>::length(void) const;
#endif
    
    
template <class T>  T vec2<T>::distance(const vec2<T> &rhs) const {
    const T dist = sqrt((x-rhs.x)*(x-rhs.x) + (y-rhs.y)*(y-rhs.y));
    return dist;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float vec2<float>::distance(const vec2<float> &rhs) const;
    template double vec2<double>::distance(const vec2<double> &rhs) const;
#endif
    
template <class T>    std::istream &operator>>( std::istream &in, vec2<T> &L ) {
    //... << "("  << L.x << ", " << L.y << ", " <<  L.z  <<  ")";
    //We have at least TWO options here. We can use a method which is compatible
    // with the ( , , ) notation, or we can ask for straight-up numbers. 
    //We will discriminate here based on what 'in' is.
    if(in != std::cin){
        char grbg;
        //... << "("  << L.x << ", " << L.y << ", " <<  L.z  <<  ")";
        in    >> grbg >> L.x >> grbg >> L.y >> grbg;
    }else  in >> L.x >> L.y;
    return in;
}
        
    
template <class T>    vec2<T> & vec2<T>::operator=(const vec2<T> &rhs) {
    //Check if it is itself.
    if (this == &rhs) return *this; 
    (*this).x = rhs.x;    (*this).y = rhs.y;
     return *this;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int> & vec2<int>::operator=(const vec2<int> &rhs);
    template vec2<long int> & vec2<long int>::operator=(const vec2<long int> &rhs);
    template vec2<float> & vec2<float>::operator=(const vec2<float> &rhs);
    template vec2<double> & vec2<double>::operator=(const vec2<double> &rhs);
#endif
    
    
template <class T>    vec2<T> vec2<T>::operator+(const vec2<T> &rhs) const {
    return vec2<T>( (*this).x + rhs.x, (*this).y + rhs.y );
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int> vec2<int>::operator+(const vec2<int> &rhs) const;
    template vec2<long int> vec2<long int>::operator+(const vec2<long int> &rhs) const;
    template vec2<float> vec2<float>::operator+(const vec2<float> &rhs) const;
    template vec2<double> vec2<double>::operator+(const vec2<double> &rhs) const;
#endif

    
template <class T>    vec2<T> & vec2<T>::operator+=(const vec2<T> &rhs) {
    (*this).x += rhs.x;    (*this).y += rhs.y;
    return *this;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int> & vec2<int>::operator+=(const vec2<int> &rhs);
    template vec2<long int> & vec2<long int>::operator+=(const vec2<long int> &rhs);
    template vec2<float> & vec2<float>::operator+=(const vec2<float> &rhs);
    template vec2<double> & vec2<double>::operator+=(const vec2<double> &rhs);
#endif
    
    
template <class T> vec2<T> vec2<T>::operator-(const vec2<T> &rhs) const {
    return vec2<T>( (*this).x - rhs.x, (*this).y - rhs.y);
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int> vec2<int>::operator-(const vec2<int> &rhs) const;
    template vec2<long int> vec2<long int>::operator-(const vec2<long int> &rhs) const;
    template vec2<float> vec2<float>::operator-(const vec2<float> &rhs) const;
    template vec2<double> vec2<double>::operator-(const vec2<double> &rhs) const;
#endif

    
template <class T>    vec2<T> & vec2<T>::operator-=(const vec2<T> &rhs) {
    (*this).x -= rhs.x;    (*this).y -= rhs.y;
    return *this;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int> & vec2<int>::operator-=(const vec2<int> &rhs);
    template vec2<long int> & vec2<long int>::operator-=(const vec2<long int> &rhs);
    template vec2<float> & vec2<float>::operator-=(const vec2<float> &rhs);
    template vec2<double> & vec2<double>::operator-=(const vec2<double> &rhs);
#endif
    
//------------------------------ overloaded native-types -----------------------------


template <class T>    vec2<T> vec2<T>::operator*(const T &rhs) const {
    return vec2<T>(x*rhs,y*rhs);
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int> vec2<int>::operator*(const int &rhs) const;
    template vec2<long int> vec2<long int>::operator*(const long int &rhs) const;
    template vec2<float> vec2<float>::operator*(const float &rhs) const;
    template vec2<double> vec2<double>::operator*(const double &rhs) const;
#endif
    
template <class T>    vec2<T> & vec2<T>::operator*=(const T &rhs) {
    (*this).x *= rhs;    (*this).y *= rhs;
    return *this;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int> & vec2<int>::operator*=(const int &rhs);
    template vec2<long int> & vec2<long int>::operator*=(const long int &rhs);
    template vec2<float> & vec2<float>::operator*=(const float &rhs);
    template vec2<double> & vec2<double>::operator*=(const double &rhs);
#endif
    
template <class T>    vec2<T> vec2<T>::operator/(const T &rhs) const {
    return vec2<T>(x/rhs,y/rhs);
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int> vec2<int>::operator/(const int &rhs) const;
    template vec2<long int> vec2<long int>::operator/(const long int &rhs) const;
    template vec2<float> vec2<float>::operator/(const float &rhs) const;
    template vec2<double> vec2<double>::operator/(const double &rhs) const;
#endif
    
template <class T>    vec2<T> & vec2<T>::operator/=(const T &rhs) {
    (*this).x /= rhs;    (*this).y /= rhs;
    return *this;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec2<int> & vec2<int>::operator/=(const int &rhs);
    template vec2<long int> & vec2<long int>::operator/=(const long int &rhs);
    template vec2<float> & vec2<float>::operator/=(const float &rhs);
    template vec2<double> & vec2<double>::operator/=(const double &rhs);
#endif
    
    
    
template <class T>    bool vec2<T>::operator==(const vec2<T> &rhs) const {
    return ( (x == rhs.x) && (y == rhs.y) );
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template bool vec2<int>::operator==(const vec2<int> &rhs) const;
    template bool vec2<long int>::operator==(const vec2<long int> &rhs) const;
    template bool vec2<float>::operator==(const vec2<float> &rhs) const;
    template bool vec2<double>::operator==(const vec2<double> &rhs) const;
#endif
    
    
template <class T>    bool vec2<T>::operator<(const vec2<T> &rhs) const {
    return (*this).length() < rhs.length();  // NOTE: Although this is a fairly "unsatisfying" result, it appears to properly allow vec2's to be placed in std::maps, whereas more intuitive methods (x<rhs.x, etc..) do NOT. 
                                             // If an actual operator< is to be defined, please do NOT overwrite this one (so that we can continue to put vec2's into std::map and not have garbled output and weird bugs!) 
//    return ( (y < rhs.y) ); //  <--- BAD! (See previous note above ^)
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template bool vec2<int>::operator<(const vec2<int> &rhs) const;
    template bool vec2<long int>::operator<(const vec2<long int> &rhs) const;
    template bool vec2<float>::operator<(const vec2<float> &rhs) const;
    template bool vec2<double>::operator<(const vec2<double> &rhs) const;
#endif
    


//---------------------------------------------------------------------------------------------------------------------------
//----------------------------------------- line: (infinitely-long) lines in 3D space ---------------------------------------
//---------------------------------------------------------------------------------------------------------------------------
//Constructors.
template <class T>    line<T>::line(){ }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template line<float>::line(void);
    template line<double>::line(void);
#endif

template <class T>    line<T>::line(const vec3<T> &R_A, const vec3<T> &R_B) : R_0(R_A) {
    vec3<T> temp(R_B);
    temp -= R_A;
    U_0 = temp.unit();
} 
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template line<float>::line(const vec3<float> &R_A, const vec3<float> &R_B);
    template line<double>::line(const vec3<double> &R_A, const vec3<double> &R_B);
#endif


//Member functions.

/*
//This function takes a point and a unit vector along each line and computes the point at which they intersect. If they diverge, the function returns false. Otherwise,
// it returns true and places the point of intersection in "output."
//
// If the function returns false, it does not imply that the lines diverge - it implies only that the solution computed with this method was unstable!
//
//This function accepts 3D vectors, but only uses the x and y parts. The z-component is entirely ignored.
template <class T>  bool line<T>::Intersects_With_Line( const line<T> &in, vec3<T> &out) const {

    //------------
    // Speculation on how to extend this result to a fully-3D result:
    //   step 1 - find the plane which intersects with line 1 infinitely-many places and which only intersects in one place for line 2.
    //   step 2 - determine the point in this plane where line 2 intersects.
    //   step 3 - determine if line 1 and this point coincide.
    //                   If they coincide, then the lines coincide. If any difficulties arise or line 1 and the point do not coincide, then the lines do not coincide.
    //------------


    //If the pivot point R_0 of each line is identical, then we say an intersection occurs there.
    if( (*this).R_0 == in.R_0 ){
        if( !((*this).U_0 == in.U_0) ){
            out = in.R_0;
            return true;
        }
        //The lines overlap! We have an infinite number of solutions, so we pretend it is unsolveable.
        FUNCWARN("Attempting to determine intersection point of two identical lines. Pretending they do not intersect!");
        return false;
    }

    //If the two lines are not in the same z-plane, then the following routine is insufficient!
    if( ((*this).R_0.z == in.R_0.z) || ((*this).U_0.z != (T)(0)) || (in.U_0.z != (T)(0)) ){
        FUNCWARN("This function can not handle fully-3D lines. Lines which do not have a constant z-component are not handled. Continuing and indicating that we could not determine the point of intersection");
        return false;
    }

    //We parametrize each line like (R(t) = point + unit*t) and attempt to determine t for each line.
    // From Maxima:
    //   solve([u1x*t1 - u2x*t2 = Cx, u1y*t1 - u2y*t2 = Cy], [t1,t2]);
    //   --->  [[t1=(Cy*u2x-Cx*u2y)/(u1y*u2x-u1x*u2y) , t2=(Cy*u1x-Cx*u1y)/(u1y*u2x-u1x*u2y)]]
    const T denom = ((*this).U_0.y*in.U_0.x - (*this).U_0.x*in.U_0.y);
    if(fabs(denom) < (T)(1E-99)){
        FUNCWARN("Unable to compute the intersection of two lines. Either the lines do not converge, or the tolerances are set too high. Continuing and indicating that we could not determine the point of intersection");
        return false;
    }

    const T Cx       = (in.R_0.x - (*this).R_0.x);
    const T Cy       = (in.R_0.y - (*this).R_0.y);
    const T numer_t1 = (Cy*in.U_0.x      - Cx*in.U_0.y     );
    const T numer_t2 = (Cy*(*this).U_0.x - Cx*(*this).U_0.y);
    const T t1       = numer_t1 / denom;
    const T t2       = numer_t2 / denom;

    //Now we could (should) check if the two t's lead to consistent results. This is not done at the moment because I will surely have nicely-orthogonal lines that will definately intersect nicely.
    //out = vec3<double>( (*this).R_0.x + (*this).U_0.x*t1, (*this).R_0.y + (*this).U_0.y*t1, (*this).R_0.z  );
    out.x = (*this).R_0.x + (*this).U_0.x*t1;
    out.y = (*this).R_0.y + (*this).U_0.y*t1;
    out.z = (*this).R_0.z;
    return true;
}
*/

//This function computes the distance from any line to any point in 3D space.
template <class T>  T line<T>::Distance_To_Point( const vec3<T> &R ) const {
    //This is a fairly simple result. Check out http://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html for a slightly
    // overtly-difficult description of the derivation.
    const vec3<T> dR = R - (*this).R_0;
    return  ( dR.Cross( dR - (*this).U_0 ) ).length();
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float line<float>::Distance_To_Point( const vec3<float> &R ) const;
    template double line<double>::Distance_To_Point( const vec3<double> &R ) const;
#endif


//This function accepts any line embedded in 3D space.
template <class T>  bool line<T>::Intersects_With_Line( const line<T> &in, vec3<T> &out) const {
    //First, we construct a plane which houses the unit vectors of the two lines.
    // This will give us two planes: $\vec{N} \cdot ( \vec{R} - \vec{R}_{a,0} )$ and $\vec{N} \cdot ( \vec{R} - \vec{R}_{b,0} )$
    // where $\vec{N} = \vec{U}_{a} \otimes \vec{U}_{b}.$ Since the planes are parallel, we just compute the distance between planes. 
    const vec3<T> N( (*this).U_0.Cross( in.U_0 ) );
    //FUNCINFO("The cross product of the unit vectors " << (*this).U_0 << " and " << in.U_0  << " of the lines is " << N);

    if(N.length() < (T)(1E-9) ){
/*
        //The unit vectors are (very) nearly parallel, so we have to check if a point on one line lies on the other line.
        if( ( (*this).Distance_To_Point( in.R_0 ) ) < (T)(1E-9) ){
            FUNCWARN("I was too tired to fill in this result. It is fairly simply, just follow the instructions I've given in the source...");
            return false;   //<--- delete this.

            //Uncomment this code and fill in the details.
            //
            //  const vec3<T> dR = ( (*this).R_0 - in.R_0 );
            //  T separation = dR.length();
            //  T sign_of_separation =   ... ?     //<---- fill this in...
            //  separation += sign_of_separation;
            //  out = (*this).R_0 + (*this).U_0 * separation;    //This will deviate from the actual intersection

        }
*/
        //I might be wrong (very tired right now) but I think this means there are either infinite solutions or none. Either way, we cannot
        // compute them, so we just return a big, fat false.
        return false;
    }

    //The distance between planes can be computed as the distance from a single point on one plane to the other plane. (We know R_0 is on the plane.)
    const plane<T> plane_b( N, in.R_0 );
    const T separation = std::fabs( plane_b.Get_Signed_Distance_To_Point( (*this).R_0 ) ); 
    //FUNCINFO("The separation between planes is " << separation);

    // Explicitly, the signed distance is   dist = (u_a x u_b) dot (R_a - R_b), which removes the need to compute the plane...

    if( separation < (T)(1E-9) ){
        //Determine the point of intersection here.
        // First, we set the two line equations equal to each other in order to determine the parametrization ta and tb where they intersect.
        // Then we dot each (vector) equation with alternatively U_0,a and U_0,b to give us two equations for two unknowns (instead of three
        // equations and two unknowns with a ghost parameter.) The extra piece of information was used during the calculation of plane 
        // separation: ie. we have not lost any info by dotting both sides of the identity to reduce the dimensionality.
        const vec3<T> dR( (*this).R_0 - in.R_0 ); //dR = R_0_a - R_0_b
        const T udotu = (*this).U_0.Dot( in.U_0 );
        const T denom = (T)(1.0) - udotu*udotu;
        if(denom < (T)(1E-9)) return false; //Is this line required, given that we know ua x ub to be nearly zero ?

        //For a line, we only need to compute one of these. For a line segment, we'll need both so we can range-check.
        const T ta = -( ( (*this).U_0 - ( in.U_0 * (udotu) ) ).Dot( dR ) ) / denom;
        //const T tb =  ( ( in.U_0 - ( (*this).U_0 * (udotu) ) ).Dot( dR ) ) / denom; 

        out = (*this).R_0 + ( ( (*this).U_0 ) * ta );
        return true;
    }
    return false;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template bool line<float>::Intersects_With_Line( const line<float> &in, vec3<float> &out) const;
    template bool line<double>::Intersects_With_Line( const line<double> &in, vec3<double> &out) const;
#endif


//---------------------------------------------------------------------------------------------------------------------------
//------------------------------------ line_segment: (finite-length) lines in 3D space --------------------------------------
//---------------------------------------------------------------------------------------------------------------------------
//Constructors.
template <class T>    line_segment<T>::line_segment(){ }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template line_segment<float>::line_segment(void);
    template line_segment<double>::line_segment(void);
#endif

template <class T>    line_segment<T>::line_segment(const vec3<T> &R_A, const vec3<T> &R_B) : t_0(0) {
    (*this).R_0 = R_A;  
    vec3<T> temp(R_A);
    temp -= R_B;
    t_1 = temp.length();
    (*this).U_0 = temp.unit();
}

#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template line_segment<float>::line_segment(const vec3<float> &R_A, const vec3<float> &R_B);
    template line_segment<double>::line_segment(const vec3<double> &R_A, const vec3<double> &R_B);
#endif




//---------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------- plane: 2D planes in 3D space -----------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------
//Constructors.
template <class T>    plane<T>::plane(){ }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template plane<float>::plane(void);
    template plane<double>::plane(void);
#endif

template <class T>    plane<T>::plane(const vec3<T> &N_0_in, const vec3<T> &R_0_in) : N_0(N_0_in), R_0(R_0_in) { }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template plane<float>::plane(const vec3<float> &N_0_in, const vec3<float> &R_0_in);
    template plane<double>::plane(const vec3<double> &N_0_in, const vec3<double> &R_0_in);
#endif

//Member functions.
template <class T>    T plane<T>::Get_Signed_Distance_To_Point(const vec3<T> &R) const {
    //It is really as simple as $Dist_{signed} = \vec{N}_{0} \cdot ( \vec{R} - \vec{R}_{0} ) .$
    // N should already be a unit, but "meh." 
    return ((*this).N_0.x*(R.x-(*this).R_0.x) + (*this).N_0.y*(R.y-(*this).R_0.y) + (*this).N_0.z*(R.z-(*this).R_0.z)) / (*this).N_0.length();  
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float  plane<float>::Get_Signed_Distance_To_Point(const vec3<float> &R) const;
    template double plane<double>::Get_Signed_Distance_To_Point(const vec3<double> &R) const;
#endif

template <class T>    bool plane<T>::Is_Point_Above_Plane(const vec3<T> &R) const {
    return ( std::signbit( (*this).Get_Signed_Distance_To_Point( R ) ) == 0 );
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template bool plane<float>::Is_Point_Above_Plane(const vec3<float> &R) const;
    template bool plane<double>::Is_Point_Above_Plane(const vec3<double> &R) const;
#endif


template <class T>    bool plane<T>::Intersects_With_Line(const line<T> &L, vec3<T> &out) const {
   //This is a fairly simple, robust routine. Set the distance to a point along the line to zero and find the parameter t
   // that corresponds. Edge cases are infinite and zero intersection points.
   const T denom = (*this).N_0.Dot( L.U_0 );
   if(fabs(denom) < 1E-9) return false; //Contains both the infinite and zero intersection cases.
   const T numer = (*this).N_0.Dot( L.R_0 - (*this).R_0 );
   out = L.R_0 - L.U_0*(numer/denom);
   return true;
}


//---------------------------------------------------------------------------------------------------------------------------
//------------------ contour_of_points: a polygon of line segments in the form of a collection of points --------------------
//---------------------------------------------------------------------------------------------------------------------------
//Constructors.
template <class T>    contour_of_points<T>::contour_of_points() : closed(false) { }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template contour_of_points<float>::contour_of_points(void);
    template contour_of_points<double>::contour_of_points(void);
#endif

template <class T>    contour_of_points<T>::contour_of_points(const std::list< vec3<T> > &in_points) : points(in_points), closed(false) { }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template contour_of_points<float>::contour_of_points(const std::list< vec3<float> > &in_points);
    template contour_of_points<double>::contour_of_points(const std::list< vec3<double> > &in_points);
#endif


//Member functions.
template <class T>  T contour_of_points<T>::Get_Signed_Area(void) const {
    //If the polygon is not closed, we complain. This is the easiest way to do it...
    if(!closed){
        FUNCERR("Computing the surface area of an unconnected contour is not well-defined. Make sure to mark your (implicitly) closed contours as closed.");
    } 

    //If the polygon does not have enough points to form a 2D surface, return a zero. (This is legitimate.)
    if((*this).points.size() < 3) return (T)(0);
    T Area = (T)(0);

    auto iter_1 = --((*this).points.end());
    const T specific_height = (*iter_1).z; //Used to abandon the computation if the contour is fully 3D.
    for( auto iter_2 = (*this).points.begin(); iter_2 != (*this).points.end(); ++iter_2 ){
        const vec3<T> r_a(*iter_1);
        const vec3<T> r_b(*iter_2);
        if( std::fabs(PERCENT_ERR(r_a.z, specific_height)) > 0.1 ){  //Our criteria for same height is a |percent error| < 0.1%.
            FUNCERR("This routine is unable to compute generic (signed) areas for fully 3D contours: found a contour with height " << r_a.z << " when the general contour height is " << specific_height << ". This routine assumes the area of interest lies in an XY plane. Fix me if you really need this!");
        }
        const T n = r_b.y - r_a.y;
        const T d = r_b.x - r_a.x;

        //Determine if the y = m_1*x + b_1 parametrization is safe (stable.) Otherwise, we will use a x = y*m_2 + b_2 parametrization.
        if( fabs(d) > (T)(1E-9) ){
            const T m_1 = n/d;
            const T b_1 = r_a.y - m_1*r_a.x;
            Area += -0.5*b_1*(r_b.x - r_a.x); //The negative comes from Green's method!
        }else if( fabs(n) > (T)(1E-9) ){
            const double m_2 = d/n;
            const double b_2 = r_a.x - m_2*r_a.y;
            Area += 0.5*b_2*(r_b.y-r_a.y); //The negative is intentionally missing here!
        }else{
            FUNCWARN("Unable to properly parametrize two contour points (x,y,z) = " << r_a << " and " << r_b << "  Continuing as if they do not exist!");
        }
        iter_1 = iter_2;
    }
    return Area; //NOTE: Do NOT take the absolute value. We want to keep the sign for adding/subtracting/etc.. contour areas!
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float  contour_of_points<float>::Get_Signed_Area(void) const;
    template double contour_of_points<double>::Get_Signed_Area(void) const;
#endif


template <class T> bool contour_of_points<T>::Is_Counter_Clockwise(void) const {
    //First, we compute the (signed) area. If the sign is positive, then the contour is counter-clockwise oriented.
    // Otherwise, it is of zero area or is clockwise.
    const T area = (*this).Get_Signed_Area();
    if( area < (T)(0.0) ) return false;
    return true;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template bool contour_of_points<float>::Is_Counter_Clockwise(void) const;
    template bool contour_of_points<double>::Is_Counter_Clockwise(void) const;
#endif


template <class T> void contour_of_points<T>::Reorient_Counter_Clockwise(void){
    if((*this).Is_Counter_Clockwise() == true) return;

    std::reverse((*this).points.begin(), (*this).points.end());
    return;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template void contour_of_points<float>::Reorient_Counter_Clockwise(void);
    template void contour_of_points<double>::Reorient_Counter_Clockwise(void);
#endif


template <class T> std::list< contour_of_points<T> > contour_of_points<T>::Split_Along_Plane( const plane<T> &theplane ) const {
    //I cannot tell if this routine will be good for non-planar contours or not. Ygor feeling is 'no', but I wonder about
    // the overall ability to describe non-planar contours with a series of points. Maybe, if the curvature of the contour
    // is small near the plane, and it is understood that the points are linearlly interpolated between to form the contour,
    // then we will not actually observe any accidental loss in curvature from this routine.  I'll have to test it..
    std::list< contour_of_points<T> > output;

    if( (*this).points.size() < 3 ){
        FUNCWARN("Not enough contour points to properly split contour. Pretending this contour has been split.");
        contour_of_points<T> new_contour;
        new_contour.closed = true;
        new_contour.points = (*this).points;
        output.push_back(new_contour);
        return output;
    }

    long int number_of_crossings = 0;

    auto copy_of_points( (*this).points ); //This is super inefficient, but it lets us shift the data around later...
    auto offset = copy_of_points.end();
    for(auto iter_2 = copy_of_points.begin(), iter_1 = --(copy_of_points.end());  iter_2 != copy_of_points.end();  ++iter_2){
        //iter_1 is the first point in the contour, iter_2 is one step ahead.      
        //We check if the line segment that connects the two points crosses the plane.
        vec3<T> garbage;
        if( (theplane.Is_Point_Above_Plane( (*iter_1) ) != theplane.Is_Point_Above_Plane( (*iter_2) )) && theplane.Intersects_With_Line(line<T>((*iter_1), (*iter_2)), garbage) ){
            ++number_of_crossings;
            if( offset == copy_of_points.end() ) offset = iter_1; //Look for the first point of the first pair which cross the plane.
        }
        iter_1 = iter_2;
    }

    if(number_of_crossings == 0){
        //Here we make a copy of the contour data and then push it onto the output. We do this because each split
        // should contain at least the same amount of contours as the input.
        contour_of_points<T> new_contour;
        new_contour.closed = true;
        new_contour.points = (*this).points;
        output.push_back(new_contour);
        return output;
    }
   
    std::rotate( copy_of_points.begin(), offset, copy_of_points.end() ); //The first point of the first pair .. is now the first point.

    //Duplicate the first point. This will allow us to cycle through the list and more easily determine the intersection points.
    copy_of_points.push_back( copy_of_points.front() );
    auto iter_of_second = ++( copy_of_points.begin() );
    copy_of_points.push_back( (*iter_of_second) );

    //Step 5 - For each such pair, determine the point on the plane where they intersect.
    //
    //Step 6 - For each continuous stream of points, create a new contour. Insert the upstream plane-intersection point at the 
    // beginning and the downstream one at the end.
    std::vector< std::vector< vec3<T> > > linesegments;
    std::vector<vec3<T> > linesegment_shuttle; //Catches points thrown at it which are eventually thrown into the linesegments vector vector.
    std::vector<vec3<T> > endpoints;    //This is a simple list of the plane-intersection points.
    
   {
    auto iter_1 = copy_of_points.begin();  
    auto iter_2 = ++(copy_of_points.begin());
    for( ;  iter_2 != copy_of_points.end();  ++iter_2, ++iter_1){
        linesegment_shuttle.push_back( (*iter_1) );
        vec3<T> intersection;

        if( (theplane.Is_Point_Above_Plane( (*iter_1) ) != theplane.Is_Point_Above_Plane( (*iter_2) )) && theplane.Intersects_With_Line(line<T>((*iter_1), (*iter_2)), intersection) ){
            linesegment_shuttle.push_back( intersection );
            if(linesegment_shuttle.size() > 2){ //Each complete contour will have two endpoints and at least one other point! (Our entry into this routine gives us a short contour.)
                linesegments.push_back(linesegment_shuttle);
                endpoints.push_back( intersection );
            }else{
                //We do not push the shuttle back - there are too few points because we are on the first iteration.
            }
            linesegment_shuttle.clear();
            //We append the "frontpoint" to the front of the next line segment, too.
            linesegment_shuttle.push_back( intersection );
        }
    }
   }

    if( number_of_crossings != static_cast<long int>(linesegments.size()) ){
        FUNCERR("We somehow produced " << number_of_crossings << " crossings and " << linesegments.size() << " line segments. This is an error. Check the (input) contour data for repeating points and then check the algorithm.");
    }
   

    //Now, we determine which endpoint is furthest from the center point. This is done so we can consistently 'walk' over 
    // the endpoints, and the choice of the most distant is otherwise arbitrary. This assumes the contour is not in the plane
    // of the plane we are splitting in. This means the split will occur along the line defined by the crossing of the plane 
    // we are splitting on and the plane the contour lies on.
    const vec3<T> r_0 = (*this).Average_Point();
    auto lambda_distance_to_r_0 = [r_0](const vec3<T> &a, const vec3<T> &b) -> bool { return r_0.distance(a) < r_0.distance(b); };
    vec3<T> furthest_point = *( std::max_element( endpoints.begin(), endpoints.end(), lambda_distance_to_r_0 ) );

    
    //Because each point is on a plane, we can determine which endpoints are connected across a contour by examining the order walking from the furthest point in the direction of the central point.
    //
    //In practice, this means we can simply sort endpoints (ie. the points which lie on the plane - or rather a line along the plane!) via their distance from the most distant point. After sorting,
    // the points will be ordered like A, B, C, D, E, F, ...  where the line segment A and B will cross a contour, the line segment B and C do NOT cross a segment, the line segment C and D will cross
    // a contour, D and E will not, etc.. Thus, we will be left with *pairs* of points which logically connect the contours along the plane. We can then walk through the endpointed-line segments 
    // and jump around whenever one of the pairs instructs us to. 
    //
    //Using the actual point coordinates is a GOOD way to match points, because no two points should be exactly identical. If there are some, they are both easy and inconsequential to remove prior to 
    // using this algorithm.
    auto lambda_distance_to_furthest_point = [furthest_point](const vec3<T> &a, const vec3<T> &b) -> bool { return (furthest_point.distance(a) < furthest_point.distance(b)); };
    std::sort(endpoints.begin(), endpoints.end(), lambda_distance_to_furthest_point ); 
    std::map< vec3<T>, vec3<T> > paired_endpoints;
    for(long int ii = 0; (2*ii) < static_cast<long int>(endpoints.size()); ++ii){
       paired_endpoints[ endpoints[2*ii+0] ] = endpoints[2*ii+1];
       paired_endpoints[ endpoints[2*ii+1] ] = endpoints[2*ii+0];  //Is this needed if we are always traversing the (original and linesegmented) contour data in the same direction? (apparently yes!)
    }
    
    //Now we cycle through the line segments until they are all used. 
    std::vector<bool> is_this_linesegment_used;
    for(long int ii=0; ii < static_cast<long int>(linesegments.size()); ++ii){
        is_this_linesegment_used.push_back( false );
    }
    std::vector<std::vector<vec3<T> > > newcontours;
    std::vector<vec3<T> > newcontour_shuttle;
    
    long int next_linesegment = -1;
    bool finished_shuttling = false;
    
    do{
    
//FUNCINFO("1 - Entering loop now. next_linesegment = " << next_linesegment << ", shuttle size = " << newcontour_shuttle.size() );
        {
        //Find the index of the next unused line segment if none is present.
        //
        //At no extra cost, check the exiting condition.
        // (If all segments are used AND the shuttle is empty, then we can exit the loop.)
        bool all_used = true;
        for(long int j=0; j < static_cast<long int>(linesegments.size()); ++j){
            if(is_this_linesegment_used[j] == false){
                all_used = false;
                if( next_linesegment == -1 ) next_linesegment = j;
                break;
            }
        }
    
        bool shuttle_empty = (newcontour_shuttle.size() == 0);
        finished_shuttling = (all_used && shuttle_empty);
        if(finished_shuttling) break; //Done.
        }
    
//FUNCINFO("2 - Just past first verification. next_linesegment = " << next_linesegment << ", shuttle size = " << newcontour_shuttle.size() << ", and is_this_linesegment_used[next_linesegment] = " << (is_this_linesegment_used[next_linesegment] ? 1 : 0) );
    
    
        //If we have a valid next_linesegment, and we have a non-empty shuttle, and next_linesegment points to a used segment, we have a complete contour in the shuttle.
        if( (next_linesegment != -1) && (newcontour_shuttle.size() != 0) && (is_this_linesegment_used[next_linesegment] == true) ){
            newcontours.push_back( newcontour_shuttle );
            newcontour_shuttle.clear();
            next_linesegment = -1;
//                    continue;
//FUNCINFO("3A - Entered stream A - pushing completed shuttle onto the stack.");
    
        //If we have a valid next_linesegment, and it points to an UNused segment, push in onto the shuttle, mark the segment as used, and set next_linesegment to the appropriate value.
        }else if((next_linesegment != -1) && (is_this_linesegment_used[next_linesegment] == false) ){
            //Mark the line segment "used."
            is_this_linesegment_used[next_linesegment] = true;
    
//FUNCINFO("3B - Just past first verification. next_linesegment = " << next_linesegment << ", shuttle size = " << newcontour_shuttle.size() << ", and is_this_linesegment_used[next_linesegment] = " << (is_this_linesegment_used[next_linesegment] ? 1 : 0) );
            //Append the line segment's points to the shuttle.
            newcontour_shuttle.insert( newcontour_shuttle.end(),  linesegments[next_linesegment].begin(), linesegments[next_linesegment].end() );
    
            //Find the "frontpoint" which corresponds to the endpoint of the current line segment.
            vec3<T> terminator   = newcontour_shuttle[ newcontour_shuttle.size() - 1 ]; 
            vec3<T> theinitiator = paired_endpoints[ terminator ];                     
    
            bool could_find_it = false;
            for(long int j=0; j < static_cast<long int>(linesegments.size()); ++j){
                if( linesegments[j][0] == theinitiator ){
                    next_linesegment = j;
                    could_find_it = true;
                    break;
                }
            }
    
            if(could_find_it == false){
                FUNCERR("Was unable to find the next line segment in this contour. Is it there?");
            } 
//FUNCINFO("4B - Entered stream B - pushing line segment onto the shuttle.");
        }
    
    
        {
        //If all segments are used AND the shuttle is empty, then we can exit the loop.
        bool all_used = true;
        for(long int j=0; j < static_cast<long int>(linesegments.size()); ++j){
            if(is_this_linesegment_used[j] == false){
                all_used = false;
                break;
            }
        }
     
        bool shuttle_empty = (newcontour_shuttle.size() == 0);
        finished_shuttling = (all_used && shuttle_empty);
        if(finished_shuttling) break; //Done.
        }
    }while(finished_shuttling == false);
    
    //We check for the number of output contours versus the number of plan crossings.
    //  2 crossings -> 2 contours.
    //  4 crossings -> 3 contours.
    //  6 crossings -> 4 contours.
    // so N crossings -> (N/2) + 1 contours.

    if( (2*(static_cast<long int>(newcontours.size()) - 1)) != number_of_crossings ){
        FUNCERR("This contour originally had " << number_of_crossings << " plane crossings and has been exploded into " << newcontours.size() << " contours. This is not the amount we should have!");
    }else{
        //If all looks swell, we push the split contours onto the output.
        for(long int j=0; j < static_cast<long int>(newcontours.size()); ++j){
            contour_of_points<T> new_contour;
            new_contour.closed = true;

            for(long int jj=0; jj < static_cast<long int>(newcontours[j].size()); ++jj){
                new_contour.points.push_back( newcontours[j][jj] );
            }

            output.push_back(new_contour);
        }
    }

    return output;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
template std::list< contour_of_points<double> > contour_of_points<double>::Split_Along_Plane( const plane<double> &theplane ) const;
template std::list< contour_of_points<float> > contour_of_points<float>::Split_Along_Plane( const plane<float> &theplane ) const;
#endif


template <class T> contour_of_points<T> contour_of_points<T>::Bounding_Box_Along( const vec3<T> &r_n ) const {
    contour_of_points<T> bounding_box;
    bounding_box.closed = true;

    if(r_n.z != 0.0){
        FUNCWARN("This routine is unable to sensibly handle non-zero z-components in the direction unit vector. Please use another algorithm!");
        return bounding_box;
    }

    if( (*this).points.size() < 3 ){
        FUNCWARN("Too few points in this contour to adaquetly compute a bounding box. Ignoring it and continuing..");
        return bounding_box;
    }

    //Now we determine the (2D) bounding box (which is oriented with the unit vector!)
    const vec3<T> r_1( r_n.x, r_n.y, r_n.z);
    const vec3<T> r_2(-r_n.y, r_n.x, r_n.z); //This is r_1 rotated by pi/2 to have an orthogonal unit vector for convenience.

    vec3<T> r_1_most  = (*this).points.front(); //We can bootstrap the bounding box method by randomly choosing a point for each maximum/minimum point. No harm in doing so.
    vec3<T> r_2_most  = (*this).points.front();
    vec3<T> r_1_least = (*this).points.front();
    vec3<T> r_2_least = (*this).points.front();

    for(auto it=(*this).points.begin(); it!=(*this).points.end(); ++it){
        //Length of the vector on the units which define the bounding box coordinates.
        const T r_1_dot_centered  = r_1.Dot( (*it) );
        const T r_2_dot_centered  = r_2.Dot( (*it) );
        
        const T r_1_dot_r_1_most  = r_1.Dot( r_1_most  );  //It is silly to compute these each time. Clean up crew to aisle 964.
        const T r_1_dot_r_1_least = r_1.Dot( r_1_least );
        const T r_2_dot_r_2_most  = r_2.Dot( r_2_most  );
        const T r_2_dot_r_2_least = r_2.Dot( r_2_least );

        if( r_1_dot_centered > r_1_dot_r_1_most  ) r_1_most  = (*it);
        if( r_1_dot_centered < r_1_dot_r_1_least ) r_1_least = (*it);

        if( r_2_dot_centered > r_2_dot_r_2_most  ) r_2_most  = (*it);
        if( r_2_dot_centered < r_2_dot_r_2_least ) r_2_least = (*it);
    }

    //Now, we have four lines describing the bounding box, and each line bounding box lies on top of a(t least one) point in the contour.
    //
    // Counter clockwise orientation:  (clockwise would just negate each unit vector!)
    //
    // Line 1:  point = r_1_most  ,  unit vector = -r_2
    // Line 2:  point = r_2_least ,  unit vector = -r_1
    // Line 3:  point = r_1_least ,  unit vector =  r_2
    // Line 4:  point = r_2_most  ,  unit vector =  r_1

    const vec3<T> u_l1( -r_2.x, -r_2.y, -r_2.z ),    p_l1( r_1_most  );
    const vec3<T> u_l2( -r_1.x, -r_1.y, -r_1.z ),    p_l2( r_2_least );
    const vec3<T> u_l3(  r_2.x,  r_2.y,  r_2.z ),    p_l3( r_1_least );
    const vec3<T> u_l4(  r_1.x,  r_1.y,  r_1.z ),    p_l4( r_2_most  );

    const line<T> L1( p_l1, p_l1 + u_l1 );
    const line<T> L2( p_l2, p_l2 + u_l2 );
    const line<T> L3( p_l3, p_l3 + u_l3 );
    const line<T> L4( p_l4, p_l4 + u_l4 );

    //Now determine the four points where the bounding box intersects.
    vec3<T> intersection;

    if( L4.Intersects_With_Line(L1, intersection) ){
        bounding_box.points.push_back( intersection );
    }else{
        FUNCERR("Unable to determine the point of intersection. Unable to continue");
    }

    if( L1.Intersects_With_Line(L2, intersection) ){
        bounding_box.points.push_back( intersection );
    }else{
        FUNCERR("Unable to determine the point of intersection. Unable to continue");
    }

    if( L2.Intersects_With_Line(L3, intersection) ){
        bounding_box.points.push_back( intersection );
    }else{
        FUNCERR("Unable to determine the point of intersection. Unable to continue");
    }

    if( L3.Intersects_With_Line(L4, intersection) ){
        bounding_box.points.push_back( intersection );
    }else{
        FUNCERR("Unable to determine the point of intersection. Unable to continue");
    }

    //Now we dump the bounding box contour.
    return bounding_box;
}

#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
template contour_of_points<float> contour_of_points<float>::Bounding_Box_Along( const vec3<float> & ) const ;
template contour_of_points<double> contour_of_points<double>::Bounding_Box_Along( const vec3<double> & ) const ;
#endif


template <class T> std::list< contour_of_points<T> > contour_of_points<T>::Split_Against_Ray( const vec3<T> &r_n ) const {
    std::list< contour_of_points<T> > output;

    FUNCWARN("This routine may or may not work OK.");

    //Grab the bounding box.
    const contour_of_points<T> the_bounding_box = (*this).Bounding_Box_Along(r_n);

    if(the_bounding_box.points.size() != 4){
        FUNCWARN("Unable to compute a bounding box. Ignoring and continuing.");
        return output;
    }

    //Given the bounding box and the contour data, we now crawl along the edge and ray cast through the contour. 
    const long int number_of_contour_points = (*this).points.size();
    //const long int number_of_new_points = number_of_contour_points;  //Too many!
    long int number_of_new_points = number_of_contour_points / 6;
    if( number_of_new_points < 5 ) number_of_new_points = 5;


    auto BB_point_iter = the_bounding_box.points.begin();
    //These points are considered to be specified in a counter clockwise orientation. 

    //const vec3<T> r_0 = (*BB_point_iter); //  <--- This one is not used here. Maybe I should use it?
    ++BB_point_iter;
    const vec3<T> r_1 = (*BB_point_iter); 
    ++BB_point_iter;
    const vec3<T> r_2 = (*BB_point_iter); 
    ++BB_point_iter;
    const vec3<T> r_3 = (*BB_point_iter); 

    const vec3<T> dr_21( r_2 - r_1 ); 
    const T width_of_bb = dr_21.length();
    const T dL = width_of_bb / static_cast<T>(number_of_new_points); //dL is the length of separation between ray casts along the unit vector orthogonal to r_n in the XY plane.
    
    //We work our way along the bounding box's "lower" edge and ray cast upward through the contour in the direction of the unit vector provided.
    std::vector< vec3<T> > halfway_points;
    vec3<T> u_ray = r_3;
    u_ray -= r_2;
    u_ray.z = 0.0;
    u_ray = u_ray.unit();

    for(T L=0.5*dL; L<width_of_bb; L+=dL){
        //First, we precisely specify the ray cast line. u_ray is the unit vector and p_ray is the point defining the line of the ray. It is NOT constrained to the bounding box!
        const vec3<T> p_ray = r_2 + r_n*L;

        //Now we find which pairs of points are joined by a line which intersects the ray cast line. We determine the precise point where the pair of point's line intersects the ray cast line.
        std::vector< vec3<T> > intersection_points;

        //Get all intersection points.
        const plane<T> theplane( r_n, p_ray ); 
       {
        auto iter_1 = (*this).points.begin();
        auto iter_2 = ++((*this).points.begin());
        for( ;  iter_2 != (*this).points.end();  ++iter_2, ++iter_1){
            vec3<T> intersection;
            if( (theplane.Is_Point_Above_Plane( (*iter_1) ) != theplane.Is_Point_Above_Plane( (*iter_2) )) && theplane.Intersects_With_Line(line<T>((*iter_1), (*iter_2)), intersection) ){
                intersection_points.push_back( intersection );
            }
        }
       }

        //Now we sort the intersections based on their distance from the edge of the bounding box. This is required because the contour can snake around any number of ways, and we might
        // not start circling the contour at the point nearest the first ("lowest") intersection.
        auto lambda_distance_along_u_ray = [u_ray](const vec3<T> &a, const vec3<T> &b) -> bool { return (u_ray.Dot(a) < u_ray.Dot(b)); };

        std::sort(intersection_points.begin(), intersection_points.end(), lambda_distance_along_u_ray );
 
        //Now, given the total number of intersections, we can compute the total length of the ray cast which is within the contour.
        if( (intersection_points.size() % 2) != 0 ){
            FUNCERR("We have crossed an odd number of contour lines, but we should have crossed an even number.");
        }else if( intersection_points.size() == 0 ){
            FUNCERR("We failed to find any points of intersection. This is likely an issue with the bounding box or the data being wonky. This could be due to multi-contour input - if so, fix me please!");
        }

        T contour_length_at_this_L = 0.0;
        for(size_t i=0; (2*i)<intersection_points.size(); ++i){
            contour_length_at_this_L += intersection_points[2*i + 0].distance( intersection_points[2*i + 1] );
        }

        //Knowing this total length, we can walk through the intersection points until we find the point which is halfway through the contour (but which is somewhere inside the contour!)
        vec3<T> the_center_point;
        T remaining_contour_halfway_length = 0.5*contour_length_at_this_L;
        bool found_a_center_point = false;
        for(size_t i=0; (2*i)<intersection_points.size(); ++i){
            const T separation = intersection_points[2*i + 0].distance( intersection_points[2*i + 1] );

            //If we do not terminate the search for the halfway point within this pair of intersection points.
            if( remaining_contour_halfway_length > separation ){
                remaining_contour_halfway_length -= separation;

            //If we DO terminate between this pair.
            }else{
                found_a_center_point = true;
                the_center_point = intersection_points[2*i + 0] + u_ray * remaining_contour_halfway_length;
                break;
            }
        }

        //Knowing this point, we push it back into the list of halfway points. Since we have walked the bounding box in a specific way, we will be able to place the point with the correct contour given
        // its location in the halfway point vector.
        if(found_a_center_point == true){
            halfway_points.push_back( the_center_point );
        }else{
            FUNCERR("Was unable to find a center-point. This is an algorithmic error.");
        }

    }

    if( halfway_points.size() == 0 ){
        FUNCWARN("No mid-contour points were generated. Not exactly sure why.. Maybe insufficient number of points were requested?");
        return output;
    }

    //We should now have an ordered list of center points which split the contour. We just have to figure out where best to attach them to the contour endpoints.
    // We take the two (newly-generated) endpoints and determine which contour point is nearest to them. We then split the contours on these points.

    vec3<T> nearest_first( (*this).points.front() );
    vec3<T> nearest_last( (*this).points.front() );
    vec3<T> halfway_first = halfway_points.front();
    vec3<T> halfway_last  = halfway_points.back();

    long int offset_first = 0;
    long int offset_last  = 0;
    for(auto it = (*this).points.begin(); it != (*this).points.end(); ++it ){
        if( halfway_first.distance( (*it) ) < halfway_first.distance( nearest_first ) ){
            nearest_first = (*it);
            offset_first = std::distance( (*this).points.begin(), it );
        }
        if( halfway_last.distance( (*it) )  < halfway_last.distance(  nearest_last )  ){
            nearest_last  = (*it);
            offset_last = std::distance( (*this).points.begin(), it );
        }
    }

    //At this point, the contour is split into two pieces. We enter the contour loop by inserting the halfway points and then looping around as needed.
    std::vector< vec3<T> > contour_A;  //Goes in direction from first to last along the halfway points.
    std::vector< vec3<T> > contour_B;  //Goes in direction from last to first along the halfway points.

    for(long int i=0; i < static_cast<long int>(halfway_points.size()); ++i){
        contour_A.push_back( halfway_points[i] );
        contour_B.push_back( halfway_points[(halfway_points.size() - 1) - i] );
    }

    { //Contour A.
      bool passed_first = false;
      bool passed_last  = false;
      long int i=0;
      while(!(passed_first && passed_last)){
          const long int ii = i%(*this).points.size();
          if( ii == offset_last ){
              passed_last = true;  //Start pushing points and watching for the first point during this iteration.
          }
          if( (ii == offset_first) && (passed_last == true) ){
              passed_first = true; //Exit the loop after this iteration (we need both first and last endpoints on the contours.)
          }
          if(passed_last == true){
              auto it = (*this).points.begin();
              std::advance(it, ii);
              contour_A.push_back( (*it) );
          }
          ++i;
      }
    }

    { //Contour B.
      bool passed_first = false;
      bool passed_last  = false;
      long int i=0;
      while(!(passed_first && passed_last)){
          const long int ii = i%(*this).points.size();
          if( (ii == offset_last) && (passed_first == true) ){
              passed_last = true;  //Exit the loop after this iteration (we need both first and last endpoints on the contours.)
          }
          if( ii == offset_first ){
              passed_first = true; //Start pushing points and watching for the first point during this iteration.
          }
          if(passed_first == true){
              auto it = (*this).points.begin();
              std::advance(it, ii);
              contour_B.push_back( (*it) );
          }
          ++i;
      }
    }


   {
    contour_of_points<T> temp;
    for(size_t i=0; i<contour_A.size(); ++i){
        temp.points.push_back( contour_A[i] );
    }
    output.push_back( temp );
   }

   {
    contour_of_points<T> temp;
    for(size_t i=0; i<contour_B.size(); ++i){
        temp.points.push_back( contour_B[i] );
    }
    output.push_back( temp );
   }
 
    return output;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
template std::list< contour_of_points<double> > contour_of_points<double>::Split_Against_Ray( const vec3<double> & ) const;
template std::list< contour_of_points<float> > contour_of_points<float>::Split_Against_Ray( const vec3<float> & ) const;
#endif



//This function sums all the contour points and divides by the number of points, giving the 'average' point. This could be used as a 
// center point, a rough indication of 'where' a contour is, or as a means of rotating the contour.
template <class T> vec3<T> contour_of_points<T>::Average_Point(void) const {
    vec3<T> out((T)(0), (T)(0), (T)(0));
    for(auto iter = (*this).points.begin(); iter != (*this).points.end(); ++iter){
        out += (*iter);
    }
    out /= (*this).points.size();
    return out;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<float> contour_of_points<float>::Average_Point(void) const;
    template vec3<double> contour_of_points<double>::Average_Point(void) const;
#endif


//This function returns the 'average pointed weighted by the area enclosed by the contour.' In other words, this returns the 
// center of mass of contour if the contour were filled with a homogeneous medium with a planar mass density.
//
//Splitting a contour on this point (along a straight line in the plane of the contour which intersects this point) will 
// result in two or more contours. 
//
// NOTE: This routine will *NOT* provide a point about which to generically split a contour into parts of equal area, despite
// what you may have read online about 'centroids.' If you do not believe this to be true, compute the centroid for a simple
// right triangle and then split it into two parts using a straight line of non-round-number slope. Compute the area of each
// piece and examine that it is not what you might expect. In particular, if the result is "off by a bit," observe that the
// difference IS off by a bit! There is no such generic "splits it into two" point even for a simple polygon!
//
template <class T> vec3<T> contour_of_points<T>::Centroid(void) const {

    //If there are pathological cases, we can deal with them fairly easily.
    if(this->points.size() == 0) FUNCERR("Attempted to compute Center of area for a contour with no points");
    if(this->points.size() < 3){
         vec3<T> R((T)(0), (T)(0), (T)(0));

         for(auto i = this->points.begin(); i != this->points.end(); i++){
             R += *i;
         }
         R /= static_cast<T>( this->points.size() );
         return R;
    }

    //First, we determine the average contour point. We hope that this within the contour. 
    // Any point interior to the contour should work.
    const vec3<T> C( this->Average_Point() );
    vec3<T> RA((T)(0), (T)(0), (T)(0));
    T Area = (T)(0);

    //Cycle through the points in the contour sequentially, accumulating the area and area*center of the 
    // triangle made by two neighbouring points (A and B) and the center point (C).
    contour_of_points<T> temp_contour;
    temp_contour.closed = true;
    auto j = --( this->points.end() );
    for(auto i = this->points.begin(); i != this->points.end(); j = i++){
        const vec3<T> A = *j;
        const vec3<T> B = *i;

        temp_contour.points.clear();
        temp_contour.points.push_back(C);
        temp_contour.points.push_back(A);
        temp_contour.points.push_back(B);

        const T area = temp_contour.Get_Signed_Area();
        const vec3<T> r_a( temp_contour.Average_Point() );

//The problem with these is that the result we get is not a signed distance... (I think.)
//..it is a shame, too, because creating a contour_of_points/populating a list each time is hard on the stack.
//        const T area = ((A-C).Cross(B-C)).length() * (T)(0.5);  //The area of the triangle ABC.
//        const T area = std::sqrt(((A-C).Cross(B-C)).Dot( (A-C).Cross(B-C) )) * (T)(0.5);  //The area of the triangle ABC.

//        const T area = std::sqrt(((A).Cross(B)).Dot( (A).Cross(B) )) * (T)(0.5);  //The area of the triangle ABC.
//        const vec3<T> r_a( (A + B) / (T)(3.0) );               //The center of the triangle.

//FUNCINFO("The current area is " << area << " and the current RA is " << r_a);

        Area += area;
        RA += r_a * area;

    }
    return RA/Area;
}

#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template vec3<float> contour_of_points<float>::Centroid(void) const;
    template vec3<double> contour_of_points<double>::Centroid(void) const;
#endif


//This routine performs (numerical) contour integration over the contour with the provided (scalar-valued) kernel.
//
// More precisely, this function computes:  $ \Chi = \sum_{i=1}^{N} \Chi_{i} $ where the summation is over the 
// straight line segments between contour points, and 
//  $ \Chi_{i} = \int_{\vec{A_{i}}}^{\vec{B_{i}}}  k( \vec{r}; \vec{A_{i}}, \vec{B_{i}} ) ds $
// or, equivalently,
//  $ \Chi_{i} = \int_{0}^{1} k( \vec{r(t)}; \vec{A_{i}}, \vec{B_{i}} ) q_{i} dt $
// where $ q_{i} \equiv | \vec{B_{i}} - \vec{A_{i}} | \equiv | \vec{U_{i}} |.$
//
//Most importantly, the kernel cannot depend on any additional parameters over the duration of the integration.
// The factors passed to the kernel may or may not be used: U is passed in as a convenience, but it is merely B-A.
//
//NOTE: This routine is robust with regard to whether or not the contour is closed, and can handle fully-3D 
// contours.
//
//NOTE: This is a numerical scheme. The actual integration is the weakest aspect: it should be upgraded ASAP. FIXME.
template <class T>    T contour_of_points<T>::Integrate_Simple_Scalar_Kernel(std::function<    T    (const vec3<T> &r,  const vec3<T> &A, const vec3<T> &B, const vec3<T> &U)> k) const {
    T out = 0.0;

    if(!k){
        FUNCERR("This routine requires a scalar kernel. If no kernel is required, provide a function which always gives 1.0");
    }

    for(auto p1_it = this->points.begin(); p1_it != this->points.end(); ++p1_it){
        //Set up the points. Loop point B (point 2) around to the first point if the contour is closed.
        auto p2_it = p1_it;
        ++p2_it;
        if(p2_it == this->points.end()){
            if(this->closed == true){
                p2_it = this->points.begin();
            }else{
                break;
            }
        }

        const vec3<T> A = *p1_it;
        const vec3<T> B = *p2_it;
        const vec3<T> U = B - A;
        //const vec3<T> U_unit = U.unit();
        const T U_length = U.length();

        //Perform a simple numerical integration.
        T tot = 0.0;
        const T dt = 0.0001;
        for(T t = 0.0; t <= (1.0-dt); t += dt){
            const T t0 = t;
            const T t1 = t + dt;
            const T p0 = k( A + U*t0,   A, B, U);
            const T p1 = k( A + U*t1,   A, B, U);
            tot += 0.5*(p0 + p1)*dt;
        }
        out += tot * U_length;
    }
    return out;
}

#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float  contour_of_points<float >::Integrate_Simple_Scalar_Kernel(std::function< float  (const vec3<float > &r,  const vec3<float > &A, const vec3<float > &B, const vec3<float > &U)> k) const;
    template double contour_of_points<double>::Integrate_Simple_Scalar_Kernel(std::function< double (const vec3<double> &r,  const vec3<double> &A, const vec3<double> &B, const vec3<double> &U)> k) const;
#endif


//This routine performs (numerical) contour integration over the contour with the provided (vector-valued) kernel.
//
// More precisely, this function computes:  $ \Chi = \sum_{i=1}^{N} \Chi_{i} $ where the summation is over the 
// straight line segments between contour points, and 
//  $ \Chi_{i} = \int_{\vec{A_{i}}}^{\vec{B_{i}}}  k( \vec{r}; \vec{A_{i}}, \vec{B_{i}} ) d\vec{r} $
// or, equivalently,
//  $ \Chi_{i} = \int_{0}^{1} k( \vec{r(t)}; \vec{A_{i}}, \vec{B_{i}} ) \vec{U}_{i} dt $
// where $ \vec{U_{i}} \equiv \vec{B_{i}} - \vec{A_{i}} .$
//
//Most importantly, the kernel cannot depend on any additional parameters over the duration of the integration.
// The factors passed to the kernel may or may not be used: U is passed in as a convenience, but it is merely B-A.
//
//NOTE: This routine is robust with regard to whether or not the contour is closed, and can handle fully-3D 
// contours.
//
//NOTE: This is a numerical scheme. The actual integration is the weakest aspect: it should be upgraded ASAP. FIXME.
template <class T>    T contour_of_points<T>::Integrate_Simple_Vector_Kernel(std::function< vec3<T> (const vec3<T> &r,  const vec3<T> &A, const vec3<T> &B, const vec3<T> &U)> k) const{
    T out = 0.0;
    if(!k){
        FUNCERR("This routine requires a vector kernel. If no kernel is required, figure out how to provide a static kernel to do what you want.");
    }

    for(auto p1_it = this->points.begin(); p1_it != this->points.end(); ++p1_it){
        //Set up the points. Loop point B (point 2) around to the first point if the contour is closed.
        auto p2_it = p1_it;
        ++p2_it;
        if(p2_it == this->points.end()){
            if(this->closed == true){
                p2_it = this->points.begin();
            }else{
                break;
            }
        }
        const vec3<T> A = *p1_it;
        const vec3<T> B = *p2_it;
        const vec3<T> U = B - A;
        //const vec3<T> U_unit = U.unit();
        const T U_length = U.length();

        //Perform a simple numerical integration.
        T tot = 0.0;
        const T dt = 0.0001;
        for(T t = 0.0; t <= (1.0-dt); t += dt){
            const T t0 = t;
            const T t1 = t + dt;
            const T p0 = U.Dot( k( A + U*t0,   A, B, U) );
            const T p1 = U.Dot( k( A + U*t1,   A, B, U) );
            tot += 0.5*(p0 + p1)*dt;
        }
        out += tot * U_length;
    }
    return out;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float  contour_of_points<float >::Integrate_Simple_Vector_Kernel(std::function< vec3<float > (const vec3<float > &r,  const vec3<float > &A, const vec3<float > &B, const vec3<float > &U)> k) const;
    template double contour_of_points<double>::Integrate_Simple_Vector_Kernel(std::function< vec3<double> (const vec3<double> &r,  const vec3<double> &A, const vec3<double> &B, const vec3<double> &U)> k) const;
#endif


//This routine produces a very simple, default plot of the data. If more customization is required, you'll have to look elsewhere!
template <class T> void contour_of_points<T>::Plot(void) const {
    Plotter a_plot;
    a_plot.ss << "# Default, simple plot for Contour of points: " << std::endl;
    for(auto iter = (*this).points.begin(); iter != (*this).points.end(); ++iter){
        a_plot.ss << (*iter).x << " ";
        a_plot.ss << (*iter).y << " ";
        //a_plot.ss << (*iter).z << " ";
        a_plot.ss << std::endl;
    }
    a_plot.Plot();
    return;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template void contour_of_points<float>::Plot(void) const;
    template void contour_of_points<double>::Plot(void) const;
#endif







//---------------------------------------------------------------------------------------------------------------------------
//--------------------- samples_1D: a convenient way to collect a sequentially-sampled array of data ------------------------
//---------------------------------------------------------------------------------------------------------------------------
template <class T>    samples_1D<T>::samples_1D(){ }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template samples_1D<float>::samples_1D(void);
    template samples_1D<double>::samples_1D(void);
#endif

template <class T>    samples_1D<T>::samples_1D(const std::list< vec2<T> > &in_samps) : samples(in_samps)  { }
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template samples_1D<float>::samples_1D(const std::list< vec2<float> > &in_points);
    template samples_1D<double>::samples_1D(const std::list< vec2<double> > &in_points);
#endif

template <class T>   T samples_1D<T>::Interpolate_Linearly(const T &x) const {
    //Step 0 - Sanity checks.
    if(this->samples.size() < 2) FUNCERR("Unable to interpolate - there are less than 2 samples");

    //Step 1 - Check if the point is within the endpoints. 
    const T first_x = (*(this->samples.begin())).x;
    const T last_x  = (*(this->samples.rbegin())).x;

    const bool Ordered_Low_First = (first_x < last_x) ? true : false;
    const T lowest_x  = (first_x < last_x) ? first_x : last_x;
    const T highest_x = (first_x < last_x) ? last_x  : first_x;

    if(!isininc(lowest_x, x, highest_x)){
        //Here will we 'interpolate' to zero. I *think* this is makes the most mathematical sense.
        return (T)(0.0);
    }

    //Step 2 - Check if the point is bounded by two samples (or if it is sitting exactly on a sample.)
//    bool bounded = false;
    T x0, x1, y0, y1;
    for(auto it0 = this->samples.begin(); it0 != this->samples.end(); ++it0){
        auto it1 = it0;
        ++it1;

        if(Ordered_Low_First){
            if( isininc( it0->x, x, it1->x ) ){
                //Check if the point is *exactly* on a sample. Important for integer ("bin") samples.
                if( x == it0->x ) return it0->y;
                if( x == it1->x ) return it1->y;

//                bounded = true;
                x0 = it0->x;   x1 = it1->x;
                y0 = it0->y;   y1 = it1->y;
                break;
            }
        }else{
            if( isininc( it1->x, x, it0->x ) ){
                //Check if the point is *exactly* on a sample. Important for integer ("bin") samples.
                if( x == it0->x ) return it0->y;
                if( x == it1->x ) return it1->y;

//                bounded = true;
                x0 = it1->x;   x1 = it0->x;
                y0 = it1->y;   y1 = it0->y;
                break;
            }
        }
    }

    //Step 3 - Given a (distinct) lower and an upper point, we perform the linear interpolation.
    return y0 + ( y1 - y0 ) * (x - x0)/( x1 - x0 );
}

#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float samples_1D<float>::Interpolate_Linearly(const float &x) const;
    template double samples_1D<double>::Interpolate_Linearly(const double &x) const;
#endif


template <class T> void samples_1D<T>::Order_Data_Lowest_First(void){
    this->samples.sort( []( vec2<T> A, vec2<T> B ) -> bool { return A.x < B.x; } );
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template void samples_1D<float>::Order_Data_Lowest_First(void);
    template void samples_1D<double>::Order_Data_Lowest_First(void);
#endif

template <class T> void samples_1D<T>::Order_Data_Lowest_Last(void){
    this->samples.sort( []( vec2<T> A, vec2<T> B ) -> bool { return A.x > B.x; } );
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template void samples_1D<float>::Order_Data_Lowest_Last(void);
    template void samples_1D<double>::Order_Data_Lowest_Last(void);
#endif


template <class T>
template <class Function> T samples_1D<T>::Integrate_Generic(const samples_1D<T> &g, Function F) const {
    //Computes the generic integral: \int_{-inf}^{inf} F(f(x), g(x), x) dx.
    //
    //NOTE: This function acts a generic backend for the other integration routines.
    //
    //NOTE: The "Function F" template needs only to define:  T operator(T f_x, T g_x, T x). A typical function would be
    // the overlap integration where F = f_x*g_x.
    //
    //History:  - v. 0.0 - simple, inefficient, imprecise midpoint rule w/ interpolation of f and g.
    //
    //Step 0 - Sanity checks.
    if(this->samples.size() < 2) FUNCERR("Unable to interpolate f - there are less than 2 samples");
    if(g.samples.size() < 2) FUNCERR("Unable to interpolate g - there are less than 2 samples");

    //Step 1 - Establish actual endpoints.
    const T f_first_x = (*(this->samples.begin())).x;
    const T f_last_x  = (*(this->samples.rbegin())).x;
    const T g_first_x = (*(g.samples.begin())).x;
    const T g_last_x  = (*(g.samples.rbegin())).x;

    const T f_lowest_x  = (f_first_x < f_last_x) ? f_first_x : f_last_x;
    const T f_highest_x = (f_first_x < f_last_x) ? f_last_x  : f_first_x;
    const T g_lowest_x  = (g_first_x < g_last_x) ? g_first_x : g_last_x;
    const T g_highest_x = (g_first_x < g_last_x) ? g_last_x  : g_first_x;

    const T lowest_x = (f_lowest_x < g_lowest_x) ? f_lowest_x : g_lowest_x;
    const T highest_x = (f_highest_x > g_highest_x) ? f_highest_x : g_highest_x;

    //Step 2 - Given the bounds, we integrate by interpolation.
    const T dx = (highest_x - lowest_x) / (T)(100.0);
    T res = (T)(0.0);
    for(auto x = lowest_x;  x < (highest_x-0.5*dx); x += dx){
//        res += dx * this->Interpolate_Linearly(x+0.5*dx) * g.Interpolate_Linearly(x+0.5*dx);
        res += dx * F( this->Interpolate_Linearly(x+0.5*dx), g.Interpolate_Linearly(x+0.5*dx), x+0.5*dx );
    }
    return res;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float samples_1D<float>::Integrate_Generic(const samples_1D<float> &g, std::function< float(float, float, float)> F) const;
    template double samples_1D<double>::Integrate_Generic(const samples_1D<double> &g, std::function< double(double, double, double)> F) const;
#endif


template <class T>   T samples_1D<T>::Integrate_Overlap(const samples_1D<T> &g) const {
    auto F = [](T f_x, T g_x, T x) -> T {
        return f_x * g_x;
    };
//    return Integrate_Generic<T>< std::function< T (T, T, T)> >(g, F); //Does not compile.
//    return this->template Integrate_Generic<decltype(F)>(g, F);  //Works, but weird syntax!
    return this->Integrate_Generic<decltype(F)>(g, F); //Works.
}

#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template float samples_1D<float>::Integrate_Overlap(const samples_1D<float> &g) const;
    template double samples_1D<double>::Integrate_Overlap(const samples_1D<double> &g) const;
#endif


template <class T>  samples_1D<T> samples_1D<T>::Sum_With(const samples_1D<T> &g) const {
    //Step 0 - Sanity checks.
    if(g.samples.empty()) return samples_1D<T>(this->samples);
    if(this->samples.empty()) return samples_1D<T>();

    samples_1D<T> out;

    auto gcopy = samples_1D<T>( g.samples );
    auto fcopy = samples_1D<T>( this->samples );

    gcopy.Order_Data_Lowest_First();
    fcopy.Order_Data_Lowest_First();

    const T f_first_x = (*(fcopy.samples.begin())).x;
    const T f_last_x  = (*(fcopy.samples.rbegin())).x;
    const T g_first_x = (*(gcopy.samples.begin())).x;
    const T g_last_x  = (*(gcopy.samples.rbegin())).x;

    const T f_lowest_x  = (f_first_x < f_last_x) ? f_first_x : f_last_x;
    const T f_highest_x = (f_first_x < f_last_x) ? f_last_x  : f_first_x;
    const T g_lowest_x  = (g_first_x < g_last_x) ? g_first_x : g_last_x;
    const T g_highest_x = (g_first_x < g_last_x) ? g_last_x  : g_first_x;

//    const T lowest_x = (f_lowest_x < g_lowest_x) ? f_lowest_x : g_lowest_x;
//    const T highest_x = (f_highest_x > g_highest_x) ? f_highest_x : g_highest_x;

    const bool f_is_lowest  = (f_lowest_x  < g_lowest_x)  ? true : false;
    const bool f_is_highest = (f_highest_x > g_highest_x) ? true : false;

//    const bool f_Ordered_Low_First = (f_first_x < f_last_x) ? true : false;
//    const bool g_Ordered_Low_First = (g_first_x < g_last_x) ? true : false;

    //Get the part on the left where only one set of samples lies.
    auto 
    if(f_is_lowest){
        for(auto it = fcopy.samples.begin(); (it != fcopy.samples.end()) && (it->x < g_lowest_x); ++it){
            out.samples.push_back( *it );
        }
    }else{
        for(auto it = gcopy.samples.begin(); (it != gcopy.samples.end()) && (it->x < f_lowest_x); ++it){
            out.samples.push_back( *it );
        }
    }

    //Get the part in between the endpoints, where BOTH functions are. We interpolate here.
    for(auto it = fcopy.samples.begin(); it != fcopy.samples.end(); ++it){
        if( isininc(f_lowest_x, it->x, f_highest_x) && isininc(g_lowest_x, it->x, g_highest_x) ){
//        if((f_lowest_x <= it->x) || (g_lowest_x <= it->x) || (it->x <= f_highest_x) || (it->x <= g_highest_x)){     // <--- why in the fuck is this ||'ed ??

            //Here we interpolate g into f. Interpolation only happens at points of f (i.e. info from g will be lost.)
            out.samples.push_back( /* *it + */ vec2<T>(it->x, it->y + gcopy.Interpolate_Linearly(it->x))  );

            //Alternatively, we could interpolate f into g.

            //The most rigorous thing to do is do BOTH, but this could quickly become pricey if we do multiple sums...

            // ... TODO ...

        }
    }


    //Get the part in between the endpoints, where BOTH functions are. We interpolate here.
    auto 






    //Get the part on the right where only one set of samples lies.
    if(f_is_highest){
        for(auto it = fcopy.samples.begin(); it != fcopy.samples.end(); ++it){
            if(it->x > g_highest_x){
                out.samples.push_back( *it );
            }
        }
    }else{
        for(auto it = gcopy.samples.begin(); it != gcopy.samples.end(); ++it){
            if(it->x > f_highest_x){
                out.samples.push_back( *it );
            }
        }
    }

    return out;
}

#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template samples_1D<float> samples_1D<float>::Sum_With(const samples_1D<float> &in) const;
    template samples_1D<double> samples_1D<double>::Sum_With(const samples_1D<double> &in) const;
#endif

//Normalizes data so that \int_{-inf}^{inf} f(x) (times) f(x) dx ~= 1.
template <class T>   void samples_1D<T>::Normalize_wrt_Self_Overlap(void){
    const T AA = this->Integrate_Overlap( *this );
    const T A  = sqrt(AA);
    for(auto it = this->samples.begin(); it != this->samples.end(); ++it){
        it->y /= A;
    }
    return;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template void samples_1D<float>::Normalize_wrt_Self_Overlap(void);
    template void samples_1D<double>::Normalize_wrt_Self_Overlap(void);
#endif

//This routine produces a very simple, default plot of the data.
//
//NOTE: No attempt is made to ensure the data is ordered - this may or may not be desirable for the user.
template <class T> void samples_1D<T>::Plot(void) const {
    Plotter a_plot;
    a_plot.ss << "# Default, simple plot for 1D sequential samples: " << std::endl;

    for(auto s_it = this->samples.begin(); s_it != this->samples.end(); ++s_it){
        a_plot.ss << s_it->x << " ";
        a_plot.ss << s_it->y << " ";
        a_plot.ss << std::endl;
    }
    a_plot.Plot();
    return;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
    template void samples_1D<float>::Plot(void) const;
    template void samples_1D<double>::Plot(void) const;
#endif



