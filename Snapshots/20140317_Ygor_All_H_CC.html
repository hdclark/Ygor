<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>Enscript Output</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<H1>Contents</H1>
<OL>
  <LI><A HREF="#file1">YgorAlgorithms.h</A>
  <LI><A HREF="#file2">YgorArguments.h</A>
  <LI><A HREF="#file3">YgorCONFIGTools.h</A>
  <LI><A HREF="#file4">YgorContainers.h</A>
  <LI><A HREF="#file5">YgorDICOMTools.h</A>
  <LI><A HREF="#file6">YgorEnvironment.h</A>
  <LI><A HREF="#file7">YgorFilesDirs.h</A>
  <LI><A HREF="#file8">YgorImages.h</A>
  <LI><A HREF="#file9">YgorMath.h</A>
  <LI><A HREF="#file10">YgorMath_Samples.h</A>
  <LI><A HREF="#file11">YgorMisc.h</A>
  <LI><A HREF="#file12">YgorNetworking.h</A>
  <LI><A HREF="#file13">YgorNoise.h</A>
  <LI><A HREF="#file14">YgorPerformance.h</A>
  <LI><A HREF="#file15">YgorPlot.h</A>
  <LI><A HREF="#file16">YgorSerialize.h</A>
  <LI><A HREF="#file17">YgorStats.h</A>
  <LI><A HREF="#file18">YgorString.h</A>
  <LI><A HREF="#file19">YgorTime.h</A>
  <LI><A HREF="#file20">YgorURITools.h</A>
  <LI><A HREF="#file21">YgorVIDEOTools.h</A>
  <LI><A HREF="#file22">YgorAlgorithms.cc</A>
  <LI><A HREF="#file23">YgorCONFIGTools.cc</A>
  <LI><A HREF="#file24">YgorContainers.cc</A>
  <LI><A HREF="#file25">YgorDICOMTools.cc</A>
  <LI><A HREF="#file26">YgorEnvironment.cc</A>
  <LI><A HREF="#file27">YgorFilesDirs.cc</A>
  <LI><A HREF="#file28">YgorImages.cc</A>
  <LI><A HREF="#file29">YgorMath.cc</A>
  <LI><A HREF="#file30">YgorMath_Samples.cc</A>
  <LI><A HREF="#file31">YgorMisc.cc</A>
  <LI><A HREF="#file32">YgorNetworking.cc</A>
  <LI><A HREF="#file33">YgorNoise.cc</A>
  <LI><A HREF="#file34">YgorPerformance.cc</A>
  <LI><A HREF="#file35">YgorPlot.cc</A>
  <LI><A HREF="#file36">YgorSerialize.cc</A>
  <LI><A HREF="#file37">YgorStats.cc</A>
  <LI><A HREF="#file38">YgorString.cc</A>
  <LI><A HREF="#file39">YgorTime.cc</A>
  <LI><A HREF="#file40">YgorURITools.cc</A>
  <LI><A HREF="#file41">YgorVIDEOTools.cc</A>
</OL>
<HR>
<A NAME="file1">
<H1>YgorAlgorithms.h 1/41</H1>
[<A HREF="#top">top</A>][prev][<A HREF="#file2">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorAlgorithms.h - A collection of some custom (niche?) algorithms. This includes things like multidimensional minimization
</FONT></I><I><FONT COLOR="#B22222">// routines (and other 'algorithm'-sorts of classes.)
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_CUSTOM_ALGORITHMS_HC_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_CUSTOM_ALGORITHMS_HC_</FONT>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_CUSTOM_ALGORITHMS_HC_ATTEMPT_ASYNCHRONOUS</FONT>
    #define YGOR_CUSTOM_ALGORITHMS_HC_ATTEMPT_ASYNCHRONOUS
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>



#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstddef&gt;</FONT></B>       //Needed for ptrdiff_t
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;functional&gt;</FONT></B>    //Needed to (easily) accept lambda functions in higher-order functions.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>     //Needed for random_shuffle(...)
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;random&gt;</FONT></B>        //Needed for std::random_device.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;tuple&gt;</FONT></B>


<I><FONT COLOR="#B22222">//NOTE: It is *probably* better to NOT use an aggressive attempt to force asynchronicity!
</FONT></I><I><FONT COLOR="#B22222">// Exceptions can result otherwise, and my (more modern) laptop calls asynchronously whenever
</FONT></I><I><FONT COLOR="#B22222">// possible anyways. Ygor (older) desktop cannot handle it, though, and pukes out a non-catchable
</FONT></I><I><FONT COLOR="#B22222">// exception if forced.
</FONT></I><I><FONT COLOR="#B22222">// 
</FONT></I><I><FONT COLOR="#B22222">//#ifdef YGOR_CUSTOM_ALGORITHMS_HC_ATTEMPT_ASYNCHRONOUS
</FONT></I><I><FONT COLOR="#B22222">//    #include &lt;system_error&gt;  //Needed to launch non-deferrable std::async(..)'s.
</FONT></I><I><FONT COLOR="#B22222">//#endif
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stdexcept&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;future&gt;</FONT></B>
<I><FONT COLOR="#B22222">//#include &lt;chrono&gt;
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMath.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorPlot.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------- NMSimplex ----------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Implements the &quot;Nelder-Mead simplex&quot; (or &quot;Downhill simplex,&quot; or &quot;Amoeba&quot;) method in double precision.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This code was written mostly by referring to Numerical Recipes and the GNU Scientific Library. It is my belief
</FONT></I><I><FONT COLOR="#B22222">// that it does not follow so closely to either as to infringe on either of their copyrights. However, care should be 
</FONT></I><I><FONT COLOR="#B22222">// exercised if planning on releasing this code. Perhaps a complete re-write and/or modification would be in order.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Numerical Recipes mentions that the simplex method computes the function more often than other methods and suggests 
</FONT></I><I><FONT COLOR="#B22222">// that Powell's method is usually more effcient.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//For usage details, refer to the test included in the Project - Utilities tests and examples directory.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>template &lt;class T&gt; class NMSimplex{
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
       T alpha, gamma, rho, sigma;   <I><FONT COLOR="#B22222">//Used as input parameters by the method.
</FONT></I>       <B><FONT COLOR="#228B22">int</FONT></B> curr_min;
       <B><FONT COLOR="#228B22">int</FONT></B> curr_max;
       <B><FONT COLOR="#228B22">int</FONT></B> curr_scnd_max;
       <B><FONT COLOR="#228B22">int</FONT></B> DIM;
       T *P_vecs;
       T *func_vals;        <I><FONT COLOR="#B22222">//Stores the function values at each P_vec.
</FONT></I>       T *centroid;         <I><FONT COLOR="#B22222">//Stores (worst-point-excluded) centroid.
</FONT></I>       T *reflec;           <I><FONT COLOR="#B22222">//Stores the reflected point. It is always calculated.
</FONT></I>       T *expand;           <I><FONT COLOR="#B22222">//Stores the expanded point, if it is calculated.
</FONT></I>       T temp_reflec;
       T temp_expand;
       <B><FONT COLOR="#228B22">int</FONT></B> iteration;       <I><FONT COLOR="#B22222">//The current algorithm's iteration.
</FONT></I>       <B><FONT COLOR="#228B22">int</FONT></B> max_iters;
       T last_best;
       T ftol_min;
       T ftol;              <I><FONT COLOR="#B22222">//The amount the function changes by (when it does). This is used as an indicator to halt.
</FONT></I>       <B><FONT COLOR="#228B22">int</FONT></B> init_done;       <I><FONT COLOR="#B22222">//Whether the initialization has been called yet.
</FONT></I>       T c_leng;            <I><FONT COLOR="#B22222">//The characteristic length of the system. IE: A rough scale (0.001, 1.0, 10000,  etc..).
</FONT></I><I><FONT COLOR="#B22222">//       T (*the_func)(T *);  //A reference to the function to be minimized. The (T *) is indicative that 
</FONT></I>       <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;T(T *)&gt; the_func;

        <I><FONT COLOR="#B22222">//Constructor. 
</FONT></I>        NMSimplex(<B><FONT COLOR="#228B22">int</FONT></B> dim, T c_leng_in, <B><FONT COLOR="#228B22">int</FONT></B> max_iters_in, T ftol_min_in){
            DIM = dim;
            c_leng = c_leng_in;
            max_iters = max_iters_in;
            ftol_min = ftol_min_in;

            <I><FONT COLOR="#B22222">//We first need to create (dim+1) vectors.
</FONT></I>            P_vecs =    (T*)malloc((DIM+1)*DIM*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T));  <I><FONT COLOR="#B22222">//This holds all the &quot;P&quot; vectors.
</FONT></I>            <I><FONT COLOR="#B22222">//This vector stores function values at each P vector.
</FONT></I>            func_vals = (T*)malloc((DIM+1)*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T));
            <I><FONT COLOR="#B22222">//Some working space for transferring data.
</FONT></I>            centroid  = (T*)malloc((DIM)*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T));
            reflec    = (T*)malloc((DIM)*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T));
            expand    = (T*)malloc((DIM)*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T));
            alpha = 1.0;  <I><FONT COLOR="#B22222">//Standard values for the Nelder-mead simplex method. Could maybe use some tweaking...
</FONT></I>            gamma = 2.0;
            rho   = 0.5;
            sigma = 0.5;
            iteration = 0;
            ftol = ftol_min * 100.0;
            init_done = 0;          <I><FONT COLOR="#B22222">//This is flipped on when initialization is completed.
</FONT></I>        }

        <I><FONT COLOR="#B22222">//Destructor.
</FONT></I>        ~NMSimplex(<B><FONT COLOR="#228B22">void</FONT></B>){
             free(P_vecs);
             free(func_vals);
             free(centroid);
             free(reflec);
             free(expand);
        }

        <I><FONT COLOR="#B22222">//Minimization routine (single) iteration.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> iter(<B><FONT COLOR="#228B22">void</FONT></B>){
           <B><FONT COLOR="#A020F0">if</FONT></B>(iteration == 0){
               <I><FONT COLOR="#B22222">//For the P* vectors other than P0, we set them equal to a linear combination
</FONT></I>               <I><FONT COLOR="#B22222">// of P0 and the parameter unit vectors using c_leng.
</FONT></I>               <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;=DIM;++i) <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j=0;j&lt;DIM;++j){
                   P_vecs[i*DIM+j] = P_vecs[0*DIM+j];
                   <B><FONT COLOR="#A020F0">if</FONT></B>(i-1 == j) P_vecs[i*DIM+j] += c_leng*1.0;               <I><FONT COLOR="#B22222">//The 1.0 comes from the unit vector.
</FONT></I>               }
               <I><FONT COLOR="#B22222">//Compute all function values. This will be costly but is necessary right now.
</FONT></I>               <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;=DIM;++i) func_vals[i] = the_func(&amp;P_vecs[i*DIM]);
               <I><FONT COLOR="#B22222">//Set the ftol catch to something relevant to the system... (Better idea for this??)
</FONT></I>               last_best = func_vals[0];
               init_done = 1;
           }
           <B><FONT COLOR="#A020F0">if</FONT></B>(iteration &lt;= max_iters &amp;&amp; ftol &gt; ftol_min &amp;&amp; init_done == 1){
               <I><FONT COLOR="#B22222">//Find the worst function value. 
</FONT></I>               curr_max = 0;
               <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;=DIM;++i) <B><FONT COLOR="#A020F0">if</FONT></B>( func_vals[i] &gt; func_vals[curr_max] ) curr_max = i;

               <I><FONT COLOR="#B22222">//Find the second worst function value.
</FONT></I>               curr_scnd_max = 0;
               <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;=DIM;++i) <B><FONT COLOR="#A020F0">if</FONT></B>( i != curr_max ) <B><FONT COLOR="#A020F0">if</FONT></B>( func_vals[i] &gt; func_vals[curr_scnd_max] ) curr_scnd_max = i;

               <I><FONT COLOR="#B22222">//Find the best function value.
</FONT></I>               curr_min = 0;
               <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;=DIM;++i) <B><FONT COLOR="#A020F0">if</FONT></B>( i != curr_max ) <B><FONT COLOR="#A020F0">if</FONT></B>( i != curr_scnd_max ) <B><FONT COLOR="#A020F0">if</FONT></B>( func_vals[i] &lt; func_vals[curr_min] ) curr_min = i;

               <I><FONT COLOR="#B22222">//Update the ftol value.
</FONT></I>               <B><FONT COLOR="#A020F0">if</FONT></B>( last_best != func_vals[curr_min] ){ <I><FONT COLOR="#B22222">//ie: If the value is not *exactly* the previous result.
</FONT></I>                   ftol = fabs(last_best - func_vals[curr_min]);
                   last_best = func_vals[curr_min];
               }
 
               <I><FONT COLOR="#B22222">//Calculate the centroid of all points except the worst one.
</FONT></I>               <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) centroid[i] = 0.0;
               <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;=DIM;++i) <B><FONT COLOR="#A020F0">if</FONT></B>( i != curr_max ) <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j=0;j&lt;DIM;++j) centroid[j] += P_vecs[i*DIM+j];
               <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) centroid[i] /= (T)DIM;

               <I><FONT COLOR="#B22222">//Compute the reflection point.
</FONT></I>               <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) reflec[i] = centroid[i] + alpha*(centroid[i] - P_vecs[curr_max*DIM+i]);

               <I><FONT COLOR="#B22222">//if   f(curr_min) &lt;= f(RECR) &lt; f(curr_max), then replace the worst point with reflec and return.
</FONT></I>               temp_reflec = the_func(reflec);
               <B><FONT COLOR="#A020F0">if</FONT></B>(func_vals[curr_min] &lt;= temp_reflec  &amp;&amp; temp_reflec &lt; func_vals[curr_scnd_max] ){
                   <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) P_vecs[curr_max*DIM+i] = reflec[i];
                   func_vals[curr_max] = temp_reflec;
                   ++iteration;
                   <B><FONT COLOR="#A020F0">return</FONT></B> 0;
               }

               <I><FONT COLOR="#B22222">//The expanded point is a method to try improve the reflected point (if the refl. pnt is good to begin with.)
</FONT></I>               <I><FONT COLOR="#B22222">//It adds another function evaluation and might be able to skipped for very costly functions.
</FONT></I>               <I><FONT COLOR="#B22222">//if the reflected point is the best point yet, then compute the expanded point.
</FONT></I>               <B><FONT COLOR="#A020F0">if</FONT></B>(temp_reflec &lt; func_vals[curr_min]){
                   <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) expand[i] = centroid[i] + gamma*(centroid[i] - P_vecs[curr_max*DIM+i]);
                   <I><FONT COLOR="#B22222">//Choose the point which is best at this point.
</FONT></I>                   temp_expand = the_func(expand);
                   <B><FONT COLOR="#A020F0">if</FONT></B>(temp_expand &lt; temp_reflec){
                       <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) P_vecs[curr_max*DIM+i] = expand[i];
                       func_vals[curr_max] = temp_expand;
                       ++iteration;
                       <B><FONT COLOR="#A020F0">return</FONT></B> 0;
                   }<B><FONT COLOR="#A020F0">else</FONT></B>{
                       <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) P_vecs[curr_max*DIM+i] = reflec[i];
                       func_vals[curr_max] = temp_reflec;
                       ++iteration;
                       <B><FONT COLOR="#A020F0">return</FONT></B> 0;
                   }
               }

               <I><FONT COLOR="#B22222">//Compute the contracted point. We will re-use the reflected point array for efficiency.
</FONT></I>               <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) reflec[i] = centroid[i] + rho*(centroid[i] - P_vecs[curr_max*DIM+i]);
               temp_reflec = the_func(reflec);
               <B><FONT COLOR="#A020F0">if</FONT></B>(temp_reflec &lt; func_vals[curr_max]){
                   <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) P_vecs[curr_max*DIM+i] = reflec[i];
                   func_vals[curr_max] = temp_reflec;
                   ++iteration;
                   <B><FONT COLOR="#A020F0">return</FONT></B> 0;
               }

               <I><FONT COLOR="#B22222">//If we have made it this far, we 'shrink' the simplex. We also recompute the function 
</FONT></I>               <I><FONT COLOR="#B22222">// for the points we have shrunk (all but the curr_min).
</FONT></I>               <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;=DIM;++i) <B><FONT COLOR="#A020F0">if</FONT></B>(i != curr_min){
                   <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j=0;j&lt;DIM;++j) P_vecs[i*DIM+j] = P_vecs[curr_min*DIM+j] + sigma*(P_vecs[i*DIM+j]-P_vecs[curr_min*DIM+j]);
                   func_vals[i] = the_func(&amp;P_vecs[i*DIM]);
               }
               ++iteration;
               <B><FONT COLOR="#A020F0">return</FONT></B> 0;
           <I><FONT COLOR="#B22222">//Check why the scheme is refusing to compute the next iteration.
</FONT></I>           }<B><FONT COLOR="#A020F0">else</FONT></B>{
               <B><FONT COLOR="#A020F0">if</FONT></B>(iteration &gt; max_iters) <B><FONT COLOR="#A020F0">return</FONT></B> 1;
               <B><FONT COLOR="#A020F0">if</FONT></B>(ftol &lt;= ftol_min)      <B><FONT COLOR="#A020F0">return</FONT></B> 2;
               <B><FONT COLOR="#A020F0">return</FONT></B> -1;
           }
        }

        <I><FONT COLOR="#B22222">//void init(T params[], T (&amp;the_func_in)(T *)){
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> init(T params[], std::function&lt;T (T *)&gt; the_func_in){
            <I><FONT COLOR="#B22222">//Set the P0 vector as the params[] array.
</FONT></I>            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) P_vecs[i] = params[i];

            <I><FONT COLOR="#B22222">//Set the_func reference.
</FONT></I>            <I><FONT COLOR="#B22222">//the_func = &amp;the_func_in;
</FONT></I>            the_func = the_func_in;

            init_done = 1;
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        }


        <B><FONT COLOR="#228B22">void</FONT></B> get_params(T params[]){
            curr_min = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;=DIM;++i) <B><FONT COLOR="#A020F0">if</FONT></B>( i != curr_max ) <B><FONT COLOR="#A020F0">if</FONT></B>( i != curr_scnd_max ) <B><FONT COLOR="#A020F0">if</FONT></B>( func_vals[i] &lt; func_vals[curr_min] ) curr_min = i;
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) params[i] = P_vecs[curr_min*DIM+i];
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        }

        <I><FONT COLOR="#B22222">//void get_all(T (&amp;the_func)(T *), T params[], T &amp;func_val){
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> get_all(std::function&lt;T (T *)&gt; the_func, T params[], T &amp;func_val){
            curr_min = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;=DIM;++i) <B><FONT COLOR="#A020F0">if</FONT></B>( i != curr_max ) <B><FONT COLOR="#A020F0">if</FONT></B>( i != curr_scnd_max ) <B><FONT COLOR="#A020F0">if</FONT></B>( func_vals[i] &lt; func_vals[curr_min] ) curr_min = i;
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;DIM;++i) params[i] = P_vecs[curr_min*DIM+i];
            func_val = the_func(params);
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        }

        <B><FONT COLOR="#228B22">void</FONT></B> printout(<B><FONT COLOR="#228B22">void</FONT></B>){
            <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;The function values are currently: &quot;</FONT></B>;
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;=DIM;++i) std::cout &lt;&lt; func_vals[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;  &quot;</FONT></B>;
            <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; at iteration &quot;</FONT></B> &lt;&lt; iteration &lt;&lt; std::endl;
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        }
};



<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------- For_Each_In_Parallel -----------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Given two iterators and a std::function&lt;void(...::iterator )&gt;, this routine will perform the function on each element in parallel.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Execution will block (ie. wait for all tasks to finish) before returning.
</FONT></I>
<I><FONT COLOR="#B22222">//template &lt;class T&gt;
</FONT></I><I><FONT COLOR="#B22222">//void For_Each_In_Parallel(T it, T end, std::function&lt; void ( T )&gt; Task){
</FONT></I><I><FONT COLOR="#B22222">//    if(! Task ){
</FONT></I><I><FONT COLOR="#B22222">//        FUNCWARN(&quot;Task passed in is not valid. Unable to perform any task. Continuing&quot;);
</FONT></I><I><FONT COLOR="#B22222">//        return;
</FONT></I><I><FONT COLOR="#B22222">//    }
</FONT></I>
template &lt;class T, class Function&gt;
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">For_Each_In_Parallel</FONT></B>(T it, T end, Function Task){

    <I><FONT COLOR="#B22222">//Launch the tasks, ensuring to keep the handles so we can tell when the task is completed.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt; std::future&lt;<B><FONT COLOR="#228B22">void</FONT></B>&gt; &gt; handle_keeper;
    <B><FONT COLOR="#A020F0">for</FONT></B>( ; it != end; ++it){
        <I><FONT COLOR="#B22222">//NOTE: We run into problems if we do not OR std::launch::deferred on some platforms. From cpp-info:
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">// &quot;...Throws std::system_error with error condition std::errc::resource_unavailable_try_again if 
</FONT></I>        <I><FONT COLOR="#B22222">//    the launch policy is std::launch::async and the implementation is unable to start a new thread.&quot;
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">//  ..however, if we use  std::launch::async | std::launch::deferred  then we will mostly get lazy 
</FONT></I>        <I><FONT COLOR="#B22222">//  evaluation (anecdotally.) Therefore, we launch as many non-deferrables as we can until an error 
</FONT></I>        <I><FONT COLOR="#B22222">//  is thrown and THEN we switch to deferrables.
</FONT></I>
        decltype(  std::async( std::launch::async, Task, it )  )  newfuture;
        #ifdef YGOR_CUSTOM_ALGORITHMS_HC_ATTEMPT_ASYNCHRONOUS
            <I><FONT COLOR="#B22222">//try{
</FONT></I><I><FONT COLOR="#B22222">//                newfuture = std::async( std::launch::async, Task, it );
</FONT></I>                newfuture = std::async( std::launch::async | std::launch::deferred, Task, it );

                handle_keeper.push_back( std::move( newfuture ) );

            <I><FONT COLOR="#B22222">//}catch(const std::system_error &amp;e){
</FONT></I>                <I><FONT COLOR="#B22222">//...
</FONT></I>            <I><FONT COLOR="#B22222">//}catch(const std::exception &amp;e){
</FONT></I>                <I><FONT COLOR="#B22222">//...
</FONT></I>            <I><FONT COLOR="#B22222">//}
</FONT></I>        #<B><FONT COLOR="#A020F0">else</FONT></B>
            Task(it);    
<I><FONT COLOR="#B22222">//            newfuture = std::async( std::launch::async | std::launch::deferred, Task, it );
</FONT></I><I><FONT COLOR="#B22222">//            handle_keeper.push_back( std::async( std::launch::async | std::launch::deferred, Task, it ) );
</FONT></I>
        #endif

    };

    <I><FONT COLOR="#B22222">//Wait on the tasks in the same order we have launched them.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> h_it = handle_keeper.begin(); h_it != handle_keeper.end(); ++h_it){
        h_it-&gt;get();
    }

    <B><FONT COLOR="#A020F0">return</FONT></B>;
}


<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------- Shuffle Algorithms ----------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I>template&lt;typename T&gt; <B><FONT COLOR="#228B22">void</FONT></B> shuffle_list_consistently( std::list&lt;T&gt; &amp;mylist ){
    <I><FONT COLOR="#B22222">//Uses a consistent scheme to shuffle. Repeated calls will return the same order.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: I don't know how it is implemented, so do not depend on the consistency!
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;T&gt; v( mylist.begin(), mylist.end() );
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::random_shuffle( v.begin(), v.end() );
    mylist.assign( v.begin(), v.end() );
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

template&lt;typename T&gt; <B><FONT COLOR="#228B22">void</FONT></B> shuffle_list_randomly( std::list&lt;T&gt; &amp;mylist ){
    <I><FONT COLOR="#B22222">//Uses a (&quot;truly random&quot;) random device to shuffle. The shuffling will be different upon repeated calls.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::random_device rd;
    <B><FONT COLOR="#228B22">auto</FONT></B> shuffle_func = [&amp;rd](ptrdiff_t i){ <B><FONT COLOR="#A020F0">return</FONT></B> rd()%i; };  <I><FONT COLOR="#B22222">//This *may* not be suitable for large lists. See rd.max() for upper bound.
</FONT></I>
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;T&gt; v( mylist.begin(), mylist.end() );
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::random_shuffle( v.begin(), v.end(), shuffle_func);
    mylist.assign( v.begin(), v.end() );
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

template&lt;typename T&gt; <B><FONT COLOR="#228B22">void</FONT></B> shuffle_list( std::list&lt;T&gt; &amp;mylist ){
    <I><FONT COLOR="#B22222">//Default 'shuffle' is a consistent one. It is not a true random shuffle, but is reproducable with repeated calls.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: I don't know how it is implemented, so do not depend on the consistency!
</FONT></I>    shuffle_list_consistently(mylist);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}



<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------- Nonparametric Regression ----------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//These routines implement 'local linear nonparametric regression' or smoothing on arbitrary (ordered) 1D data. The 
</FONT></I><I><FONT COLOR="#B22222">// implementation is based on the chapter 'Nonparametric regression' from Larry Wasserman's &quot;All of Nonparametric Statistics&quot;.
</FONT></I><I><FONT COLOR="#B22222">// Everything was kept outside of a class for sanity and flexibility. Down the road, higher-order p versions might be 
</FONT></I><I><FONT COLOR="#B22222">// implemented (currently only p=1 is supported).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//See the test files for some examples of how to use these functions.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTES: 
</FONT></I><I><FONT COLOR="#B22222">//  1) These routines require data to be ordered (I think lowest-to-highest x, but it might not be a problem with high-to-low).
</FONT></I><I><FONT COLOR="#B22222">//  2) These routines require a decent amount of data to function. They are not worthwhile for small amounts of data (ie. a 
</FONT></I><I><FONT COLOR="#B22222">//     few points) and should not be used in those cases anyways!
</FONT></I><I><FONT COLOR="#B22222">//  3) This is Smoothing/REGRESSION. Do *NOT* extrapolate using these routines. You'd have to be crazy to think it would work!
</FONT></I><I><FONT COLOR="#B22222">//  4) A very bad integration is performed when determining k0 (used for computing 'c'). It compares ~ok with Wasserman's 
</FONT></I><I><FONT COLOR="#B22222">//     example numbers, but is nowhere near exact (or stable). It would be a good idea to take the confidence bars with a 
</FONT></I><I><FONT COLOR="#B22222">//     grain of salt. In fact, only first-order terms are used / normal errors are assumed / some assumptions are slightly
</FONT></I><I><FONT COLOR="#B22222">//     violated in most cases. This will require a redo if it becomes a problem!
</FONT></I><I><FONT COLOR="#B22222">//     Currently, the percent error in computed c's is asymptotically off by 5-10% in most cases (at 95% confidence interval).
</FONT></I><I><FONT COLOR="#B22222">//     It is safest to compute 95% or 99% confidence intervals.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//General Usage Idea:
</FONT></I><I><FONT COLOR="#B22222">//  Grab some data. Choose a starting h (smoothing parameter) to encompass about 100x the normal point spacing. Choose a scale
</FONT></I><I><FONT COLOR="#B22222">//  for h to be about 10-50x the normal point spacing. Perform Find_Optimal_H(...) routine to find the optimal smoothing h.
</FONT></I><I><FONT COLOR="#B22222">//  Now, use the Get_Smoothed_at_X(...) function to evaluate the smoothed function at whatever x is desired.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  If desired, one can proceed to find X% confidence bars (for the fit - NOT for the data!). This is a fairly arduous task.
</FONT></I><I><FONT COLOR="#B22222">//  See the examples to see how it is done. Do not rely on the confidence bands for anything important. They are not perfect.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>namespace NPRLL { <I><FONT COLOR="#B22222">//NPRLL - Non-Parametric Regression: Local Linear Smoothing.
</FONT></I>    
    <I><FONT COLOR="#B22222">//------- Functions to get a single value of a distribution ---------
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> Get_Smoothed_at_X(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, bool *OK);
    <B><FONT COLOR="#228B22">double</FONT></B> Get_Conf_at_X(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">double</FONT></B> conf_h, <B><FONT COLOR="#228B22">double</FONT></B> c, <B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;log_mse_data_in, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;data, bool *OK);
    
    <I><FONT COLOR="#B22222">//------- Routines which 'score' a given parameter in terms of some risk function. --------
</FONT></I>    <I><FONT COLOR="#B22222">//These typically are very similar. The user won't need these unless performing a visual inspection.
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> Get_Cross_Validation_Leave_One_Out(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in);
    <B><FONT COLOR="#228B22">double</FONT></B> Get_Cross_Validation_Generalized_CV(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in);
    
    <I><FONT COLOR="#B22222">//------- Routines to find or estimate parameters --------
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> Find_Optimal_H(<B><FONT COLOR="#228B22">double</FONT></B> h_0, <B><FONT COLOR="#228B22">double</FONT></B> h_scale, <B><FONT COLOR="#228B22">double</FONT></B> cv_tol, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N_iters, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, bool show_info, bool *OK);
    
    <I><FONT COLOR="#B22222">//This function computes an estimate of 'c' - the 'confidence' scale which is used in computing the confidence bands.
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> Find_C(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">double</FONT></B> confidence, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, bool *OK);
    
    
    <I><FONT COLOR="#B22222">//This function takes the data's optimal h and returns log(MSE) data which is itself suitable for regression.
</FONT></I>    samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; Log_of_MSE(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, bool *OK);
    
    <I><FONT COLOR="#B22222">//------- Canned routines for more easily sampling the smoothed function/confidence bands. --------
</FONT></I>    <I><FONT COLOR="#B22222">//Return constant-separation (dx) smoothed function data.
</FONT></I>    samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; Get_Smoothed_Evenly_Spaced(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">double</FONT></B> dx, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, bool *OK);
    <I><FONT COLOR="#B22222">//For the given input (x_i,y_i), generate a smoothed output (x_i,s_y_i) on the same x_i.
</FONT></I>    samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; Get_Smoothed_at_Xi(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, bool *OK);
    
    <I><FONT COLOR="#B22222">//------- Convenience, all-in-one routines ---------
</FONT></I>    samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; Attempt_Auto_Smooth(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, bool *OK); <I><FONT COLOR="#B22222">//Gives back the data.
</FONT></I>
    <I><FONT COLOR="#B22222">//Does several things. Useful for exploring the data. Outputs a lot of stuff, though.
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> Attempt_Auto_Analysis(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;Title = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, bool only_show_final = false, Plotter2 *plotter = nullptr, bool *OK = nullptr);

} <I><FONT COLOR="#B22222">//end of namespace NPRLL.
</FONT></I>

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------- Architecture-independant Non-cryptographic Hashes --------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//For most purposes, the std::hash would be sufficient. When talking across a network (to same-endian machines) these will
</FONT></I><I><FONT COLOR="#B22222">// produce identical results, whereas the C++11 standard hashes are not required to.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Currently using SpookyHash (in External). 
</FONT></I>uint64_t <B><FONT COLOR="#0000FF">Consistent_Hash_64</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);

<I><FONT COLOR="#B22222">//MD5 hash. Implemented in External.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;uint8_t[]&gt; MD5_Hash(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t bytecnt, std::string *hash);


<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------- Fitting Algorithms ----------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//These routines perform simple (somewhat constrained) fitting to a function.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//They are around primarily because they are easy to tweak (compared with black boxes) and for speed (compared with highly-
</FONT></I><I><FONT COLOR="#B22222">// flexible, but currently slow-as-hell PolyCAS routines).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  For fitting of type f(x) :
</FONT></I><I><FONT COLOR="#B22222">//      -If there are 2 columns, weighting is not considered.
</FONT></I><I><FONT COLOR="#B22222">//      -If there are 3 columns, it is assumed they are &lt;Xi,Yi,Uncertainty in Yi&gt;
</FONT></I><I><FONT COLOR="#B22222">//      -The functional form must ONLY accept parameters as arguments, and return a double.
</FONT></I><I><FONT COLOR="#B22222">//      -The input parameters are taken as initial parameters AND used to specify the number of fitting parameters to use.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>namespace YGORFIT { 
    <B><FONT COLOR="#228B22">const</FONT></B> uint32_t DIM2 = (1 &lt;&lt; 0);  <I><FONT COLOR="#B22222">//2-dimensional (with or without user-provided Y_i uncertainties).
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> uint32_t DIM3 = (1 &lt;&lt; 1);  <I><FONT COLOR="#B22222">//3-dimensional (with or without user-provided Z_i uncertainties).
</FONT></I>  
    <B><FONT COLOR="#228B22">const</FONT></B> uint32_t LSS =  (1 &lt;&lt; 2);  <I><FONT COLOR="#B22222">//Least sum of squares.  The generally-recommended version.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> uint32_t LMS =  (1 &lt;&lt; 3);  <I><FONT COLOR="#B22222">//Least-median squares.  This version is more robust wrt outliers.
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> uint32_t NON_CONVERG_IS_ERR = (1 &lt;&lt; 4); <I><FONT COLOR="#B22222">//Report failure if it didn't converge. Default is &quot;no error&quot;.
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> uint32_t UNCERT_CAUCHY = (1 &lt;&lt; 5); <I><FONT COLOR="#B22222">//Override uncertainties and use a Cauchy distribution instead (see source).
</FONT></I>} <I><FONT COLOR="#B22222">//end of namespace YGORFIT.
</FONT></I>
<I><FONT COLOR="#B22222">//This is an internal function and should only be used if you know what you're doing (and how it will affect the reported
</FONT></I><I><FONT COLOR="#B22222">// stats and convergence).
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::tuple&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;
<B><FONT COLOR="#0000FF">Ygor_Fit_Driver</FONT></B>(bool *wasOK,
    <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
    <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,   <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars,   uint32_t fitflags,
    bool Verbose, <B><FONT COLOR="#228B22">double</FONT></B> char_len,  <B><FONT COLOR="#228B22">int</FONT></B> max_iters,  <B><FONT COLOR="#228B22">double</FONT></B> ftol);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::tuple&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;
<B><FONT COLOR="#0000FF">Ygor_Fit_LSS</FONT></B>(bool *wasOK,
         <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
         <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,  <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars,     <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim,
         bool Verbose = false,
         <B><FONT COLOR="#228B22">double</FONT></B> char_len = 0.6,
         <B><FONT COLOR="#228B22">int</FONT></B> max_iters = 1500,
         <B><FONT COLOR="#228B22">double</FONT></B> ftol = 1E-6);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::tuple&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;
<B><FONT COLOR="#0000FF">Ygor_Fit_LMS</FONT></B>(bool *wasOK,
         <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
         <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,  <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars,     <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim,
         bool Verbose = false,
         <B><FONT COLOR="#228B22">double</FONT></B> char_len = 0.6,
         <B><FONT COLOR="#228B22">int</FONT></B> max_iters = 2500,
         <B><FONT COLOR="#228B22">double</FONT></B> ftol = 1E-6);

<I><FONT COLOR="#B22222">//Performs bootstrap analysis and provides N estimates of the fit parameters. Use this to construct a 
</FONT></I><I><FONT COLOR="#B22222">// mean/median/uncertainty estimate/whatever. See nice writeup in A.J. Blanco's 2005 paper 'Dose-Volume
</FONT></I><I><FONT COLOR="#B22222">// modeling of parotid salivary function'
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; Ygor_Fit_Bootstrap_Driver(bool *wasOK,
         <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
         <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,  <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars,  uint32_t fitflags,
         <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N,  <B><FONT COLOR="#228B22">double</FONT></B> char_len,  <B><FONT COLOR="#228B22">int</FONT></B> max_iters,  <B><FONT COLOR="#228B22">double</FONT></B> ftol);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; Ygor_Fit_Bootstrap_LSS(bool *wasOK,
         <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
         <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,  <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars,  <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim,
         <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N = 5000,
         <B><FONT COLOR="#228B22">double</FONT></B> char_len = 0.6,
         <B><FONT COLOR="#228B22">int</FONT></B> max_iters = 1500,
         <B><FONT COLOR="#228B22">double</FONT></B> ftol = 1E-6);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; Ygor_Fit_Bootstrap_LMS(bool *wasOK,
         <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
         <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,  <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars,  <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim,
         <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N = 5000,
         <B><FONT COLOR="#228B22">double</FONT></B> char_len = 0.6,
         <B><FONT COLOR="#228B22">int</FONT></B> max_iters = 2500,
         <B><FONT COLOR="#228B22">double</FONT></B> ftol = 1E-6);


#<B><FONT COLOR="#5F9EA0">endif</FONT></B> 
</PRE>
<HR>
<A NAME="file2">
<H1>YgorArguments.h 2/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file1">prev</A>][<A HREF="#file3">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorArguments.h - A wrapper around getopts (or similar) which uses a more-DRY-like method of handling main's arguments.
</FONT></I><I><FONT COLOR="#B22222">//                Common arguments, like '--help' are provided automatically.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_ARGUMENTS_PROJECT_UTILITIES_HC_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_ARGUMENTS_PROJECT_UTILITIES_HC_</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iomanip&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;tuple&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;utility&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;functional&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;set&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;getopt.h&gt;</FONT></B>            //Needed for 'getopts' argument parsing.

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>            //Needed for function macros FUNCINFO, FUNCWARN, FUNCERR.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorEnvironment.h&quot;</FONT></B>     //Needed for Get_Terminal_Char_Dimensions();


<I><FONT COLOR="#B22222">// #########################################################################
</FONT></I><I><FONT COLOR="#B22222">// ##### NOTE:                                                       #######
</FONT></I><I><FONT COLOR="#B22222">// #####  This typedef has been made so that some compiler errors    #######
</FONT></I><I><FONT COLOR="#B22222">// #####  can be mitigated in gcc 4.8.1. If one uses std::make_tuple #######
</FONT></I><I><FONT COLOR="#B22222">// #####  with a 'bare' closure, then a long, nasty error is given   #######
</FONT></I><I><FONT COLOR="#B22222">// #####  about: &quot;/usr/include/c++/4.8.1/functional: In substitution #######
</FONT></I><I><FONT COLOR="#B22222">// #####  of template&lt;class _Res, class ... _ArgType  ........&quot;     #######
</FONT></I><I><FONT COLOR="#B22222">// #####  Using this typedef solves the problem. I'm not sure if it  #######
</FONT></I><I><FONT COLOR="#B22222">// #####  should stay or not, though. It sort of hides the fact that #######
</FONT></I><I><FONT COLOR="#B22222">// #####  it is a simple tuple.                                      #######
</FONT></I><I><FONT COLOR="#B22222">// #####                                                             #######
</FONT></I><I><FONT COLOR="#B22222">// #####  Remove this note and the typedef if it is desired, or      #######
</FONT></I><I><FONT COLOR="#B22222">// #####  just this note otherwise.                                  #######
</FONT></I><I><FONT COLOR="#B22222">// #########################################################################
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> std::tuple&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">char</FONT></B>,std::string,bool,std::string,std::string,std::function&lt;<B><FONT COLOR="#228B22">void</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;optarg)&gt;&gt; ygor_arg_handlr_t;

class ArgumentHandler {
    <B><FONT COLOR="#5F9EA0">private</FONT></B>:
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string theprogsname; <I><FONT COLOR="#B22222">//Set when we launch the processing command.
</FONT></I>
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <I><FONT COLOR="#B22222">//This list holds all the directives or arguments (with their actions, description, etc..) we want to handle.
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">// NOTE: The 'family' number determines where to print the description when calling the --help argument. Families
</FONT></I>        <I><FONT COLOR="#B22222">// which share an indentifier will be printed in the same section. The '--help' description itself is in the 0 family.
</FONT></I>        <I><FONT COLOR="#B22222">// Families can be larger or smaller than 0, and will be printed in ascending order.
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">// NOTE: The 'sample argument' is used in the help menu, and should be a (string) of a sample argument (like a filename
</FONT></I>        <I><FONT COLOR="#B22222">// or something similar.)
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">// Key:  family, short form, long form, takes argument?, sample argument, description, callback function.
</FONT></I>        <I><FONT COLOR="#B22222">//         0         1           2             3               4               5               6
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt; std::tuple&lt; <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B>, std::string, bool, std::string, std::string, std::function&lt; <B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;optarg) &gt; &gt; &gt; directives;

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt; <B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;optarg) &gt; default_callback; <I><FONT COLOR="#B22222">//Gets called by default, when no others matches are found. 
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt; <B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;optarg) &gt; optionless_callback;   <I><FONT COLOR="#B22222">//Gets called for each optionless argument passed into main.
</FONT></I>
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string description;                                                 <I><FONT COLOR="#B22222">//A description of the program itself (for the help menu.)
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt; &gt; examples;                <I><FONT COLOR="#B22222">//Example invocations and a description (for the help menu.)
</FONT></I>
        <I><FONT COLOR="#B22222">//Constructor/Destructor.
</FONT></I>        ArgumentHandler() {  
            <I><FONT COLOR="#B22222">//Register the default callbacks.
</FONT></I>            this-&gt;default_callback = [](<B><FONT COLOR="#228B22">int</FONT></B> opt, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;optarg) -&gt; <B><FONT COLOR="#228B22">void</FONT></B> { 
                FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Received unrecognized option '&quot;</FONT></B> &lt;&lt; opt &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;' with argument '&quot;</FONT></B> &lt;&lt; optarg &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;'. Register callback to handle it if desired. Ignoring&quot;</FONT></B>); 
                <B><FONT COLOR="#A020F0">return</FONT></B>; 
            };

            this-&gt;optionless_callback = [](<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;optarg) -&gt; <B><FONT COLOR="#228B22">void</FONT></B> { 
                FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Received an optionless argument '&quot;</FONT></B> &lt;&lt; optarg &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;'. Register callback to handle it if desired. Ignoring&quot;</FONT></B>);
                <B><FONT COLOR="#A020F0">return</FONT></B>; 
            };
 
            <I><FONT COLOR="#B22222">//Register the special --help directive.
</FONT></I>            <B><FONT COLOR="#228B22">auto</FONT></B> help_callback = [&amp;](<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;optarg) -&gt; <B><FONT COLOR="#228B22">void</FONT></B> {
                <I><FONT COLOR="#B22222">//------------------------------------------------------ help output ---------------------------------------------------
</FONT></I>                <I><FONT COLOR="#B22222">//Environmental information and common things.
</FONT></I>                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> terminal_dims = Get_Terminal_Char_Dimensions();
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> termW = (terminal_dims.first  == -1) ? 80 : terminal_dims.first;
                <I><FONT COLOR="#B22222">//const long int termH = (terminal_dims.second == -1) ? 50 : terminal_dims.second;
</FONT></I>                <B><FONT COLOR="#5F9EA0">std</FONT></B>::string DoubleLine, SingleLine(<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>);
                <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;termW; ++i) DoubleLine += <B><FONT COLOR="#BC8F8F">'='</FONT></B>;
                <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=2; i&lt;termW; ++i) SingleLine += <B><FONT COLOR="#BC8F8F">'-'</FONT></B>;
                SingleLine += <B><FONT COLOR="#BC8F8F">' '</FONT></B>;

                <I><FONT COLOR="#B22222">//Program's name.
</FONT></I>                <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; DoubleLine &lt;&lt; std::endl &lt;&lt; Reflow_Line_Align_Center(this-&gt;theprogsname, termW) &lt;&lt; std::endl;

                <I><FONT COLOR="#B22222">//We first output the program's description.
</FONT></I>                <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; DoubleLine &lt;&lt; std::endl &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; Description.&quot;</FONT></B> &lt;&lt; std::endl &lt;&lt; SingleLine &lt;&lt; std::endl;
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> rf_des = Reflow_Text_to_Fit_Width_Left_Just(description, termW, 4);
                <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> itt = rf_des.begin(); itt != rf_des.end(); ++itt) std::cout &lt;&lt; *itt &lt;&lt; std::endl;
                <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; std::endl;

                <I><FONT COLOR="#B22222">//Determine which families are out there, the maximum arg length, etc.. so we can group them together in the help usage.
</FONT></I>                <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; uniq_families;
                size_t max_shrt(0), max_long(0), max_desc(0);
                <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> d_it = directives.begin(); d_it != directives.end(); ++d_it){
                    uniq_families.insert( std::get&lt;0&gt;(*d_it) );

                    <B><FONT COLOR="#228B22">const</FONT></B> size_t len_shrt = 1 + (std::get&lt;4&gt;(*d_it)).size() + 1;
                    <B><FONT COLOR="#228B22">const</FONT></B> size_t len_long = (std::get&lt;2&gt;(*d_it)).size() + (<B><FONT COLOR="#BC8F8F">&quot;...&quot;</FONT></B>_s).size() + 1; <I><FONT COLOR="#B22222">// &quot;...&quot; instead of std::get&lt;4&gt;(*d_it).
</FONT></I>                    <B><FONT COLOR="#228B22">const</FONT></B> size_t len_desc = (std::get&lt;5&gt;(*d_it)).size();

                    <B><FONT COLOR="#A020F0">if</FONT></B>(max_shrt &lt; len_shrt) max_shrt = len_shrt;
                    <B><FONT COLOR="#A020F0">if</FONT></B>(max_long &lt; len_long) max_long = len_long;
                    <B><FONT COLOR="#A020F0">if</FONT></B>(max_desc &lt; len_desc) max_desc = len_desc;
                }

                <I><FONT COLOR="#B22222">//The width of the text blocks for short options, long options, and descriptions. We will attempt to word-wrap the descriptions.
</FONT></I>                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> shrtW  = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(max_shrt + 2); <I><FONT COLOR="#B22222">//And an extra space after.
</FONT></I>                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> longW  = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(max_long + 2); <I><FONT COLOR="#B22222">//And an extra space after.
</FONT></I>                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> remain = termW - (longW + shrtW + 1);
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> descW  = (remain &gt; 20) ? remain : 20; 

                <I><FONT COLOR="#B22222">//Now we cycle over the arguments, displaying them in a tabular fashion on the screen.
</FONT></I>                <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; DoubleLine &lt;&lt; std::endl &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; Usage.&quot;</FONT></B> &lt;&lt; std::endl &lt;&lt; SingleLine &lt;&lt; std::endl;
                <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; std::setiosflags(std::ios_base::left) &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">' '</FONT></B>) &lt;&lt; std::setw( shrtW + longW + 2) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Option (short/long)&quot;</FONT></B>;
                <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; std::setiosflags(std::ios_base::left) &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">' '</FONT></B>) &lt;&lt; std::setw( descW - 3) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Description&quot;</FONT></B>;
                <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; std::endl;

                <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> f_it = uniq_families.begin(); f_it != uniq_families.end(); ++f_it){
                    <B><FONT COLOR="#A020F0">if</FONT></B>(f_it != uniq_families.begin()) std::cout &lt;&lt; std::endl;
                    <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; SingleLine &lt;&lt; std::endl;

                    <I><FONT COLOR="#B22222">//bool firstnewlineskipped = false;
</FONT></I>                    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> d_it = directives.begin(); d_it != directives.end(); ++d_it){
                        <B><FONT COLOR="#A020F0">if</FONT></B>( (*f_it) == std::get&lt;0&gt;(*d_it) ){
                           <I><FONT COLOR="#B22222">//if(!firstnewlineskipped){
</FONT></I>                           <I><FONT COLOR="#B22222">//    firstnewlineskipped = true;
</FONT></I>                           <I><FONT COLOR="#B22222">//}else{
</FONT></I>                           <I><FONT COLOR="#B22222">//      std::cout &lt;&lt; &quot; &quot; &lt;&lt; std::endl;  //Put a space between descriptions. I prefer not to...
</FONT></I>                           <I><FONT COLOR="#B22222">//}
</FONT></I>
                           <I><FONT COLOR="#B22222">//Short options.
</FONT></I>                           <B><FONT COLOR="#5F9EA0">std</FONT></B>::string shrtandsmpl = std::get&lt;1&gt;(*d_it) + <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>_s + std::get&lt;4&gt;(*d_it);
                           <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; -&quot;</FONT></B> &lt;&lt; std::setiosflags(std::ios_base::left) &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">' '</FONT></B>) &lt;&lt; std::setw( shrtW ) &lt;&lt; shrtandsmpl;

                           <I><FONT COLOR="#B22222">//Long options.
</FONT></I>                           <B><FONT COLOR="#5F9EA0">std</FONT></B>::string longandsmpl = std::get&lt;2&gt;(*d_it) + <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>_s + (std::get&lt;3&gt;(*d_it) ? <B><FONT COLOR="#BC8F8F">&quot;...&quot;</FONT></B>_s : <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>_s);
                           <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;--&quot;</FONT></B> &lt;&lt; std::setiosflags(std::ios_base::left) &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">' '</FONT></B>) &lt;&lt; std::setw( longW ) &lt;&lt; longandsmpl;

                           <I><FONT COLOR="#B22222">//Descriptions.
</FONT></I>                           <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> rf_des = Reflow_Text_to_Fit_Width_Left_Just(std::get&lt;5&gt;(*d_it), descW-4, -2);
                           <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> dl_it = rf_des.begin(); dl_it != rf_des.end(); ++dl_it){
                               <B><FONT COLOR="#A020F0">if</FONT></B>(dl_it != rf_des.begin()) <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;(shrtW + longW + 2 + 1 + 1); ++i) std::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
                               <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; *dl_it &lt;&lt; std::endl;
                           }
                        }
                    }
                }

                <I><FONT COLOR="#B22222">//Now we check if any examples have been registered.
</FONT></I>                <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; std::endl &lt;&lt; DoubleLine &lt;&lt; std::endl &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; Examples.&quot;</FONT></B> &lt;&lt; std::endl;
                <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> e_it = examples.begin(); e_it != examples.end(); ++e_it){
                    <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; SingleLine &lt;&lt; std::endl;
                    <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; this-&gt;theprogsname &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e_it-&gt;first &lt;&lt; std::endl;

                    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> rf_des = Reflow_Text_to_Fit_Width_Left_Just(e_it-&gt;second , termW-4, 2);
                    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> itt = rf_des.begin(); itt != rf_des.end(); ++itt) std::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;    &quot;</FONT></B>_s &lt;&lt; *itt &lt;&lt; std::endl;
                }
                <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; DoubleLine &lt;&lt; std::endl;
                exit(0);
                <I><FONT COLOR="#B22222">//------------------------------------------------------ /help output ---------------------------------------------------
</FONT></I>            };
            this-&gt;push_back( std::make_tuple( 0, <B><FONT COLOR="#BC8F8F">'h'</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;help&quot;</FONT></B>, false, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Show (this) help information.&quot;</FONT></B>, help_callback) );
        };


        <I><FONT COLOR="#B22222">//Member functions.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> push_back( <B><FONT COLOR="#228B22">const</FONT></B> std::tuple&lt; <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B>, std::string, bool, std::string, std::string, std::function&lt; <B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;optarg) &gt; &gt; &amp;directive){
            <I><FONT COLOR="#B22222">//Check for conflicting options??
</FONT></I>
            <I><FONT COLOR="#B22222">// ...
</FONT></I> 
            directives.push_back( directive );


            <B><FONT COLOR="#A020F0">return</FONT></B>;
        };

        bool Launch(<B><FONT COLOR="#228B22">int</FONT></B> local_argc, <B><FONT COLOR="#228B22">char</FONT></B> **local_argv){  <I><FONT COLOR="#B22222">//This function performs the actual argument handling.
</FONT></I>            this-&gt;theprogsname = ((local_argv != nullptr) &amp;&amp; (local_argv[0] != nullptr)) ? local_argv[0] : <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>;

            <I><FONT COLOR="#B22222">//Check if there is anything to do.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(local_argc &lt;= 1) <B><FONT COLOR="#A020F0">return</FONT></B> true;

            <I><FONT COLOR="#B22222">//First, we set up the getopt stuff.
</FONT></I>            <B><FONT COLOR="#5F9EA0">std</FONT></B>::string short_opts;
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> d_it = directives.begin(); d_it != directives.end(); ++d_it){
                short_opts += std::get&lt;1&gt;(*d_it);
                <B><FONT COLOR="#A020F0">if</FONT></B>( std::get&lt;3&gt;(*d_it) == true ) short_opts += <B><FONT COLOR="#BC8F8F">&quot;:&quot;</FONT></B>;
            }

            <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">struct</FONT></B> option&gt; long_opts;
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> d_it = directives.begin(); d_it != directives.end(); ++d_it){
                <I><FONT COLOR="#B22222">//long_opts.push_back( { description, (int)(takes arg?), nullptr, (char)(short form) } );
</FONT></I>                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> takesarg = (std::get&lt;3&gt;(*d_it) == true) ? 1 : 0;
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> option shuttle = { (std::get&lt;2&gt;(*d_it)).c_str(), takesarg, nullptr, std::get&lt;1&gt;(*d_it) };
                long_opts.push_back( shuttle );
            }
            {
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> option shuttle = { NULL, 0, NULL, 0 };
                long_opts.push_back( shuttle ); <I><FONT COLOR="#B22222">//The manual says to terminate with all-zeros.
</FONT></I>            }
            <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">struct</FONT></B> option&gt; long_const_opts( long_opts );
            long_opts.clear(); <I><FONT COLOR="#B22222">//So we do not accidentally invalidate the pointer to the vector's data.
</FONT></I>
            <I><FONT COLOR="#B22222">//Now we loop over the arguments, calling the callbacks if necessary. We cycle through the directives 
</FONT></I>            <I><FONT COLOR="#B22222">// backward so that more recently-pushed directives get priority over others.
</FONT></I>            <B><FONT COLOR="#228B22">int</FONT></B> next_options;
            <B><FONT COLOR="#A020F0">do</FONT></B>{
                next_options = getopt_long(local_argc, local_argv, short_opts.c_str(), &amp;long_const_opts[0], nullptr);
                bool matched = false;
                <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> d_it = directives.rbegin(); d_it != directives.rend(); ++d_it){
                    <B><FONT COLOR="#A020F0">if</FONT></B>( next_options == std::get&lt;1&gt;(*d_it) ){
                        matched = true;
                        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string theoptarg;
                        <B><FONT COLOR="#A020F0">if</FONT></B>(optarg != nullptr) theoptarg = optarg;
                        <B><FONT COLOR="#A020F0">if</FONT></B>( std::get&lt;6&gt;(*d_it) ){
                            (std::get&lt;6&gt;(*d_it))( theoptarg );
                        }<B><FONT COLOR="#A020F0">else</FONT></B>{
                            FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Encountered argument '&quot;</FONT></B> &lt;&lt; next_options &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;', but there is not a valid callback function to perform. Continuing&quot;</FONT></B>);
                        }
                        <B><FONT COLOR="#A020F0">break</FONT></B>;
                    }
                }

                <B><FONT COLOR="#A020F0">if</FONT></B>((matched == false) &amp;&amp; (next_options != -1)){
                    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string theoptarg;
                    <B><FONT COLOR="#A020F0">if</FONT></B>(optarg != nullptr) theoptarg = optarg;
                    <B><FONT COLOR="#A020F0">if</FONT></B>(default_callback){
                        default_callback( next_options, theoptarg );
                    }<B><FONT COLOR="#A020F0">else</FONT></B>{
                        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to match argument '&quot;</FONT></B> &lt;&lt; next_options &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;', and unable to execute default callback. Continuing&quot;</FONT></B>);
                    } 
                }

            }<B><FONT COLOR="#A020F0">while</FONT></B>(next_options != -1);
            <I><FONT COLOR="#B22222">//From the optind man page:
</FONT></I>            <I><FONT COLOR="#B22222">//  &quot;If the resulting value of optind is greater than argc, this indicates a missing option-argument,
</FONT></I>            <I><FONT COLOR="#B22222">//         and getopt() shall return an error indication.&quot;
</FONT></I>            <B><FONT COLOR="#A020F0">for</FONT></B>( ; optind &lt; local_argc; ++optind){
                <B><FONT COLOR="#5F9EA0">std</FONT></B>::string theoptarg;
                <B><FONT COLOR="#A020F0">if</FONT></B>(local_argv[optind] != nullptr) theoptarg = local_argv[optind];
                <B><FONT COLOR="#A020F0">if</FONT></B>(optionless_callback){
                    optionless_callback( theoptarg );
                }<B><FONT COLOR="#A020F0">else</FONT></B>{
                    FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to perform optionless argument processing because callback is not valid. Continuing&quot;</FONT></B>);
                }
            }
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
        };

};
#<B><FONT COLOR="#5F9EA0">endif</FONT></B> 
</PRE>
<HR>
<A NAME="file3">
<H1>YgorCONFIGTools.h 3/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file2">prev</A>][<A HREF="#file4">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorCONFIGTools.h - A collection of routines for parsing/reading configuration files.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">CONFIGTOOLS_HDR_GRD_H_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">CONFIGTOOLS_HDR_GRD_H_</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

<I><FONT COLOR="#B22222">//A simple config file is one where:
</FONT></I><I><FONT COLOR="#B22222">//  1) Each line is self-contained. There is no positional awareness (at least, no structural awareness.)
</FONT></I><I><FONT COLOR="#B22222">//  2) Each comment line begins with optional whitespace and non-optional '#'. Non-comment lines with a '#' is OK.
</FONT></I><I><FONT COLOR="#B22222">//  3) Each line is separated with some character (typically ':'.) Lines which omit this delimiter are comments.
</FONT></I><I><FONT COLOR="#B22222">//       (NOTE: If a structure like 'a = b' is required, simply filter out the lines with one element!)
</FONT></I><I><FONT COLOR="#B22222">//  4) Each line logically ends with a line-ending token. This is not changeable, and is always a newline '\n'.
</FONT></I><I><FONT COLOR="#B22222">//       (NOTE: This can be overcome be repeated serialization, until a single newline remains!)
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;std::string&gt;&gt; Tokenize_Simple_Config_File(std::string filename, std::string separator);
bool <B><FONT COLOR="#0000FF">Write_Config_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;inmem, std::string filename, std::string separator);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;std::string&gt;&gt; Deserialize_Simple_Config_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;serialized, std::string separator);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Serialize_Simple_Config_File(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;deserialized, std::string separator);


<I><FONT COLOR="#B22222">//This function will take an in-memory config file and will serialize it twice, producing a truly-serial output (no newlines.)
</FONT></I><I><FONT COLOR="#B22222">// It is useful for dumping from one program to another (i.e. using std::cin to collect a serialized config file as a single input.)
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine cannot handle content which contains newlines!
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;std::string&gt;&gt; Double_Deserialize_Simple_Config_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;serialized, std::string separator, std::string linetoken);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Double_Serialize_Simple_Config_File(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;deserialized, std::string separator, std::string linetoken);



<I><FONT COLOR="#B22222">//Operations on in-memory configs. The burden is on the user to ensure the proper method is used for the config.
</FONT></I><I><FONT COLOR="#B22222">// For instance, some routines assume a simple 'a = b' format. Using these on a 'a = b = c' format, for instance,
</FONT></I><I><FONT COLOR="#B22222">// may produce unreliable output.
</FONT></I>bool        <B><FONT COLOR="#0000FF">YgorCONFIGTools_Is_X_Present_on_Leftmost</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;conf, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;X);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string YgorCONFIGTools_Given_X_Get_First_B_When_XB(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;conf, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;X);



<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;std::string&gt;&gt; YgorCONFIGTools_Get_All_Lines_With_X_Present_on_Leftmost(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;conf, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;X);

#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file4">
<H1>YgorContainers.h 4/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file3">prev</A>][<A HREF="#file5">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorContainers.h - A collection of some custom (niche?) containers. Most likely the contents of this file exist somewhere as more
</FONT></I><I><FONT COLOR="#B22222">//  mature implementations with well thought-out uses. These are handy because they do not do anything 'sneaky' behind my back
</FONT></I><I><FONT COLOR="#B22222">//  and are all a simple header-only implementation (usually relying on the STL, though.)
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_CUSTOM_CONTAINERS_HC_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_CUSTOM_CONTAINERS_HC_</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;map&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;utility&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;thread&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iterator&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;functional&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;mutex&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;atomic&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>            //Needed for function macros FUNCINFO, FUNCWARN, FUNCERR.

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------- bimap -------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">// Bimap - A bi-directional map. Useful for describing a set of items which relate to one another with one-to-one correspondance.
</FONT></I><I><FONT COLOR="#B22222">// This implementation 'piggybacks' on some simple STL containers to give a very crippled (but useable) container.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// This container is a poor-man's version of the Boost::Bimap library. Q: Why not just use Boost? A: To increase portability, this 
</FONT></I><I><FONT COLOR="#B22222">// will only depend on the C++ compiler's support of the STL. If performance or flexibility are desired, simply switch to Boost.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Notes:
</FONT></I><I><FONT COLOR="#B22222">//   1) For simplicity in this implementation, please do NOT use this container with TA == TB.
</FONT></I>
template &lt;class TA, class TB&gt;   class bimap { 
    <B><FONT COLOR="#5F9EA0">private</FONT></B>:
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt; std::pair&lt;TA,TB&gt; &gt;  the_pairs;

    <B><FONT COLOR="#5F9EA0">public</FONT></B>:

        <I><FONT COLOR="#B22222">//Constructors.
</FONT></I>        bimap();

        <I><FONT COLOR="#B22222">//Member functions.
</FONT></I>        TA &amp; operator[]( <B><FONT COLOR="#228B22">const</FONT></B> TB &amp;in );
        TB &amp; operator[]( <B><FONT COLOR="#228B22">const</FONT></B> TA &amp;in );

        bimap &amp; operator=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;TA,TB&gt; &amp;);
        bimap &amp; operator=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;TB,TA&gt; &amp;);

        typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_iterator  begin( <B><FONT COLOR="#228B22">void</FONT></B> ) <B><FONT COLOR="#228B22">const</FONT></B>;
        typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_reverse_iterator  rbegin( <B><FONT COLOR="#228B22">void</FONT></B> ) <B><FONT COLOR="#228B22">const</FONT></B>;
        typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_iterator  end( <B><FONT COLOR="#228B22">void</FONT></B> ) <B><FONT COLOR="#228B22">const</FONT></B>;
        typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_reverse_iterator  rend( <B><FONT COLOR="#228B22">void</FONT></B> ) <B><FONT COLOR="#228B22">const</FONT></B>;
        
        typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_iterator  find( <B><FONT COLOR="#228B22">const</FONT></B> TA &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B>;
        typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_iterator  find( <B><FONT COLOR="#228B22">const</FONT></B> TB &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B>;

        <I><FONT COLOR="#B22222">//Given an element, these functions return a pointer to the next (cyclically.) Helps avoid a find/iterate/check procedure.
</FONT></I>        template &lt;class T&gt; typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_iterator  after( <B><FONT COLOR="#228B22">const</FONT></B> T &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B>;
        template &lt;class T&gt; typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_iterator  before( <B><FONT COLOR="#228B22">const</FONT></B> T &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B>;

        <I><FONT COLOR="#B22222">//Given an element, these functions return the desired element (or the given element, if something fails.)
</FONT></I>        template &lt;class T&gt; T get_next( <B><FONT COLOR="#228B22">const</FONT></B> T &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B>;
        template &lt;class T&gt; T get_previous( <B><FONT COLOR="#228B22">const</FONT></B> T &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B>;
   
        <B><FONT COLOR="#228B22">void</FONT></B> order_on_first(<B><FONT COLOR="#228B22">void</FONT></B>);
        <B><FONT COLOR="#228B22">void</FONT></B> order_on_second(<B><FONT COLOR="#228B22">void</FONT></B>);


        <I><FONT COLOR="#B22222">//  erase? 
</FONT></I>        <I><FONT COLOR="#B22222">//  non-const iterators? (&lt;-- Do I just need to remove the trailing const in the function def?)
</FONT></I>        <I><FONT COLOR="#B22222">//  size() ?  ((needed?))
</FONT></I>        <I><FONT COLOR="#B22222">//  empty() ?
</FONT></I>};



<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------- taskqueue ------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">// Task Queue - A single-(additional)-threaded function evaluator. All tasks are performed in a std::thread, but are 
</FONT></I><I><FONT COLOR="#B22222">// performed sequentially. The utility of this container is that the queue is consumed by the thread asynchronously. The
</FONT></I><I><FONT COLOR="#B22222">// only interaction with the consuming thread is to push tasks into the queue (may block for small time) and intentionally
</FONT></I><I><FONT COLOR="#B22222">// blocking on events (such as queue being empty, completing current task, etc.).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Each task is pushed onto the queue with an identical method: this-&gt;Queue(...). If a task is currently being performed, 
</FONT></I><I><FONT COLOR="#B22222">// then the task is queued until the previous task is complete. If no current task is being performed, execution happens 
</FONT></I><I><FONT COLOR="#B22222">// (nearly) immediately.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// This container is essentially a thread pool with a single thread consumer.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>class taskqueue {
    <B><FONT COLOR="#5F9EA0">private</FONT></B>:
        <I><FONT COLOR="#B22222">//This is the basic queue, where tasks are pushed. There is probably no reason why it could not be templated.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::function&lt;<B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">void</FONT></B>)&gt;&gt; queue;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::thread queue_thread;

        <I><FONT COLOR="#B22222">//Long-blocking mutexes - these block while doing arbitrary computation and thus may block indefinately.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::mutex entire_queue_mutex;   <I><FONT COLOR="#B22222">//Gets flipped on when the first task is launched, off when the last is completed.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::mutex single_task_mutex;    <I><FONT COLOR="#B22222">//Gets flipped on when a single task is launched, off when it returns.
</FONT></I>
        <I><FONT COLOR="#B22222">//Short-blocking mutexes - these block during simple tasks like queue alterations and task (lambda) pushing.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::mutex queue_access_mutex;        <I><FONT COLOR="#B22222">//Gets flipped on when queue_thread is being used.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::mutex launching_mutex;           <I><FONT COLOR="#B22222">//Gets flipped on when launching the task thread initially, off after launch.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::mutex thread_has_launched_mutex; <I><FONT COLOR="#B22222">//Used to block the main thread until first item launches. Used to prevent 
</FONT></I>                                              <I><FONT COLOR="#B22222">// 'sneaky' priority tasks prior to first task..
</FONT></I>
        <I><FONT COLOR="#B22222">//Callbacks which are checked/performed upon specific actions. Each comes with a mutex which locks access.
</FONT></I>        <I><FONT COLOR="#B22222">// Note: these mutexs are simple locks which lock for access AND during execution, so they *may* lock forever.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;<B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">void</FONT></B>)&gt; Callback_Queue_Emptied;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::mutex callback_queue_emptied_mutex;

        <I><FONT COLOR="#B22222">//This will launch tasks. It is robust enough to handle being called when there is currently a task. It should not
</FONT></I>        <I><FONT COLOR="#B22222">// be directly called without going through some wrapper functions. 
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">//Returns 'true' if there were no errors encountered. 
</FONT></I>        bool Launch(<B><FONT COLOR="#228B22">void</FONT></B>){
            this-&gt;launching_mutex.lock(); 

            <I><FONT COLOR="#B22222">//Check if the queue thread is currently doing something. If it is, we do not have to do anything.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(this-&gt;queue_thread.joinable() == 1){
                this-&gt;launching_mutex.unlock();
                <B><FONT COLOR="#A020F0">return</FONT></B> true; <I><FONT COLOR="#B22222">//Everything A-O-K.
</FONT></I>            }
            <B><FONT COLOR="#A020F0">if</FONT></B>(!this-&gt;thread_has_launched_mutex.try_lock()){
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;The 'thread has launched' mutex is locked. It is used to block on thread creation and should not remain locked. Bailing&quot;</FONT></B>);
                this-&gt;launching_mutex.unlock();
                <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//Something went wrong.
</FONT></I>            }

            <I><FONT COLOR="#B22222">//This is the lambda function we will launch in another thread. It will iterate over the tasks (which can be popped
</FONT></I>            <I><FONT COLOR="#B22222">// on in realtime) until they are all complete. It erases tasks which have been completed.
</FONT></I>            <I><FONT COLOR="#B22222">//
</FONT></I>            <I><FONT COLOR="#B22222">//NOTE: It is more convenient to lock the entire_queue_mutex just prior to calling this lambda. See below.
</FONT></I>            <B><FONT COLOR="#228B22">auto</FONT></B> lambda = [&amp;](<B><FONT COLOR="#228B22">void</FONT></B>) -&gt; <B><FONT COLOR="#228B22">void</FONT></B> {
                <I><FONT COLOR="#B22222">//Iterate over the queue. Note that we do not explicitly need to iterate because we 'gobble up' the list 
</FONT></I>                <I><FONT COLOR="#B22222">// from the front by erasing tasks which we complete.
</FONT></I>                this-&gt;queue_access_mutex.lock();    <I><FONT COLOR="#B22222">//Lock the queue PRIOR to allowing threads access by unblocking the launching thread.
</FONT></I>                                                    <I><FONT COLOR="#B22222">//  This is desired so that we cannot have a 'fast' thread Queue() a priority task very quickly,
</FONT></I>                                                    <I><FONT COLOR="#B22222">//  which will NOT be the same behaviour for other systems: uniformity is better to have!
</FONT></I>                thread_has_launched_mutex.unlock(); <I><FONT COLOR="#B22222">//Unlock the 'thread has launched' mutexbecause we are now 'running free' in a thread.
</FONT></I>
                <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = this-&gt;queue.begin(); it != this-&gt;queue.end();     ){  <I><FONT COLOR="#B22222">// ..and NOT: ++it){
</FONT></I>                    <I><FONT COLOR="#B22222">//Check if the element queued still exists. If it does not, we remove it and continue on.
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B>(!(*it)){
                        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to perform task - the reference appears to be invalid. Removing it and continuing&quot;</FONT></B>);
                        it = this-&gt;queue.erase(it);
                        <B><FONT COLOR="#A020F0">continue</FONT></B>;
                    }

                    <I><FONT COLOR="#B22222">//We copy, test for a lock, and remove this task from the queue. Then we relinquish queue control to the masses. 
</FONT></I>                    <B><FONT COLOR="#228B22">auto</FONT></B> f = std::move(*it);
                    <B><FONT COLOR="#A020F0">if</FONT></B>( !this-&gt;single_task_mutex.try_lock() ){
                        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;The single task mutex is currently locked. Is there already a thread performing these tasks? Bailing&quot;</FONT></B>);
                        this-&gt;queue_access_mutex.unlock();
                        <B><FONT COLOR="#A020F0">return</FONT></B>;
                    }
                    this-&gt;queue.erase(it);
                    this-&gt;queue_access_mutex.unlock();

                    <I><FONT COLOR="#B22222">//Perform the task. We have a local copy, so the queue remains available to the masses.
</FONT></I>                    f();
                    this-&gt;single_task_mutex.unlock();
    
                    <I><FONT COLOR="#B22222">//Get back control of the queue. Determine whether or not we can should continue. We do not
</FONT></I>                    <I><FONT COLOR="#B22222">// assume any of our iterators are still valid.
</FONT></I>                    this-&gt;queue_access_mutex.lock();
                    <B><FONT COLOR="#A020F0">if</FONT></B>(this-&gt;queue.empty()){
                        <B><FONT COLOR="#A020F0">break</FONT></B>;
                    }<B><FONT COLOR="#A020F0">else</FONT></B>{
                        it = this-&gt;queue.begin();
                    }
                }
                this-&gt;queue_access_mutex.unlock();

                <I><FONT COLOR="#B22222">//Perform the queue-end callback, if one exists.
</FONT></I>                this-&gt;callback_queue_emptied_mutex.lock();
                <B><FONT COLOR="#A020F0">if</FONT></B>(this-&gt;Callback_Queue_Emptied){
                    this-&gt;Callback_Queue_Emptied();
                }
                this-&gt;callback_queue_emptied_mutex.unlock();
 
                <I><FONT COLOR="#B22222">//Detach this thread. Unlock the entire_queue_mutex, signifying we have consumed all tasks in the queue.
</FONT></I>                this-&gt;queue_thread.detach();
                this-&gt;entire_queue_mutex.unlock();
                <B><FONT COLOR="#A020F0">return</FONT></B>;
            };
    
            <I><FONT COLOR="#B22222">//Lock the entire queue mutex. Launch the thread.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>( !this-&gt;entire_queue_mutex.try_lock() ){
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to initiate tasks - entire_queue_mutex is locked. Is another thread already running?&quot;</FONT></B>);
                this-&gt;launching_mutex.unlock();
                this-&gt;thread_has_launched_mutex.unlock();
                <B><FONT COLOR="#A020F0">return</FONT></B> false;
            }
            this-&gt;queue_thread = std::thread( lambda );

            <I><FONT COLOR="#B22222">//Wait on the queue lock for the thread to begin. This guarantees us sequential operations upon Queue()'ing.
</FONT></I>            this-&gt;thread_has_launched_mutex.lock(); <I><FONT COLOR="#B22222">//If the thread did not unlock, we would wait here forever!
</FONT></I>            this-&gt;thread_has_launched_mutex.unlock();

            <I><FONT COLOR="#B22222">//Release the Launch() mutex so that waiting Launch()'ers can Launch().
</FONT></I>            launching_mutex.unlock();
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
        }

    <B><FONT COLOR="#5F9EA0">public</FONT></B>:

        <I><FONT COLOR="#B22222">//----- Constructors/Destructor.
</FONT></I>        taskqueue(<B><FONT COLOR="#228B22">void</FONT></B>){   this-&gt;queue.clear();          }
        ~taskqueue(<B><FONT COLOR="#228B22">void</FONT></B>){  this-&gt;Wait_For_Empty_Queue(); }

        <I><FONT COLOR="#B22222">//----- Methods - Non-blocking.
</FONT></I>        <I><FONT COLOR="#B22222">//This is the quintessential user function.
</FONT></I>        bool Queue(std::function&lt;<B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">void</FONT></B>)&gt; in){            <I><FONT COLOR="#B22222">//Insert the task in the back of the queue.
</FONT></I>            this-&gt;queue_access_mutex.lock();
            this-&gt;queue.push_back(in);
            this-&gt;queue_access_mutex.unlock();
            <B><FONT COLOR="#A020F0">return</FONT></B> this-&gt;Launch();
        }

        bool Queue_Priority(std::function&lt;<B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">void</FONT></B>)&gt; in){   <I><FONT COLOR="#B22222">//Insert the task in the front of the queue.
</FONT></I>            this-&gt;queue_access_mutex.lock();
            this-&gt;queue.push_front(in);
            this-&gt;queue_access_mutex.unlock();
            <B><FONT COLOR="#A020F0">return</FONT></B> this-&gt;Launch();
        }

        decltype(queue) Acquire_Remaining_Queue(<B><FONT COLOR="#228B22">void</FONT></B>){   <I><FONT COLOR="#B22222">//Passes ownership of remaining tasks out.
</FONT></I>            this-&gt;queue_access_mutex.lock();
            decltype(queue) out(std::move(this-&gt;queue));
            this-&gt;queue.clear();
            this-&gt;queue_access_mutex.unlock();
            <B><FONT COLOR="#A020F0">return</FONT></B> out;
        }

        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> QueueSize(<B><FONT COLOR="#228B22">void</FONT></B>){  <I><FONT COLOR="#B22222">//Returns the current size of the queue.
</FONT></I>            <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l_size = 0;
            this-&gt;queue_access_mutex.lock();
            l_size = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(this-&gt;queue.size());
            this-&gt;queue_access_mutex.unlock();
            <B><FONT COLOR="#A020F0">return</FONT></B> l_size;
        }

        <I><FONT COLOR="#B22222">//----- Callback functions.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Set_Callback_Queue_Emptied(std::function&lt;<B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">void</FONT></B>)&gt; in){
            this-&gt;callback_queue_emptied_mutex.lock();
            this-&gt;Callback_Queue_Emptied = in;
            this-&gt;callback_queue_emptied_mutex.unlock();
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        }

        <I><FONT COLOR="#B22222">//----- Methods - Blocking.
</FONT></I>        <I><FONT COLOR="#B22222">//These let the user wait on tasks. Typically used to determine when to deallocate/destruct/destroy/terminate.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Wait_For_Current_Task(<B><FONT COLOR="#228B22">void</FONT></B>){
            <I><FONT COLOR="#B22222">//Block on the current task mutex. Immediately unlock and return afterward.
</FONT></I>            this-&gt;single_task_mutex.lock();
            this-&gt;single_task_mutex.unlock();
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        }
        <B><FONT COLOR="#228B22">void</FONT></B> Wait_For_Empty_Queue(<B><FONT COLOR="#228B22">void</FONT></B>){
            <I><FONT COLOR="#B22222">//Block on the entire queue mutex. Immediately unlock and return afterward.
</FONT></I>            this-&gt;entire_queue_mutex.lock();
            this-&gt;entire_queue_mutex.unlock();
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        }
};

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------ taskpool ------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">// Task Pool - A multi-threaded function evaluator. A given task is pushed into a queue. At the other end of the queue, 
</FONT></I><I><FONT COLOR="#B22222">// there is a pool of threads executing the tasks (ie. 'consuming' them). The tasks are performed by whichever thread is
</FONT></I><I><FONT COLOR="#B22222">// free at a given point. If no threads are available, and there are less than N threads currently running, new threads 
</FONT></I><I><FONT COLOR="#B22222">// are pooled to handle the tasks. Consequently, when a thread finishes and finds no remaining tasks, it sepuku's itself
</FONT></I><I><FONT COLOR="#B22222">// from the pool.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// The order in which tasks are consumed is FIFO. Which thread they will be executed in is not known (and shouldn't matter
</FONT></I><I><FONT COLOR="#B22222">// because all threads are created equally).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>class taskpool {
    <B><FONT COLOR="#5F9EA0">private</FONT></B>:
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::atomic&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; N; <I><FONT COLOR="#B22222">//The maximum number of threads in the pool. This can be adjusted by the user at runtime!
</FONT></I>
        <I><FONT COLOR="#B22222">//This is the basic queue, where tasks are pushed. There is probably no reason why it could not be templated.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::function&lt;<B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">void</FONT></B>)&gt;&gt; queue;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::thread&gt; pool;  <I><FONT COLOR="#B22222">//Need to use a list because removal will not invalidate pointers.
</FONT></I>
        <I><FONT COLOR="#B22222">//Long-blocking mutexes - these block while doing arbitrary computation and thus may block indefinately.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::mutex entire_queue_mutex;   <I><FONT COLOR="#B22222">//Gets flipped on when the first task is launched, off when the last is completed.
</FONT></I>
        <I><FONT COLOR="#B22222">//Short-blocking mutexes - these block during simple tasks like queue alterations and task (lambda) pushing.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::mutex pool_access_mutex;           <I><FONT COLOR="#B22222">//Used for all operations involving the pool.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::mutex queue_access_mutex;          <I><FONT COLOR="#B22222">//Gets flipped on when queue_thread is being used.
</FONT></I>
<I><FONT COLOR="#B22222">//        std::mutex launching_mutex;           //Gets flipped on when launching the task thread initially, off after launch.
</FONT></I><I><FONT COLOR="#B22222">//        std::mutex thread_has_launched_mutex; //Used to block the main thread until first item launches. Used to prevent 
</FONT></I>                                              <I><FONT COLOR="#B22222">// 'sneaky' priority tasks prior to first task..
</FONT></I>
        <I><FONT COLOR="#B22222">//Callbacks which are checked/performed upon specific actions. Each comes with a mutex which locks access.
</FONT></I>        <I><FONT COLOR="#B22222">// Note: these mutexs are simple locks which lock for access AND during execution, so they *may* lock forever.
</FONT></I><I><FONT COLOR="#B22222">//        std::function&lt;void (void)&gt; Callback_Queue_Emptied;
</FONT></I><I><FONT COLOR="#B22222">//        std::mutex callback_queue_emptied_mutex;
</FONT></I>
        <I><FONT COLOR="#B22222">//This will launch a thread into the thread pool. The thread will eventually sepuku itself if it finds the queue
</FONT></I>        <I><FONT COLOR="#B22222">// empty, so we do not need to track it (except that it will live in the list of threads).
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">//Returns 'true' if there were no errors encountered. 
</FONT></I>        bool Launch_Thread(<B><FONT COLOR="#228B22">void</FONT></B>){
            <I><FONT COLOR="#B22222">//Check if the entire queue mutex is locked or not. If not, lock it.
</FONT></I>            this-&gt;entire_queue_mutex.try_lock();

            <I><FONT COLOR="#B22222">//This is the 'brains' of each thread. 
</FONT></I>            <B><FONT COLOR="#228B22">auto</FONT></B> lambda = [&amp;](std::list&lt;std::thread&gt;::iterator self) -&gt; <B><FONT COLOR="#228B22">void</FONT></B> {

                <I><FONT COLOR="#B22222">//Chew through tasks from the queue.
</FONT></I>                this-&gt;queue_access_mutex.lock();
                <B><FONT COLOR="#A020F0">while</FONT></B>(!this-&gt;queue.empty()){
                    <B><FONT COLOR="#228B22">auto</FONT></B> it =  this-&gt;queue.begin();
                    <B><FONT COLOR="#A020F0">if</FONT></B>(!(*it)){
                        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to perform task - the reference appears to be invalid. Removing it and continuing&quot;</FONT></B>);
                        it = this-&gt;queue.erase(it);
                        <B><FONT COLOR="#A020F0">continue</FONT></B>;
                    }

                    <I><FONT COLOR="#B22222">//We copy, test for a lock, and remove this task from the queue. Then we relinquish queue control to the masses. 
</FONT></I>                    <B><FONT COLOR="#228B22">auto</FONT></B> f = std::move(*it);
                    this-&gt;queue.erase(it);
                    this-&gt;queue_access_mutex.unlock();

                    <I><FONT COLOR="#B22222">//Perform the task. We have a local copy, so the queue remains available to the masses.
</FONT></I>                    f();

                    <I><FONT COLOR="#B22222">//Get back control of the queue. 
</FONT></I>                    this-&gt;queue_access_mutex.lock();
                }
                this-&gt;queue_access_mutex.unlock();

                <I><FONT COLOR="#B22222">//Sepuku. Remove self from the thread pool list.
</FONT></I>                <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::thread&gt; underground_railroad;
                this-&gt;pool_access_mutex.lock();
                underground_railroad.push_back(std::move(*self));
                this-&gt;pool.erase(self);
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> alive_threads = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(this-&gt;pool.size());
                this-&gt;pool_access_mutex.unlock();
                
                <I><FONT COLOR="#B22222">//Check if there are any more items in the queue (which may have been queued since earlier).
</FONT></I>                <I><FONT COLOR="#B22222">//
</FONT></I>                <I><FONT COLOR="#B22222">//NOTE: This is not watertight. Maybe we should use an atomic/special lock to determine when threads die...
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B>(alive_threads == 0){
                    this-&gt;queue_access_mutex.lock();
                    <B><FONT COLOR="#A020F0">if</FONT></B>(this-&gt;queue.empty()) this-&gt;entire_queue_mutex.unlock();
                    this-&gt;queue_access_mutex.unlock();
                }

                <I><FONT COLOR="#B22222">//return true;
</FONT></I>                <I><FONT COLOR="#B22222">//underground_railroad.clear();
</FONT></I>                ((underground_railroad.begin()))-&gt;detach();
            };            

            this-&gt;pool_access_mutex.lock();
            this-&gt;pool.push_front(std::thread());
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> it = this-&gt;pool.begin();
            this-&gt;pool_access_mutex.unlock();

            *it = std::thread( lambda, it );

            <I><FONT COLOR="#B22222">//it-&gt;detach();
</FONT></I>            <B><FONT COLOR="#A020F0">return</FONT></B> true;
        }

        bool Spawn_Thread_If_Needed(<B><FONT COLOR="#228B22">void</FONT></B>){
            <I><FONT COLOR="#B22222">//Check if there are &lt;N threads running. If so, spawn a new one.
</FONT></I>            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> n = this-&gt;N.load();
            this-&gt;pool_access_mutex.lock();
            <B><FONT COLOR="#228B22">const</FONT></B> bool spawnthread = (static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(pool.size()) &lt; n);
            this-&gt;pool_access_mutex.unlock();

            <B><FONT COLOR="#A020F0">if</FONT></B>(spawnthread){
                <I><FONT COLOR="#B22222">//FUNCINFO(&quot;We have not spawned the max number of threads. Launching thread now&quot;);
</FONT></I>                <B><FONT COLOR="#A020F0">return</FONT></B> this-&gt;Launch_Thread();
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                <I><FONT COLOR="#B22222">//FUNCINFO(&quot;We have spawned the limit number of threads. Nothing to do, so leaving&quot;);
</FONT></I>                <B><FONT COLOR="#A020F0">return</FONT></B> true;
            }
        }

    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <I><FONT COLOR="#B22222">//----- Constructors/Destructor.
</FONT></I>        taskpool(<B><FONT COLOR="#228B22">void</FONT></B>){   
            this-&gt;queue.clear();
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> hwn = 2*std::thread::hardware_concurrency();
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> n   = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;((hwn &gt; 0) ? hwn : 2);  <I><FONT COLOR="#B22222">//Fall back on two threads. Seems reasonable.
</FONT></I>            this-&gt;N.store(n);
            <I><FONT COLOR="#B22222">//FUNCINFO(&quot;Using &quot; &lt;&lt; n &lt;&lt; &quot; threads in the pool&quot;);
</FONT></I>        }
        ~taskpool(<B><FONT COLOR="#228B22">void</FONT></B>){
            <I><FONT COLOR="#B22222">//FUNCINFO(&quot;Waiting for queue to empty&quot;);
</FONT></I>            this-&gt;Wait_For_Empty_Queue();  <I><FONT COLOR="#B22222">//Wait for the tasks to finish to avoid memory loss.
</FONT></I>        }

        <I><FONT COLOR="#B22222">//----- Methods - Non-blocking.
</FONT></I>        <I><FONT COLOR="#B22222">//This is the quintessential user function.
</FONT></I>        bool Queue(std::function&lt;<B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">void</FONT></B>)&gt; in){            <I><FONT COLOR="#B22222">//Insert the task in the back of the queue.
</FONT></I>            <I><FONT COLOR="#B22222">//Push the task into the queue. It may be consumed prior to launching a thread to execute it. This is OK!
</FONT></I>            this-&gt;queue_access_mutex.lock();
            this-&gt;queue.push_back(in);
            this-&gt;queue_access_mutex.unlock();

            <B><FONT COLOR="#A020F0">return</FONT></B> this-&gt;Spawn_Thread_If_Needed();
        }

        <I><FONT COLOR="#B22222">//This function inserts the task into the front of the queue, where it will be consumed ASAP.
</FONT></I>        bool Queue_Priority(std::function&lt;<B><FONT COLOR="#228B22">void</FONT></B> (<B><FONT COLOR="#228B22">void</FONT></B>)&gt; in){
            <I><FONT COLOR="#B22222">//Push the task into the queue. It may be consumed prior to launching a thread to execute it. This is OK!
</FONT></I>            this-&gt;queue_access_mutex.lock();
            this-&gt;queue.push_front(in);
            this-&gt;queue_access_mutex.unlock();

            <B><FONT COLOR="#A020F0">return</FONT></B> this-&gt;Spawn_Thread_If_Needed();
        }

        decltype(queue) Acquire_Remaining_Queue(<B><FONT COLOR="#228B22">void</FONT></B>){   <I><FONT COLOR="#B22222">//Passes ownership of remaining tasks out.
</FONT></I>            this-&gt;queue_access_mutex.lock();
            decltype(queue) out(std::move(this-&gt;queue));
            this-&gt;queue.clear();
            this-&gt;queue_access_mutex.unlock();
            <B><FONT COLOR="#A020F0">return</FONT></B> out;
        }

        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> QueueSize(<B><FONT COLOR="#228B22">void</FONT></B>){  <I><FONT COLOR="#B22222">//Returns the current size of the queue.
</FONT></I>            this-&gt;queue_access_mutex.lock();
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> l_size = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(this-&gt;queue.size());
            this-&gt;queue_access_mutex.unlock();
            <B><FONT COLOR="#A020F0">return</FONT></B> l_size;
        }

<I><FONT COLOR="#B22222">//        //----- Callback functions.
</FONT></I><I><FONT COLOR="#B22222">//        void Set_Callback_Queue_Emptied(std::function&lt;void (void)&gt; in){
</FONT></I><I><FONT COLOR="#B22222">//            this-&gt;callback_queue_emptied_mutex.lock();
</FONT></I><I><FONT COLOR="#B22222">//            this-&gt;Callback_Queue_Emptied = in;
</FONT></I><I><FONT COLOR="#B22222">//            this-&gt;callback_queue_emptied_mutex.unlock();
</FONT></I><I><FONT COLOR="#B22222">//            return;
</FONT></I><I><FONT COLOR="#B22222">//        }
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//        //----- Methods - Blocking.
</FONT></I><I><FONT COLOR="#B22222">//        //These let the user wait on tasks. Typically used to determine when to deallocate/destruct/destroy/terminate.
</FONT></I><I><FONT COLOR="#B22222">//        void Wait_For_Current_Task(void){
</FONT></I><I><FONT COLOR="#B22222">//            //Block on the current task mutex. Immediately unlock and return afterward.
</FONT></I><I><FONT COLOR="#B22222">//            this-&gt;single_task_mutex.lock();
</FONT></I><I><FONT COLOR="#B22222">//            this-&gt;single_task_mutex.unlock();
</FONT></I><I><FONT COLOR="#B22222">//            return;
</FONT></I><I><FONT COLOR="#B22222">//        }
</FONT></I>
        <B><FONT COLOR="#228B22">void</FONT></B> Wait_For_Empty_Queue(<B><FONT COLOR="#228B22">void</FONT></B>){
            <I><FONT COLOR="#B22222">//Block on the entire queue mutex. Immediately unlock and return afterward.
</FONT></I>            this-&gt;entire_queue_mutex.lock();
            this-&gt;entire_queue_mutex.unlock();
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        }
};


#<B><FONT COLOR="#5F9EA0">endif</FONT></B> 
</PRE>
<HR>
<A NAME="file5">
<H1>YgorDICOMTools.h 5/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file4">prev</A>][<A HREF="#file6">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorDICOMTools.h - A collection of routines for parsing/reading/writing/modifying/inspecting DICOM-format files.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: These still need to be rigorously tested. Do NOT use them for any critical purposes prior to verification!
</FONT></I>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_DICOMTOOLS_H_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_DICOMTOOLS_H_</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>

bool <B><FONT COLOR="#0000FF">Is_File_A_DICOM_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);




<B><FONT COLOR="#5F9EA0">std</FONT></B>::basic_string&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;  Simple_DICOM_Header( <B><FONT COLOR="#228B22">void</FONT></B> );

<I><FONT COLOR="#B22222">/*
union small;
union large;
*/</FONT></I>

<B><FONT COLOR="#228B22">union</FONT></B> small {
    uint16_t i;
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> c[2];
};

<B><FONT COLOR="#228B22">union</FONT></B> large {
    uint32_t i;
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> c[4];
    small s[2];
};

<I><FONT COLOR="#B22222">//class piece;
</FONT></I>class piece {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        large A;
        large B;

        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> data_size;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::basic_string&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt; data;

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;piece&gt; child;   <I><FONT COLOR="#B22222">//This is the data, delinearized into sequential items.
</FONT></I>};


bool <B><FONT COLOR="#0000FF">Is_Common_ASCII</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> &amp;in );
bool operator==( <B><FONT COLOR="#228B22">const</FONT></B> large &amp;L, <B><FONT COLOR="#228B22">const</FONT></B> large &amp;R );
bool operator==( <B><FONT COLOR="#228B22">const</FONT></B> small &amp;L, <B><FONT COLOR="#228B22">const</FONT></B> small &amp;R );

<B><FONT COLOR="#5F9EA0">std</FONT></B>::ostream &amp; operator&lt;&lt;( std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> large &amp;in );
<B><FONT COLOR="#5F9EA0">std</FONT></B>::ostream &amp; operator&lt;&lt;( std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> small &amp;in );

class piece;
<B><FONT COLOR="#5F9EA0">std</FONT></B>::ostream &amp; operator&lt;&lt;( std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> std::basic_string&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt; &amp;in );
<B><FONT COLOR="#5F9EA0">std</FONT></B>::ostream &amp; operator&lt;&lt;( std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> piece &amp;in );

bool <B><FONT COLOR="#0000FF">Does_A_B_Not_Denote_A_Size</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> large &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> large &amp;B );
bool <B><FONT COLOR="#0000FF">Do_Last_Two_Bytes_of_B_Denote_A_Size</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> large &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> large &amp;B );
bool <B><FONT COLOR="#0000FF">Do_Next_Four_Bytes_Denote_A_Size</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> large &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> large &amp;B );
bool <B><FONT COLOR="#0000FF">Can_This_Elements_Data_Be_Delineated</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> piece &amp;in );

<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> * <B><FONT COLOR="#0000FF">Validate_DICOM_Format</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *begin, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *end);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;piece&gt; Parse_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *begin, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *end);
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Delineate_Children</FONT></B>(std::vector&lt;piece&gt; &amp;in);

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Dump_Children</FONT></B>(std::ostream &amp; out, <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;piece&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string space = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>); <I><FONT COLOR="#B22222">//NOTE: space defaults to &quot;&quot;
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Dump_Children</FONT></B>(std::ostream &amp; out, <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;piece *&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string space = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>); <I><FONT COLOR="#B22222">//NOTE: space defaults to &quot;&quot;
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Get_Elements</FONT></B>(std::vector&lt;piece *&gt; &amp;out, std::vector&lt;piece&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;uint32_t&gt; &amp;key, <B><FONT COLOR="#228B22">const</FONT></B> uint32_t depth = 0); <I><FONT COLOR="#B22222">//NOTE: depth defaults to 0
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Prep_Children_For_Recompute_Children_Data_Size</FONT></B>( std::vector&lt;piece&gt; &amp;in );

<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">Recompute_Children_Data_Size</FONT></B>( std::vector&lt;piece&gt; &amp;in );
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Repack_Nodes</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;piece&gt; &amp;in, std::basic_string&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt; &amp;out );

#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file6">
<H1>YgorEnvironment.h 6/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file5">prev</A>][<A HREF="#file7">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorEnvironment.h
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_ENVIRONMENT_HDR_GRD_H</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_ENVIRONMENT_HDR_GRD_H</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;utility&gt;</FONT></B>


<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------- /bin/bash system(3) ------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">system_bash</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *command);

<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------- Simple Input ---------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Wait_For_Enter_Press</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>);

<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------- Simple Email Sending -----------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I>bool <B><FONT COLOR="#0000FF">Send_Simple_SMTP_Email</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;TO, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;subject, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;msg);          <I><FONT COLOR="#B22222">//DEPRECATED and BROKEN! Do not use!
</FONT></I>
<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------- Framebuffer ---------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; Get_Framebuffer_Pixel_Dimensions(<B><FONT COLOR="#228B22">int</FONT></B> fbN, bool Virtual = false);

<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------- Terminal Dimensions ----------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; Get_Terminal_Char_Dimensions(<B><FONT COLOR="#228B22">void</FONT></B>); <I><FONT COLOR="#B22222">//W,H.
</FONT></I>
<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------- X-related ----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I>bool <B><FONT COLOR="#0000FF">Is_X_Running_And_In_Focus</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>);


<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------- Memory-related --------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Amount_Of_Total_Memory_MB</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>);
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Amount_Of_Totally_Free_Memory_MB</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>);




<I><FONT COLOR="#B22222">//-------- Other (? Should this be here???)
</FONT></I>
<I><FONT COLOR="#B22222">//----------------------------------- Print color text in a console using a simple 'setter' side-effect call. --------------------------
</FONT></I><I><FONT COLOR="#B22222">/*#include &lt;stdio.h&gt;

#define RESET           0
#define BRIGHT          1
#define DIM             2
#define UNDERLINE       3
#define BLINK           4
#define REVERSE         7
#define HIDDEN          8

#define BLACK           0
#define RED             1
#define GREEN           2
#define YELLOW          3
#define BLUE            4
#define MAGENTA         5
#define CYAN            6
#define WHITE           7

void textcolor(int attr, int fg, int bg);
int main()
{       textcolor(BRIGHT, RED, WHITE);
        printf(&quot;In color\n&quot;);
        textcolor(RESET, WHITE, BLACK);
        return 0;
}

void textcolor(int attr, int fg, int bg)
{       char command[13];

        //Command is the control command to the terminal.
        sprintf(command, &quot;%c[%d;%d;%dm&quot;, 0x1B, attr, fg + 30, bg + 40);
        printf(&quot;%s&quot;, command);
}
*/</FONT></I>

#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file7">
<H1>YgorFilesDirs.h 7/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file6">prev</A>][<A HREF="#file8">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorFilesDirs.h
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_FILES_DIRS_HDR_GRD_H</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_FILES_DIRS_HDR_GRD_H</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;memory&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;fstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ctime&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdint&gt;</FONT></B> //For intmax_t

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/stat.h&gt;</FONT></B>



<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------- Files Only ----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//Checks if a file exists and is available to be read. Closes the file in either case.
</FONT></I>bool <B><FONT COLOR="#0000FF">Does_File_Exist_And_Can_Be_Read</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename);

<I><FONT COLOR="#B22222">//Returns the first filename which exists and is available to be read, or an empty string.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Get_First_Filename_Which_Exists_And_Can_Be_Read(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::string&gt; &amp;filenames);

<I><FONT COLOR="#B22222">//Returns the size of the file in bytes without having to open/seek/close it. 
</FONT></I><I><FONT COLOR="#B22222">//off_t Size_of_File(const std::string &amp;filename);
</FONT></I>intmax_t <B><FONT COLOR="#0000FF">Size_of_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename);

<I><FONT COLOR="#B22222">//Returns last time of access, or (std::time_t)(-1) if an error occurs.
</FONT></I><I><FONT COLOR="#B22222">// Should work for both files and directories.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::time_t Last_Access_Time(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;pathorfilename);

<I><FONT COLOR="#B22222">//Returns last time of modification, or (std::time_t)(-1) if an error occurs.
</FONT></I><I><FONT COLOR="#B22222">// Should work for both files and directories.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::time_t Last_Modification_Time(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;pathorfilename);

<I><FONT COLOR="#B22222">//Returns a string containing an md5, or an empty string on failure.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string MD5_of_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename);
 
<I><FONT COLOR="#B22222">//Gets from byte N to byte N+L from a file. Should only use for large files, because it is opened/closed each time.
</FONT></I>template &lt;class T&gt; std::unique_ptr&lt;T[]&gt; Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L); <I><FONT COLOR="#B22222">//std::ios::pos_type N, std::ios::pos_type L);
</FONT></I>
<I><FONT COLOR="#B22222">//Checks if a FIFO exists.
</FONT></I>bool <B><FONT COLOR="#0000FF">Does_Fifo_Exist</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename);

<I><FONT COLOR="#B22222">//Generates random filenames, given a prefix filename. This replaces mkstemp, tmpfile, etc.. from unistd
</FONT></I><I><FONT COLOR="#B22222">// and other non-portable (non-reliable?) methods (just need to wrap the guts of these functions for other
</FONT></I><I><FONT COLOR="#B22222">// systems...)   NOTE: This routine does *not* reserve the name for you!
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Get_Unique_Filename(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;prefix, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> len, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;suffix = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Get_Unique_Sequential_Filename(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;prefix, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_of_zero_pads = 6, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;suffix = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);

<I><FONT COLOR="#B22222">//Expand a filename/partial path/full path/symbolic link/./.. into a full path. Empty string is returned on fail.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Fully_Expand_Filename(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename);

<I><FONT COLOR="#B22222">//Determines if a path is below another path. Useful for specifying whitelists of files/directories.
</FONT></I>bool <B><FONT COLOR="#0000FF">File_Is_Recursively_Within_Directory</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;pathname_in);

<I><FONT COLOR="#B22222">//Reads a file in binary mode and returns a pointer to the data.
</FONT></I>template &lt;class T&gt; std::unique_ptr&lt;T[]&gt; Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);

<I><FONT COLOR="#B22222">//Writes a block of data to file.
</FONT></I>template &lt;class T&gt; bool Write_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;T[]&gt; in, intmax_t size);

<I><FONT COLOR="#B22222">//Append a block of data to file.
</FONT></I>template &lt;class T&gt; bool Append_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;T[]&gt; in, intmax_t size);

<I><FONT COLOR="#B22222">//Load a file into a string, line by line, delimited by '\n'.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string LoadFileToString(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in);

<I><FONT COLOR="#B22222">//Load a binary file and copy the memory into a std::string. Involves a copy, so use only for small things.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string LoadBinaryFileToString(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in);

<I><FONT COLOR="#B22222">//Load a file into a list with no delimiters.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; LoadFileToList(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in);

<I><FONT COLOR="#B22222">//Write a string to a file. No extra formatting is performed. Returns true on success.
</FONT></I>bool <B><FONT COLOR="#0000FF">WriteStringToFile</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, bool overwrite = false);

<I><FONT COLOR="#B22222">//Write a binary string to a file. Returns true on success.
</FONT></I>bool <B><FONT COLOR="#0000FF">WriteBinaryStringToFile</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, bool overwrite = false);

<I><FONT COLOR="#B22222">//Append a string to file, creating the file if necessary. Returns true on success.
</FONT></I>bool <B><FONT COLOR="#0000FF">AppendStringToFile</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in);

<I><FONT COLOR="#B22222">//Creates a FIFO at the specified path. User must then read/write to use it.
</FONT></I>bool <B><FONT COLOR="#0000FF">CreateFIFOFile</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in);

<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------- Directories ---------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//Checks if a directory exists and can be read. 
</FONT></I>bool <B><FONT COLOR="#0000FF">Does_Dir_Exist_And_Can_Be_Read</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir);

<I><FONT COLOR="#B22222">//Acts like `mkdir -p $dir`. Supply full path if (somehow) in an orphan working directory.
</FONT></I>bool <B><FONT COLOR="#0000FF">Create_Dir_and_Necessary_Parents</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir);

<I><FONT COLOR="#B22222">//Returns a list of the files and (non-'.' and -'..') dirs under a dir. Empty list on error (or empty dir!).
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; Get_List_of_File_and_Dir_Names_in_Dir(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir);

<I><FONT COLOR="#B22222">//Same as 'Get_List_of_File_and_Dir_Names_in_Dir()' but with preceeding directory appended.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; Get_List_of_Full_Path_File_and_Dir_Names_in_Dir(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir);

<I><FONT COLOR="#B22222">//Returns a list of the files under a dir. Empty list on error (or empty dir!).
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; Get_List_of_File_Names_in_Dir(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir);

<I><FONT COLOR="#B22222">//Same as 'Get_List_of_File_Names_in_Dir()' but with preceeding directory appended.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; Get_List_of_Full_Path_File_Names_in_Dir(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir);

#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file8">
<H1>YgorImages.h 8/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file7">prev</A>][<A HREF="#file9">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorImages.h
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_HDR_GRD_H</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_HDR_GRD_H</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;memory&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMath.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------- planar_image ----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This is a class used to handle flat images (ie. 2D buffers) which may be floating in 3D space. This 
</FONT></I><I><FONT COLOR="#B22222">// class is useful because it encapsulates external indexing and querying. It can simply dole out 
</FONT></I><I><FONT COLOR="#B22222">// image values, or it can precisely tell you the 3D center of a given pixel (or voxel).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>template &lt;class T, class R&gt; class planar_image {
    <I><FONT COLOR="#B22222">//NOTE: template type T --- image data type (probably unsigned int).
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: template type R --- real-world coordinates (probably double or float).
</FONT></I>
    <B><FONT COLOR="#5F9EA0">public</FONT></B>: <I><FONT COLOR="#B22222">//private:
</FONT></I>        <I><FONT COLOR="#B22222">//This is the actual, raw, 2D data.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;T []&gt; data;

        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> rows;      <I><FONT COLOR="#B22222">//This is the number of rows in the 2D image.
</FONT></I>        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> columns; 

        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> channels;  <I><FONT COLOR="#B22222">//The number of colour channels.
</FONT></I>
        R pxl_dx;<I><FONT COLOR="#B22222">//(row)    //This is the R^3 spacing of adjacent pixels. It is nearest-neighbour distance
</FONT></I>        R pxl_dy;<I><FONT COLOR="#B22222">//(col)    // in the image plane (where |x| points along the row unit vector - see below).
</FONT></I>        R pxl_dz;           <I><FONT COLOR="#B22222">//This is the R^3 'thickness' of the image. A thickness of 0 is
</FONT></I>                            <I><FONT COLOR="#B22222">// perfectly fine. This meaning of the thickness of a plane is up to the user.
</FONT></I>                            <I><FONT COLOR="#B22222">// It is treated as the thickness along the normal to row and col unit vectors.
</FONT></I>                            <I><FONT COLOR="#B22222">// It is considered to be half above and half below plane of image for internal
</FONT></I>                            <I><FONT COLOR="#B22222">// calculations.
</FONT></I>
        vec3&lt;R&gt; anchor;     <I><FONT COLOR="#B22222">//An (arbitrary) point in R^3 in which the image is considered to be anchored to.
</FONT></I>                            <I><FONT COLOR="#B22222">// The edges, corners, and center of the image are given relative to this.
</FONT></I>                            <I><FONT COLOR="#B22222">// The point is virtual, and should be thought of as the origin of a frame of 
</FONT></I>                            <I><FONT COLOR="#B22222">// reference (which may not be at (0,0,0)).
</FONT></I>                            <I><FONT COLOR="#B22222">//NOTE: This vector is most likely to be (0,0,0) for typical usage.
</FONT></I>
        vec3&lt;R&gt; offset;     <I><FONT COLOR="#B22222">//A vector from the anchor's terminus to the *center* of the pixel with image 
</FONT></I>                            <I><FONT COLOR="#B22222">// coordinates (0,0). It is how we specify the position of the 2D data in R^3.
</FONT></I>
        vec3&lt;R&gt; row_unit;   <I><FONT COLOR="#B22222">//An orientation unit vector denoting the (positive) direction of row indices.
</FONT></I>                            <I><FONT COLOR="#B22222">// For example, if R denotes the location of pixel(i,j), then
</FONT></I>                            <I><FONT COLOR="#B22222">// [R' = R + row_unit*pxl_dx] is the location of pixel(i+1,j) (if it exists).
</FONT></I>
        vec3&lt;R&gt; col_unit;   <I><FONT COLOR="#B22222">//An orientation unit vector denoting the (positive) direction of col indices.
</FONT></I>                            <I><FONT COLOR="#B22222">// For example, if R denotes the location of pixel(i,j), then
</FONT></I>                            <I><FONT COLOR="#B22222">// [R' = R + col_unit*pxl_dy] is the location of pixel(i,j+1) (if it exists).
</FONT></I>

        <I><FONT COLOR="#B22222">//------------------------------------ Member functions --------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Zero-based indexing (the default).
</FONT></I>        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> index(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> c) <B><FONT COLOR="#228B22">const</FONT></B>;    <I><FONT COLOR="#B22222">//Note: For external access, prefer this-&gt;value().
</FONT></I>        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> index(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B>;

        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> index(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;point, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Returns -1 on failure/out of bounds.
</FONT></I>
    <I><FONT COLOR="#B22222">//public:
</FONT></I>
        <I><FONT COLOR="#B22222">//------------------------------------ Member functions --------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Constructor/Destructors.
</FONT></I>        planar_image();
        planar_image(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;T,R&gt; &amp;in);
        ~planar_image();

        <I><FONT COLOR="#B22222">//Allocating space and initializing the purely-2D-image members.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> init_buffer(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> rows, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> columns, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> channels);

        <I><FONT COLOR="#B22222">//Initializing the R^3 members. These are less important because they won't cause a segfault.
</FONT></I>        <I><FONT COLOR="#B22222">// If one wants to simply deal with R^2 image data, they could probably skip these.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> init_spatial(R pxldx, R pxldy, R pxldz, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;anchr, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;offst);
        <B><FONT COLOR="#228B22">void</FONT></B> init_orientation(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;rowunit, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;colunit);

        planar_image &amp; operator= (<B><FONT COLOR="#228B22">const</FONT></B> planar_image &amp;); <I><FONT COLOR="#B22222">//Performs a deep copy (unless copying self).
</FONT></I>        bool operator==(<B><FONT COLOR="#228B22">const</FONT></B> planar_image &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Compares image position, dimensions, orientation, and finally image contents.
</FONT></I>        bool operator!=(<B><FONT COLOR="#228B22">const</FONT></B> planar_image &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool operator&lt; (<B><FONT COLOR="#228B22">const</FONT></B> planar_image &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//This is mostly for sorting / placing into a std::map. There is no great 
</FONT></I>                                                     <I><FONT COLOR="#B22222">// way to define '&lt;' for images, so be careful with it. This is designed to be fast, not reliable!
</FONT></I>
        <I><FONT COLOR="#B22222">//Get the value of a channel.
</FONT></I>        T value(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Fails on out-of-bounds input.
</FONT></I>        T value(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;point, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Returns the value of the voxel which contains the point, or zero.
</FONT></I>
        <I><FONT COLOR="#B22222">//Get a reference to the value of a channel. This can be used to set it.
</FONT></I>        T&amp; reference(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl);

        <I><FONT COLOR="#B22222">//Get an R^3 position of the *center* of the pixel/voxel.
</FONT></I>        vec3&lt;R&gt; position(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col) <B><FONT COLOR="#228B22">const</FONT></B>;

        <I><FONT COLOR="#B22222">//Determine if a given point in R^3 is encompassed by the 3D volume of the image (using 'thickness' pxl_dz).
</FONT></I>        bool encompasses_point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Note: does not consider points on the boundary encompassed.
</FONT></I>
        <I><FONT COLOR="#B22222">//Determine if a given point is in the infinite, thick plane defined by the 'top' and 'bottom' of image.
</FONT></I>        bool sandwiches_point_within_top_bottom_planes(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;

        <I><FONT COLOR="#B22222">//Computes the R^3 center of the image. Nothing fancy.
</FONT></I>        vec3&lt;R&gt; center(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;

        <I><FONT COLOR="#B22222">//Returns an ordered list of the corners of the 2D image. Does NOT use thickness!
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;vec3&lt;R&gt;&gt; corners2D(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>; 

        <I><FONT COLOR="#B22222">//Returns true if the 3D volume of this image encompasses the 2D image of the given planar image.
</FONT></I>        bool encloses_2D_planar_image(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;T,R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Note: considers images on the boundary enclosed.
</FONT></I>
        <I><FONT COLOR="#B22222">//Compare the geometrical (non-pixel/voxel) aspects of the image to another.
</FONT></I>        bool Compare_Geom(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;T,R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;

        <I><FONT COLOR="#B22222">//Plot an outline of the image. Useful for alignment testing.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Plot_Outline(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;

};




<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------- image_collection: a collection of logically-related planar_images  -----------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class is a sort of utility class for holding logically-grouped images. For instance, a 3D array may be represented
</FONT></I><I><FONT COLOR="#B22222">// as a stack of planar_images. Note, however, that the onus is on the user to ensure the collection is sorted/handled
</FONT></I><I><FONT COLOR="#B22222">// in a consistent way.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Essentially, this class is a thin wrapper around a std::list&lt;planar_image&gt; with some extra things like 3D plotting
</FONT></I><I><FONT COLOR="#B22222">// and some multi-image operations (like channel-volume groupings, etc..)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This class assumes that all contained images are part of a logically cohesive unit. It is the user's responsibility
</FONT></I><I><FONT COLOR="#B22222">// to correctly interpret/handle their particular meaning of the words 'logically related'. Some operations may violate
</FONT></I><I><FONT COLOR="#B22222">// this notion in some scenarios. It is important not to enforce or require any particular arrangement so as to remain 
</FONT></I><I><FONT COLOR="#B22222">// as general as possible, whereever possible.
</FONT></I>template &lt;class T,class R&gt;   class planar_image_collection {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;planar_image&lt;T,R&gt;&gt; images;   <I><FONT COLOR="#B22222">//This is not a list of pointers because the planar_images contain a 
</FONT></I>                                               <I><FONT COLOR="#B22222">// pointer to the data. It is cheap to move around planar_images!
</FONT></I>                                               <I><FONT COLOR="#B22222">// Copying is another story. We usually want a local copy of image
</FONT></I>                                               <I><FONT COLOR="#B22222">// data, so deep copying will be performed.
</FONT></I>        <I><FONT COLOR="#B22222">//Constructors.
</FONT></I>        planar_image_collection();
        planar_image_collection(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;T,R&gt; &amp;);
        planar_image_collection(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;planar_image&lt;T,R&gt;&gt; &amp;);


        <I><FONT COLOR="#B22222">//Member functions.
</FONT></I>        planar_image_collection &amp; operator=(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection &amp;); <I><FONT COLOR="#B22222">//Performs a deep copy (unless copying self).
</FONT></I>        bool operator==(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Relies on the planar_image operator==. See caveats there.
</FONT></I>        bool operator!=(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool operator&lt; (<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Relies on the planar_image operator&lt; . See caveats there. Only use for sorting.
</FONT></I>
        <I><FONT COLOR="#B22222">//Returns a list of list::const_iterators to images which encompass a given point. Be careful not to invalidate the data after calling this!
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;typename std::list&lt;planar_image&lt;T,R&gt;&gt;::const_iterator&gt; get_images_which_encompass_point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;typename std::list&lt;planar_image&lt;T,R&gt;&gt;::const_iterator&gt; get_images_which_sandwich_point_within_top_bottom_planes(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;

        <I><FONT COLOR="#B22222">//Computes the R^3 center of the images.
</FONT></I>        vec3&lt;R&gt; center(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;

        <I><FONT COLOR="#B22222">//Compare the geometrical (non-pixel/voxel) aspects of the images to one another.
</FONT></I>        bool Compare_Geom(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;T,R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;

        <B><FONT COLOR="#228B22">void</FONT></B> Plot_Outlines(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title) <B><FONT COLOR="#228B22">const</FONT></B>;     <I><FONT COLOR="#B22222">//Spits out a default R^3 plot of the image outlines.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Plot_Outlines(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;

};


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------- postscriptinator: a thin class for generating Postscript images -------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class generates Postscript files from simple data. It was developed to convert the workflow 
</FONT></I><I><FONT COLOR="#B22222">// R^3 -&gt; OpenGL Bitmap -&gt; R^3 (using potrace or similar) into just R^3.
</FONT></I>
template &lt;class R&gt; class postscriptinator {
    R xmin, xmax, ymin, ymax;  <I><FONT COLOR="#B22222">//Drawing coordinates.
</FONT></I>    R PageW, PageH;            <I><FONT COLOR="#B22222">//Page geometry (in [cm]).
</FONT></I>    bool Enable_Auto_Sizing;   <I><FONT COLOR="#B22222">//Default is yes. Will be flipped to no if size explicitly set by user.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string Definitions;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string Header; <I><FONT COLOR="#B22222">//Note: Does NOT hold the '%!PS' at the top!
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; Stack; <I><FONT COLOR="#B22222">//Holds postscript commands. May morph into something more easily parseable (true stack)...
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string Footer;

    <I><FONT COLOR="#B22222">//Constructor.
</FONT></I>    postscriptinator();

    <I><FONT COLOR="#B22222">//Methods. 
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> Import_Contour(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;R&gt; &amp;C, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;Proj2);


    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string Generate_Page_Geom(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string Assemble(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Assembles all the pieces into a single string.
</FONT></I>};


#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file9">
<H1>YgorMath.h 9/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file8">prev</A>][<A HREF="#file10">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorMath.h
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_MATH_H_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_MATH_H_</FONT>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;fstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;complex&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;functional&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;tuple&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------- One-Offs ------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//Moved to YgorStats.
</FONT></I><I><FONT COLOR="#B22222">//double Stats::P_From_StudT_1Tail(double tval, double dof);
</FONT></I><I><FONT COLOR="#B22222">//double Stats::P_From_StudT_2Tail(double tval, double dof);
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//double Stats::P_From_StudT_Diff_Means_From_Uneq_Vars(double M1, double S1, double N1, double M2, double S2, double N2);
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//double Stats::Q_From_ChiSq_Fit(double chi_square, double dof);
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//double Stats::Unbiased_Var_Est(std::list&lt;double&gt; in);
</FONT></I>

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Ygor_Sum</FONT></B>(std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; in);
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Ygor_Sum_Squares</FONT></B>(std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; in);

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Ygor_Median</FONT></B>(std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; in);
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Ygor_Mean</FONT></B>(std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; in);

<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------- vec3: A three-dimensional vector -------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class is the basis of the geometry-heavy classes below. It can happily be used on its own.
</FONT></I>template &lt;class T&gt; class vec3 {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        T x, y, z;
    
        <I><FONT COLOR="#B22222">//Constructors.
</FONT></I>        vec3();
        vec3(T a, T b, T c);
        vec3( <B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp; );
    
        <I><FONT COLOR="#B22222">//Operators - vec3 typed.
</FONT></I>        vec3 &amp; operator=(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;);
    
        vec3   operator+(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        vec3 &amp; operator+=(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;);
        vec3   operator-(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        vec3 &amp; operator-=(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;);
    
        bool operator==(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool operator!=(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool operator&lt;(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;   <I><FONT COLOR="#B22222">//This is mostly for sorting / placing into a std::map. There is no great 
</FONT></I>                                              <I><FONT COLOR="#B22222">// way to define '&lt;' for a vector, so be careful with it.
</FONT></I>    
        <I><FONT COLOR="#B22222">//Operators - T typed.
</FONT></I>        <I><FONT COLOR="#B22222">//vec3   operator*(const T);
</FONT></I>        <I><FONT COLOR="#B22222">//vec3 &amp; operator*=(const T);
</FONT></I>        <I><FONT COLOR="#B22222">//vec3   operator/(const T);
</FONT></I>        <I><FONT COLOR="#B22222">//vec3 &amp; operator/=(const T);
</FONT></I>    
        vec3   operator*(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        vec3 &amp; operator*=(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;);
        vec3   operator/(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        vec3 &amp; operator/=(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;);
    
        <I><FONT COLOR="#B22222">//Member functions.
</FONT></I>        T Dot(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;        <I><FONT COLOR="#B22222">// ---&gt; Dot product.
</FONT></I>        vec3 Cross(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;   <I><FONT COLOR="#B22222">// ---&gt; Cross product.
</FONT></I>        vec3 Mask(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;    <I><FONT COLOR="#B22222">// ---&gt; Term-by-term product:   (a b c).Outer(1 2 0) = (a 2*b 0)
</FONT></I>    
        vec3 unit() <B><FONT COLOR="#228B22">const</FONT></B>;                <I><FONT COLOR="#B22222">// ---&gt; Return a normalized version of this vector.
</FONT></I>        T length() <B><FONT COLOR="#228B22">const</FONT></B>;                 <I><FONT COLOR="#B22222">// ---&gt; (pythagorean) length of vector.
</FONT></I>        T distance(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;   <I><FONT COLOR="#B22222">// ---&gt; (pythagorean) distance between vectors.
</FONT></I>        T sq_dist(<B><FONT COLOR="#228B22">const</FONT></B> vec3 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;    <I><FONT COLOR="#B22222">// ---&gt; Square of the (pythagorean) distance. Avoids a sqrt().
</FONT></I>
        <I><FONT COLOR="#B22222">//Friends.
</FONT></I><I><FONT COLOR="#B22222">//        template&lt;class Y&gt; friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp;, const vec3&lt;Y&gt; &amp;); // ---&gt; Overloaded stream operators.
</FONT></I><I><FONT COLOR="#B22222">//        template&lt;class Y&gt; friend std::istream &amp; operator &gt;&gt; (std::istream &amp;, vec3&lt;T&gt; &amp;);      
</FONT></I>        template&lt;class Y&gt; friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp;, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;Y&gt; &amp;); <I><FONT COLOR="#B22222">// ---&gt; Overloaded stream operators.
</FONT></I>        template&lt;class Y&gt; friend std::istream &amp; operator &gt;&gt; (std::istream &amp;, vec3&lt;Y&gt; &amp;);      
};


<I><FONT COLOR="#B22222">//This is a function for rotation unit vectors in some plane. It requires angles to describe the plane of rotation, angle of rotation. 
</FONT></I><I><FONT COLOR="#B22222">// It also requires a unit vector with which to rotate the plane about.
</FONT></I>vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; rotate_unit_vector_in_plane(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;theta, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;R);

<I><FONT COLOR="#B22222">//This function evolves a pair of position and velocity (x(t=0),v(t=0)) to a pair (x(t=T),v(t=T)) using the
</FONT></I><I><FONT COLOR="#B22222">// classical expression for a time- and position-dependent force F(x;t). It is highly unstable, so the number
</FONT></I><I><FONT COLOR="#B22222">// of iterations must be specified. If this is going to be used for anything important, make sure that the
</FONT></I><I><FONT COLOR="#B22222">// number of iterations is chosen sufficiently high so as to produce negligible errors.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::tuple&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; Evolve_x_v_over_T_via_F(<B><FONT COLOR="#228B22">const</FONT></B> std::tuple&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;x_and_v, 
                                                              <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; x, <B><FONT COLOR="#228B22">double</FONT></B> T)&gt; F, 
                                                              <B><FONT COLOR="#228B22">double</FONT></B> T, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> steps);


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------- vec2: A two-dimensional vector --------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class is the basis of the geometry-heavy classes below. It can happily be used on its own.
</FONT></I>template &lt;class T&gt; class vec2 {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        T x, y;

        <I><FONT COLOR="#B22222">//Constructors.
</FONT></I>        vec2();
        vec2(T a, T b);
        vec2( <B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp; );

        <I><FONT COLOR="#B22222">//Operators - vec2 typed.
</FONT></I>        vec2 &amp; operator=(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;);

        vec2   operator+(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        vec2 &amp; operator+=(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;);
        vec2   operator-(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        vec2 &amp; operator-=(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;);

        bool operator==(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool operator!=(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool operator&lt;(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;   <I><FONT COLOR="#B22222">//This is mostly for sorting / placing into a std::map. There is no great 
</FONT></I>                                              <I><FONT COLOR="#B22222">// way to define '&lt;' for a vector, so be careful with it.
</FONT></I>
        <I><FONT COLOR="#B22222">//Operators - T typed.
</FONT></I>        <I><FONT COLOR="#B22222">//vec2   operator*(const T);
</FONT></I>        <I><FONT COLOR="#B22222">//vec2 &amp; operator*=(const T);
</FONT></I>        <I><FONT COLOR="#B22222">//vec2   operator/(const T);
</FONT></I>        <I><FONT COLOR="#B22222">//vec2 &amp; operator/=(const T);
</FONT></I>
        vec2   operator*(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        vec2 &amp; operator*=(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;);
        vec2   operator/(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        vec2 &amp; operator/=(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;);

        <I><FONT COLOR="#B22222">//Member functions.
</FONT></I>        T Dot(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;        <I><FONT COLOR="#B22222">// ---&gt; Dot product.
</FONT></I>        vec2 Mask(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;    <I><FONT COLOR="#B22222">// ---&gt; Term-by-term product:   (a b).Outer(5 0) = (5*a 0*b)
</FONT></I>
        vec2 unit() <B><FONT COLOR="#228B22">const</FONT></B>;                <I><FONT COLOR="#B22222">// ---&gt; Return a normalized version of this vector.
</FONT></I>        T length() <B><FONT COLOR="#228B22">const</FONT></B>;                 <I><FONT COLOR="#B22222">// ---&gt; (pythagorean) length of vector.
</FONT></I>        T distance(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;   <I><FONT COLOR="#B22222">// ---&gt; (pythagorean) distance between vectors.
</FONT></I>        T sq_dist(<B><FONT COLOR="#228B22">const</FONT></B> vec2 &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;    <I><FONT COLOR="#B22222">// ---&gt; Square of the (pythagorean) distance. Avoids a sqrt().
</FONT></I>
        <I><FONT COLOR="#B22222">//Friends.
</FONT></I><I><FONT COLOR="#B22222">//        template&lt;class Y&gt; friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp;, const vec2&lt;Y&gt; &amp;); // ---&gt; Overloaded stream operator.
</FONT></I><I><FONT COLOR="#B22222">//        template&lt;class Y&gt; friend std::istream &amp; operator &gt;&gt; (std::istream &amp;, vec2&lt;T&gt; &amp;);
</FONT></I>        template&lt;class Y&gt; friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp;, <B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;Y&gt; &amp;); <I><FONT COLOR="#B22222">// ---&gt; Overloaded stream operators.
</FONT></I>        template&lt;class Y&gt; friend std::istream &amp; operator &gt;&gt; (std::istream &amp;, vec2&lt;Y&gt; &amp;);           
};


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------- line: (infinitely-long) lines in 3D space ---------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I>template &lt;class T&gt;   class line {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        vec3&lt;T&gt; R_0;  <I><FONT COLOR="#B22222">//A point which the line intersects.
</FONT></I>        vec3&lt;T&gt; U_0;  <I><FONT COLOR="#B22222">//A unit vector which points along the length of the line.
</FONT></I>
        <I><FONT COLOR="#B22222">//Constructors.
</FONT></I>        line();
        line(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R_A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R_B);

        <I><FONT COLOR="#B22222">//Member functions.
</FONT></I>        T Distance_To_Point( <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool Intersects_With_Line_Once( <B><FONT COLOR="#228B22">const</FONT></B> line&lt;T&gt; &amp;, vec3&lt;T&gt; &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool Closest_Point_To_Line( <B><FONT COLOR="#228B22">const</FONT></B> line&lt;T&gt; &amp;, vec3&lt;T&gt; &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
};


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------ line_segment: (finite-length) lines in 3D space --------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">// The difference between a line segment and a line is that the line segment can only be interpolated between two points,
</FONT></I><I><FONT COLOR="#B22222">// whereas a line will extend off to infinity.
</FONT></I>template &lt;class T&gt;   class line_segment : public line&lt;T&gt; {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        T t_0;  <I><FONT COLOR="#B22222">//These define the endpoints of the line segment in terms of the parameterization R(t) = R_0 + t*U_0.
</FONT></I>        T t_1;  <I><FONT COLOR="#B22222">// Whenever endpoints are required, they are explicitly computed. (We can usually get around this, though!)
</FONT></I>
        <I><FONT COLOR="#B22222">//Constructors.
</FONT></I>        line_segment();
        line_segment(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R_A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R_B);  <I><FONT COLOR="#B22222">//Line segment starts at A (at t=t_0), terminates at B (at t=t_1.)
</FONT></I>
        <I><FONT COLOR="#B22222">//Member functions.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;vec3&lt;T&gt;&gt; Sample_With_Spacing(T spacing, T offset, T &amp; remaining) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Samples every &lt;spacing&gt;, beginning at offset. 
</FONT></I>                                                                                          <I><FONT COLOR="#B22222">// Returns sampled points and remaining space along segment.
</FONT></I>
        vec3&lt;T&gt; Get_R0(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
        vec3&lt;T&gt; Get_R1(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
};

<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------- plane: 2D planes in 3D space -----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//A 3D plane can be described completely with the relation:  $\vec{N}_{0} \cdot ( \vec{R} - \vec{R}_{0} ) = 0$ (where $\vec{R}$ 
</FONT></I><I><FONT COLOR="#B22222">// is a point on the plane if it satisfies this identity.)
</FONT></I>
template &lt;class T&gt;   class plane {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        vec3&lt;T&gt; N_0;  <I><FONT COLOR="#B22222">//A unit vector normal to the plane. The orientation is up to the user to choose (and be consistent with!)
</FONT></I>        vec3&lt;T&gt; R_0;  <I><FONT COLOR="#B22222">//A 3D point the plane intersects.
</FONT></I>
        <I><FONT COLOR="#B22222">//Constructors.
</FONT></I>        plane();
        plane(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;N_0_in, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R_0_in);

        <I><FONT COLOR="#B22222">//Member functions.
</FONT></I>        T Get_Signed_Distance_To_Point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool Is_Point_Above_Plane(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R) <B><FONT COLOR="#228B22">const</FONT></B>;      <I><FONT COLOR="#B22222">//Essentially returns the sign. True if pointing in direction of plane's 
</FONT></I>                                                                <I><FONT COLOR="#B22222">// positive normal, false if in opposite direction. Do not rely on any sign
</FONT></I>                                                                <I><FONT COLOR="#B22222">// in case the point is in the plane (but a consistent sign IS given in this case.)
</FONT></I>        bool Intersects_With_Line_Once(<B><FONT COLOR="#228B22">const</FONT></B> line&lt;T&gt; &amp;L, vec3&lt;T&gt; &amp;out) <B><FONT COLOR="#228B22">const</FONT></B>;
};



<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------ contour_of_points: a polygon of line segments in the form of a collection of points --------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Simple structure representing a polygon of line segments in the form of a collection of points in 3D space (using vec3&lt;...&gt;'s.) 
</FONT></I><I><FONT COLOR="#B22222">// Alternatively, they can be thought of as the perimeter of a (2D) structure.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//The points may or may not form a closed surface (ie. the first and last points are connected.) They must be marked as being either.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This class holds a *single* contour, represented as a list of points in R^3.
</FONT></I>template &lt;class T&gt;   class contour_of_points {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;vec3&lt;T&gt;&gt; points; <I><FONT COLOR="#B22222">//We use doubly-linked lists because the points can then be re-ordered, inserted or removed, or shuffled around with small cost.
</FONT></I>                                   <I><FONT COLOR="#B22222">// Additionally, we typically do not random access the points, but instead iterate over them (drawing them, computing areas, etc..
</FONT></I>  
        bool closed;               <I><FONT COLOR="#B22222">//Are the first and last points connected via a line? For instance, we cannot compute the area of the line segment if they are not.
</FONT></I>
        <I><FONT COLOR="#B22222">//Constructors.
</FONT></I>        contour_of_points();
        contour_of_points(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;vec3&lt;T&gt;&gt; &amp;points);

        <I><FONT COLOR="#B22222">//Member functions.
</FONT></I><I><FONT COLOR="#B22222">//        void append(const vec3&lt;T&gt; &amp;point);
</FONT></I>        T Get_Signed_Area(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool Is_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
        <B><FONT COLOR="#228B22">void</FONT></B> Reorient_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>);

        vec3&lt;T&gt; Average_Point(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;   <I><FONT COLOR="#B22222">//This is the average of all the 3D points of the contour. It has little value except simplicity.
</FONT></I>        vec3&lt;T&gt; Centroid(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;        <I><FONT COLOR="#B22222">//This is the centroid of the contour. This is a more mathematically well-define concept. See the source.
</FONT></I>        vec3&lt;T&gt; First_N_Point_Avg(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Useful when dealing with planes for determining if above or below.
</FONT></I>        T Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;             <I><FONT COLOR="#B22222">//This is the perimeter (length) of the contour edges. It is computed from vertex to vertex (positive-definite.)
</FONT></I>
        contour_of_points  Bounding_Box_Along(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;, T margin = (T)(0.0)) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Gives a (planar 2D) bounding box with two edges aligned with the given unit vector. 
</FONT></I>
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_of_points&lt;T&gt;&gt; Split_Along_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;T&gt; &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Splits the contour into individual contours along the given plane. This is a &quot;geometric&quot; splitting.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_of_points&lt;T&gt;&gt; Split_Against_Ray(<B><FONT COLOR="#228B22">const</FONT></B>  vec3&lt;T&gt; &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Splits the contour into individual contours along the halfway point of a given ray unit vector. This is a &quot;ray casting&quot; splitting.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_of_points&lt;T&gt;&gt; Split_Into_Core_Peel_Spherical(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;, T frac_dist) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Splits contour into an inner (core) and outer (peel).
</FONT></I>
        T Integrate_Simple_Scalar_Kernel(std::function&lt;    T    (<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;r, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;B, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;U)&gt; k) <B><FONT COLOR="#228B22">const</FONT></B>;
        T Integrate_Simple_Vector_Kernel(std::function&lt; vec3&lt;T&gt; (<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;r, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;B, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;U)&gt; k) <B><FONT COLOR="#228B22">const</FONT></B>;

        contour_of_points Resample_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Walks along the perimeter, creating a new point (using interpolation) every [perimeter]/N .
</FONT></I>                                                                                   <I><FONT COLOR="#B22222">// Points will only be homogeneously distributed if the shape is circular (or by fluke.)
</FONT></I>        contour_of_points Scale_Dist_From_Point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;, T scale) <B><FONT COLOR="#228B22">const</FONT></B>;   <I><FONT COLOR="#B22222">//Scales distance from each point to given point by factor (scale).
</FONT></I>
        contour_of_points Resample_LTE_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Performs Resample_Evenly_Along_Perimeter only on contours with more than N.
</FONT></I>

        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> Avoids_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;T&gt; &amp;P) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//-1 if contour is below P, 0 if it intersects/crosses it, 1 if it is above.
</FONT></I>
        <I><FONT COLOR="#B22222">//These routines remove points unless/until there are &lt;= 3 of them!
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Remove_Sequential_Duplicate_Points(std::function&lt;bool(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;)&gt; Feq);
        <B><FONT COLOR="#228B22">void</FONT></B> Remove_Extraneous_Points(std::function&lt;bool(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;)&gt; Feq); <I><FONT COLOR="#B22222">//Removes unnecessary points unnecessary to exactly retain contour.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Remove_Needles(std::function&lt;bool(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;)&gt; Feq); <I><FONT COLOR="#B22222">//Turns ...-A-B-A-C-D-...  into ...-A-C-D-...
</FONT></I>
        contour_of_points &amp; operator= (<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points &amp;);
        bool operator==(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Attempts to compare global contour, without disregarding location of first point within the contour.
</FONT></I>        bool operator!=(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool operator&lt; (<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//This is mostly for sorting / placing into a std::map. There is no great 
</FONT></I>                                                          <I><FONT COLOR="#B22222">// way to define '&lt;' for a contour, so be careful with it. This is designed to be fast, not reliable!
</FONT></I>
        <B><FONT COLOR="#228B22">void</FONT></B> Plot(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;                            <I><FONT COLOR="#B22222">//Spits out a default R^2 plot of the data. Ignores the z-component entirely!
</FONT></I>
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string write_to_string(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool load_from_string(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);     <I><FONT COLOR="#B22222">//Returns true if it worked/was loaded into the contour, false otherwise.
</FONT></I>};


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------- contour_collection: a collection of logically-related contour_of_points  ---------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class is a sort of utility class for holding logically-grouped contours. For instance, a 3D shape may be represented
</FONT></I><I><FONT COLOR="#B22222">// as a stack of contour_of_points. Note, however, that the onus is on the user to ensure the collection is sorted/handled
</FONT></I><I><FONT COLOR="#B22222">// in a consistent way.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Essentially, this class is a wrapper around a std::list&lt;contour_of_points&gt; with some extra things like 3D plotting
</FONT></I><I><FONT COLOR="#B22222">// and some multi-contour operations (like average centroid, stringification, etc..)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This class assumes that ALL contours it knows about are logically linked as a single unit in R^3. For example, the
</FONT></I><I><FONT COLOR="#B22222">// vertex operations in this class will typically operate on ALL vertices in ALL contours as if they were part of a single
</FONT></I><I><FONT COLOR="#B22222">// (but separated) structure. See the methods for more info on how multi-contour operations are handled.
</FONT></I>template &lt;class T&gt;   class contour_collection {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_of_points&lt;T&gt;&gt; contours; 

        <I><FONT COLOR="#B22222">//Constructors.
</FONT></I>        contour_collection();
        contour_collection(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;T&gt; &amp;);
        contour_collection(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;contour_of_points&lt;T&gt;&gt; &amp;);

        <I><FONT COLOR="#B22222">//Member functions.
</FONT></I>        T Get_Signed_Area(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool Is_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
        <B><FONT COLOR="#228B22">void</FONT></B> Reorient_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>);

        vec3&lt;T&gt; Average_Point(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;   <I><FONT COLOR="#B22222">//This is the average of all the 3D points of all contours. It has little value except simplicity.
</FONT></I>        vec3&lt;T&gt; Centroid(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;        <I><FONT COLOR="#B22222">//This is the centroid of all contours. This is a more mathematically well-defined concept, but still 
</FONT></I>                                             <I><FONT COLOR="#B22222">// somewhat unreliable for stacked, planar contours. Uses SIGNED area, so mind your orientations.
</FONT></I>        vec3&lt;T&gt; Generic_Avg_Boundary_Point(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> M) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Useful when dealing with planes for determining if above or below.
</FONT></I>        T Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;             <I><FONT COLOR="#B22222">//This is the total perimeter (length) of all contour edges. It is computed from vertex to vertex (positive-definite.)
</FONT></I>        T Average_Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;     <I><FONT COLOR="#B22222">//This is the total perimeter (length) of all contour edges / number of contours.
</FONT></I>        T Longest_Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;     <I><FONT COLOR="#B22222">//This is the perimeter of the largest contour. It is a positive-definite quantity.
</FONT></I>
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_collection&lt;T&gt;&gt; Split_Along_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;T&gt; &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Splits the contours along the given plane. This is a &quot;geometric&quot; splitting.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_collection&lt;T&gt;&gt; Split_Against_Ray(<B><FONT COLOR="#228B22">const</FONT></B>  vec3&lt;T&gt; &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Splits the contours along the halfway point of a given ray unit vector. This is a &quot;ray casting&quot; splitting.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_collection&lt;T&gt;&gt; Split_Into_Core_Peel_Spherical(T frac_dist) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Splits contour into an inner (core) and outer (peel) using the cc centroid.
</FONT></I>
        contour_collection &amp; operator= (<B><FONT COLOR="#228B22">const</FONT></B> contour_collection &amp;);
        bool operator==(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Relies on the contour_of_points operator==. See caveats there.
</FONT></I>        bool operator!=(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; 
        bool operator&lt; (<B><FONT COLOR="#228B22">const</FONT></B> contour_collection &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Relies on the contour_of_points operator&lt; . See caveats there. Only used when sorting.
</FONT></I>
        contour_collection Resample_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>;     <I><FONT COLOR="#B22222">//Per-contour resampling. See contour_of_points implementation.
</FONT></I>        contour_collection Resample_LTE_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Per-contour resampling. See contour_of_points implementation.
</FONT></I>
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> Avoids_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;T&gt; &amp;P) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//-1 if contour is below P, 0 if it intersects/crosses it, 1 if it is above.
</FONT></I>
        <B><FONT COLOR="#228B22">void</FONT></B> Merge_Adjoining_Contours(std::function&lt;bool(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;)&gt; Feq);

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;vec3&lt;T&gt;&gt; Generate_Basic_Surface(T min_dist) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Tries to find a rudimentary surface from the contour data. If points are sep. by &gt; min_dist, they are considered not coupled.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;vec3&lt;T&gt;&gt; Generate_Reconstructed_Surface(T qual) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Parameter adjusts how many vertices will be produced. 0 is none, 1 is ~# of contour points, &gt;1 is supersampling.
</FONT></I>
        <B><FONT COLOR="#228B22">void</FONT></B> Plot(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title) <B><FONT COLOR="#228B22">const</FONT></B>;         <I><FONT COLOR="#B22222">//Spits out a default R^3 plot of the data.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Plot(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string write_to_string(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool load_from_string(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);      <I><FONT COLOR="#B22222">//Returns true if it worked/was loaded into the contour, false otherwise.
</FONT></I>};



<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------- samples_1D: a convenient way to collect a sequentially-sampled array of data ------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class is mostly useful as a sort of linear array which can easily handle unevenly-spaced data. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Always ensure the samples are ORDERED in the sequential direction of your choice. No sorting will occur within
</FONT></I><I><FONT COLOR="#B22222">// because it is not clear which orientation is required. Some routines require a specific order, so you should be aware
</FONT></I><I><FONT COLOR="#B22222">// which!
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The samples should be single-valued, meaning the algorithms herein (generally) assume that there are NOT two distinct
</FONT></I><I><FONT COLOR="#B22222">// samples (ie. varying y-values) at the same point (ie. with same x-values.) To handle this, a sort of per-sample averaging
</FONT></I><I><FONT COLOR="#B22222">// scheme should be performed by the user. If you decide to do this, be weary of the weird statistics you may find...
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>template &lt;class T&gt; class samples_1D {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;vec2&lt;T&gt;&gt; samples;  <I><FONT COLOR="#B22222">//The samples are set up like [x,y] == [location of sample, value of sample] == [x_i, f(x_i)].
</FONT></I>
        <I><FONT COLOR="#B22222">//Constructors.
</FONT></I>        samples_1D();
        samples_1D(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;vec2&lt;T&gt;&gt; &amp;samps);
        samples_1D(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;in);

        <I><FONT COLOR="#B22222">//Member functions.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> push_back(T, T);    <I><FONT COLOR="#B22222">// == this-&gt;samples.push_back(vec2&lt;T&gt;(x,y))
</FONT></I>        bool empty(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;  <I><FONT COLOR="#B22222">// == this-&gt;samples.empty()
</FONT></I>        size_t size(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">// == this-&gt;samples.size()
</FONT></I>
        samples_1D&lt;T&gt; Select_Those_Within_Inc(T L, T H) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Select those within [L,H] (inclusive).
</FONT></I>
        T Interpolate_Linearly(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;x) <B><FONT COLOR="#228B22">const</FONT></B>;

        <B><FONT COLOR="#228B22">void</FONT></B> Order_Data_Lowest_First(<B><FONT COLOR="#228B22">void</FONT></B>); <I><FONT COLOR="#B22222">//These functions sort (both x and y) into sequential order, sorting on x-axis.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Order_Data_Lowest_Last(<B><FONT COLOR="#228B22">void</FONT></B>);

        template &lt;class Function&gt; T Integrate_Generic(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;in, Function F) <B><FONT COLOR="#228B22">const</FONT></B>;
        T Integrate_Overlap(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Computes the overlap integral: \int_{-inf}^{inf}f(x)g(x)dx.
</FONT></I>
        samples_1D&lt;T&gt; Resample_Average_Into_N_Equal_Sized_Bins(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, bool explicitbins = false) <B><FONT COLOR="#228B22">const</FONT></B>;

        samples_1D&lt;T&gt; Rank_x(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Replaces x- (y-)values with (casted-integer) rank. N-plicates get
</FONT></I>        samples_1D&lt;T&gt; Rank_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">// an averaged (maybe non-integer) rank.
</FONT></I>
        samples_1D&lt;T&gt; Swap_x_and_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;

        T Average_x(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//aka the mean.
</FONT></I>        T Average_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//aka the mean.
</FONT></I>
        <I><FONT COLOR="#B22222">//Statistical quantities. These may fail (which is legitimate behaviour in most cases).
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::tuple&lt;T,T,T,T&gt; Spearmans_Rank_Correlation_Coefficient(bool *OK=nullptr) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//rho, num of samples, z-value, t-value.
</FONT></I>
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::tuple&lt;T,T,T&gt; Compute_Sxy_Sxx_Syy(bool *OK=nullptr) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Computes Sxy, Sxx, Syy which are used for linear regression.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::tuple&lt;T,T&gt; Linear_Least_Squares_Regression(bool *OK=nullptr) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//slope (A), intercept (B):  y = x*A + B.
</FONT></I>
        <I><FONT COLOR="#B22222">//~Vector math operations.
</FONT></I>        samples_1D&lt;T&gt; operator=(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;rhs);
        samples_1D&lt;T&gt; Sum_With(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//i.e. &quot;operator +=&quot;.
</FONT></I>        samples_1D&lt;T&gt; Subtract(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//i.e. &quot;operator -=&quot;.
</FONT></I>

        <B><FONT COLOR="#228B22">void</FONT></B> Normalize_wrt_Self_Overlap(<B><FONT COLOR="#228B22">void</FONT></B>); <I><FONT COLOR="#B22222">//Normalizes data so that \int_{-inf}^{inf} f(x) (times) f(x) dx ~= 1.
</FONT></I>
        bool Write_To_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Writes data to file as 2 columns. Use it to plot/fit.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string Write_To_String(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Writes data to file as 2 columns. Use it to plot/fit.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Plot(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;Title = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Spits out a default plot of the data. 
</FONT></I>
        <I><FONT COLOR="#B22222">//Friends.
</FONT></I><I><FONT COLOR="#B22222">//        template&lt;class Y&gt; friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp;, const samples_1D&lt;Y&gt; &amp;); // ---&gt; Overloaded stream operators.
</FONT></I><I><FONT COLOR="#B22222">//        template&lt;class Y&gt; friend std::istream &amp; operator &gt;&gt; (std::istream &amp;, samples_1D&lt;T&gt; &amp;);
</FONT></I>        template&lt;class Y&gt; friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp;, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;Y&gt; &amp;); <I><FONT COLOR="#B22222">// ---&gt; Overloaded stream operators.
</FONT></I>        template&lt;class Y&gt; friend std::istream &amp; operator &gt;&gt; (std::istream &amp;, samples_1D&lt;Y&gt; &amp;);           
};

template &lt;class T&gt; samples_1D&lt;T&gt; Bag_of_numbers_to_N_equal_bin_samples_1D_histogram(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;T&gt; &amp;nums, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, bool explicitbins = false);



<I><FONT COLOR="#B22222">/*
    COMING SOON: A bounding box which inherits from the contour_of_points class.
    //
    (Then we can move is_point_in_poly to the contour_of_points class and get it for free for bounding boxes!)

*/</FONT></I>

#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file10">
<H1>YgorMath_Samples.h 10/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file9">prev</A>][<A HREF="#file11">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorMath_Samples.h - A few sample things which can be used for testing.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_MATH_SAMPLES_H_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_MATH_SAMPLES_H_</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMath.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------- contour_of_points ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I>contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points_sample_blob(<B><FONT COLOR="#228B22">void</FONT></B>);
contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points_sample_gumby(<B><FONT COLOR="#228B22">void</FONT></B>);
contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points_sample_airplane(<B><FONT COLOR="#228B22">void</FONT></B>);

<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------- contour_collection ---------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I>contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_collection_sample_ICCR2013(<B><FONT COLOR="#228B22">void</FONT></B>);

<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------------ samples_1D -------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I>samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D_sample_CMB(<B><FONT COLOR="#228B22">void</FONT></B>);
samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D_sample_CMB_first_half(<B><FONT COLOR="#228B22">void</FONT></B>);

samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D_sample_LIDAR(<B><FONT COLOR="#228B22">void</FONT></B>);

samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D_sample_Calories(<B><FONT COLOR="#228B22">void</FONT></B>);

#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file11">
<H1>YgorMisc.h 11/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file10">prev</A>][<A HREF="#file12">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorMisc.h
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_MISC_HDR_GRD_H</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_MISC_HDR_GRD_H</FONT>


#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ctime&gt;</FONT></B>    //Needed for gen_time_random().
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;climits&gt;</FONT></B>  //Needed for CHAR_BIT.

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;set&gt;</FONT></B>

<I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------- Error/Warning/Verbosity macros -----------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//------- Executable name variants.
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_BASIC_ERRFUNC_</FONT>
    #define YGOR_BASIC_ERRFUNC_
    #define ERR( x )  { std::cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;--(E) &quot;</FONT></B> &lt;&lt; argv[0] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;. Terminating program.&quot;</FONT></B> &lt;&lt; std::endl; \
                        <B><FONT COLOR="#5F9EA0">std</FONT></B>::cerr.flush();  \
                        <B><FONT COLOR="#5F9EA0">std</FONT></B>::exit(-1); }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_BASIC_WARNFUNC_</FONT>
    #define YGOR_BASIC_WARNFUNC_
    #define WARN( x )  { std::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;--(W) &quot;</FONT></B> &lt;&lt; argv[0] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;.&quot;</FONT></B> &lt;&lt; std::endl; \
                         <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout.flush();  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_BASIC_INFOFUNC_</FONT>
    #define YGOR_BASIC_INFOFUNC_
    #define INFO( x )  { std::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;--(I) &quot;</FONT></B> &lt;&lt; argv[0] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;.&quot;</FONT></B> &lt;&lt; std::endl; \
                         <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout.flush();  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//------- Function name variants.
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">__GNUC__</FONT> //<FONT COLOR="#B8860B">If</FONT> <FONT COLOR="#B8860B">using</FONT> <FONT COLOR="#B8860B">gcc</FONT>..
    #ifndef __PRETTY_FUNCTION__
        #define __PRETTY_FUNCTION__ __func__
    #endif
#<B><FONT COLOR="#5F9EA0">endif</FONT></B> //<FONT COLOR="#B8860B">__GNUC__</FONT>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">__PRETTY_FUNCTION__</FONT>   //(<FONT COLOR="#B8860B">this</FONT> <FONT COLOR="#B8860B">is</FONT> <FONT COLOR="#B8860B">a</FONT> <FONT COLOR="#B8860B">fallback</FONT>!)
    #define __PRETTY_FUNCTION__ '(function name not available)'
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">FUNCYGOR_BASIC_ERRFUNC_</FONT>
    #define FUNCYGOR_BASIC_ERRFUNC_
    #define FUNCERR( x )  {std::cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;--(E) In function: &quot;</FONT></B> &lt;&lt; __PRETTY_FUNCTION__; \
                           <B><FONT COLOR="#5F9EA0">std</FONT></B>::cerr &lt;&lt;  <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;. Terminating program.&quot;</FONT></B> &lt;&lt; std::endl; \
                           <B><FONT COLOR="#5F9EA0">std</FONT></B>::cerr.flush();  \
                           <B><FONT COLOR="#5F9EA0">std</FONT></B>::exit(-1); }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">FUNCYGOR_BASIC_WARNFUNC_</FONT>
    #define FUNCYGOR_BASIC_WARNFUNC_
    #define FUNCWARN( x )  {std::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;--(W) In function: &quot;</FONT></B> &lt;&lt; __PRETTY_FUNCTION__; \
                            <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt;  <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;.&quot;</FONT></B> &lt;&lt; std::endl; \
                            <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout.flush();  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">FUNCYGOR_BASIC_INFOFUNC_</FONT>
    #define FUNCYGOR_BASIC_INFOFUNC_
    #define FUNCINFO( x )  {std::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;--(I) In function: &quot;</FONT></B> &lt;&lt; __PRETTY_FUNCTION__; \
                            <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt;  <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;.&quot;</FONT></B> &lt;&lt; std::endl; \
                            <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout.flush();  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------- Convenience (math) macros --------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">YGORABS</FONT></B>(X)    ((X) &lt; 0 ? -(X) : (X))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">YGORMAX</FONT></B>(A, B) ((A) &gt; (B) ? (A) : (B))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">YGORMIN</FONT></B>(A, B) ((A) &lt; (B) ? (A) : (B))


#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">isininc</FONT>
    <I><FONT COLOR="#B22222">//Inclusive_in_range()      isininc( 0, 10, 100) == true
</FONT></I>    <I><FONT COLOR="#B22222">//                          isininc( 0, 100, 10) == false
</FONT></I>    <I><FONT COLOR="#B22222">//                          isininc( 0, 10, 10)  == true
</FONT></I>    <I><FONT COLOR="#B22222">//                          isininc( 10, 10, 10) == true
</FONT></I>    #define isininc( A, x, B ) (((x) &gt;= (A)) &amp;&amp; ((x) &lt;= (B)))
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//For computing percent error. This should not be used for determining equality of floating
</FONT></I><I><FONT COLOR="#B22222">// point values. See RELATIVE_DIFF for this purpose.
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">PERCENT_ERR</FONT>
    #define PERCENT_ERR( A, B ) (100.0 * ((B) - (A)) / (B))
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//For computing the relative difference (i.e. the equality to a given threshold). This routine
</FONT></I><I><FONT COLOR="#B22222">// should be used like:  if(RELATIVE_DIFF(1.23456, 1.23654) &lt; 1E-3){ //then equivalent within 1E-3.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// NOTE: Does this handle both positive and negative floating point zeros? I doubt it...
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">RELATIVE_DIFF</FONT>
    #define RELATIVE_DIFF( A, B ) \
        (YGORMAX(YGORABS(A), YGORABS(B)) == 0.0 ? 0.0 : \
             YGORABS((A)-(B)) / YGORMAX(YGORABS(A), YGORABS(B)))
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------- Convenience (Bitwise) macros -------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">/*
// NOTE: These do not currently work consistently across architectures.
//
template &lt;class T, class R&gt;
inline T BITWISE_ROT_L(const T N, const R S){
    return (((S &amp; sizeof(N)*CHAR_BIT) - 1) == 0) ? N : ((N &lt;&lt; ((S &amp; sizeof(N)*CHAR_BIT) - 1)) | (N &gt;&gt; (sizeof(N)*CHAR_BIT - ((S &amp; sizeof(N)*CHAR_BIT) - 1))));
}
template &lt;class T, class R&gt;
inline T BITWISE_ROT_R(const T N, const R S){
    return (((S &amp; sizeof(N)*CHAR_BIT) - 1) == 0) ? N : ((N &gt;&gt; ((S &amp; sizeof(N)*CHAR_BIT) - 1)) | (N &lt;&lt; (sizeof(N)*CHAR_BIT - ((S &amp; sizeof(N)*CHAR_BIT) - 1))));
}
*/</FONT></I>

template &lt;class T, class R&gt;  inline T PER_BYTE_BITWISE_ROT_L(<B><FONT COLOR="#228B22">const</FONT></B> T N, <B><FONT COLOR="#228B22">const</FONT></B> R S);
template &lt;class T, class R&gt;  inline T PER_BYTE_BITWISE_ROT_R(<B><FONT COLOR="#228B22">const</FONT></B> T N, <B><FONT COLOR="#228B22">const</FONT></B> R S);

template &lt;class T, class R&gt;
inline T <B><FONT COLOR="#0000FF">PER_BYTE_BITWISE_ROT_L</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> T N, <B><FONT COLOR="#228B22">const</FONT></B> R S){
    <I><FONT COLOR="#B22222">//This routine will not handle 'negative'-leftward rotations. Pass them to sister function.
</FONT></I><I><FONT COLOR="#B22222">//    if(static_cast&lt;long int&gt;(S) &lt; 0L) return PER_BYTE_BITWISE_ROT_R(N,-S);
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(S &lt; static_cast&lt;R&gt;(0)) <B><FONT COLOR="#A020F0">return</FONT></B> PER_BYTE_BITWISE_ROT_R(N,-S);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> SS(static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(S % 8));

    <B><FONT COLOR="#228B22">union</FONT></B> a_byte_array {
        T num; <I><FONT COLOR="#B22222">//The number (N).
</FONT></I>        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> dat[<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)]; <I><FONT COLOR="#B22222">//Access to the individual bytes.
</FONT></I>    } C;
    C.num = N;

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)); ++i){
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> out(C.dat[i]);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;SS; ++j){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> initially(out);
            out = static_cast&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;(out &lt;&lt; 1);
            <B><FONT COLOR="#A020F0">if</FONT></B>((out &gt;&gt; 1) != initially) out |= 1; <I><FONT COLOR="#B22222">//Insert a low-bit.
</FONT></I>        }
        C.dat[i] = out;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> C.num;
}
template &lt;class T, class R&gt;
inline T <B><FONT COLOR="#0000FF">PER_BYTE_BITWISE_ROT_R</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> T N, <B><FONT COLOR="#228B22">const</FONT></B> R S){
    <I><FONT COLOR="#B22222">//This routine will not handle 'negative'-rightward rotations. Pass them to sister function.
</FONT></I><I><FONT COLOR="#B22222">//    if(static_cast&lt;long int&gt;(S) &lt; 0L) return PER_BYTE_BITWISE_ROT_L(N,-S);
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(S &lt; static_cast&lt;R&gt;(0)) <B><FONT COLOR="#A020F0">return</FONT></B> PER_BYTE_BITWISE_ROT_L(N,-S);

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> SS(static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(S % 8));

    <B><FONT COLOR="#228B22">union</FONT></B> a_byte_array {
        T num; <I><FONT COLOR="#B22222">//The number (N).
</FONT></I>        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> dat[<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)]; <I><FONT COLOR="#B22222">//Access to the individual bytes.
</FONT></I>    } C;
    C.num = N;

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)); ++i){
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> out(C.dat[i]);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;SS; ++j){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> initially(out);
            out = static_cast&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;(out &gt;&gt; 1);
            <B><FONT COLOR="#A020F0">if</FONT></B>((out &lt;&lt; 1) != initially) out |= (1 &lt;&lt; 7); <I><FONT COLOR="#B22222">//128; //Insert a high-bit.
</FONT></I>        }
        C.dat[i] = out;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> C.num;
}


<I><FONT COLOR="#B22222">//Checks if a variable, bitwise AND'ed with a bitmask, equals the bitmask. Ensure the ordering is observed
</FONT></I><I><FONT COLOR="#B22222">// because the operation is non-commutative.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// For example: let A = 0110011
</FONT></I><I><FONT COLOR="#B22222">//        and BITMASK = 0010010
</FONT></I><I><FONT COLOR="#B22222">//   then A &amp; BITMASK = 0010010 == BITMASK.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// For example: let A = 0100011
</FONT></I><I><FONT COLOR="#B22222">//        and BITMASK = 0010010
</FONT></I><I><FONT COLOR="#B22222">//   then A &amp; BITMASK = 0000010 != BITMASK.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// NOTE: This operation is mostly useful for checking for embedded 'flags' within a variable. These flags 
</FONT></I><I><FONT COLOR="#B22222">// are set by bitwise ORing them into the variable.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">BITMASK_BITS_ARE_SET</FONT>
    #define BITMASK_BITS_ARE_SET( A, BITMASK ) \
        ( (A &amp; BITMASK) == BITMASK )
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>



<I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------- Function Declarations -----------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//Generate a random [0-9a-zA-Z] string of length len. Useful for finding an unused filename.
</FONT></I><I><FONT COLOR="#B22222">//void gen_random(std::string *s, const int len);   //NOTE: An alternative, better implementation is in YgorString.h/cc. Use it if possible!
</FONT></I>
<I><FONT COLOR="#B22222">//Seeds the (old-style) random number generator with the current time.
</FONT></I><I><FONT COLOR="#B22222">//void seed_time(void);
</FONT></I>
<I><FONT COLOR="#B22222">//Prints out a set. This should be turned into an iostream form, but it was only needed briefly.
</FONT></I><I><FONT COLOR="#B22222">//void Dump_Set_to_Screen(const std::set&lt;std::string&gt;::iterator &amp;begin, const std::set&lt;std::string&gt;::iterator &amp;end);
</FONT></I>
<I><FONT COLOR="#B22222">//Execute a given command in a read-only pipe (using popen/pclose.) Return the output.
</FONT></I><I><FONT COLOR="#B22222">// Do not use if you do not care about / do not expect output. An empty string should be 
</FONT></I><I><FONT COLOR="#B22222">// able to be interpretted as a failure.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Execute_Command_In_Pipe(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;cmd);

#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file12">
<H1>YgorNetworking.h 12/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file11">prev</A>][<A HREF="#file13">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorNetworking.h - A few constructs which are useful for basic networking. These are basically
</FONT></I><I><FONT COLOR="#B22222">// simple wrappers for BSD-style sockets.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">HDR_GRD_YGORNETWORKING_H_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">HDR_GRD_YGORNETWORKING_H_</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;functional&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;thread&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;mutex&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;set&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;unistd.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;errno.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/types.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/socket.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;netinet/in.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;netdb.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;arpa/inet.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/wait.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;signal.h&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorContainers.h&quot;</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">USE_OWN_GETIFADDR</FONT>
    <I><FONT COLOR="#B22222">//Adapted from http://www.openwall.com/lists/musl/2012/09/19/8.
</FONT></I>    <B><FONT COLOR="#228B22">struct</FONT></B> ifaddrs {
        <B><FONT COLOR="#228B22">struct</FONT></B> ifaddrs    *ifa_next;
        <B><FONT COLOR="#228B22">char</FONT></B>        *ifa_name;
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>     ifa_flags;
        <B><FONT COLOR="#228B22">struct</FONT></B> sockaddr    *ifa_addr;
        <B><FONT COLOR="#228B22">struct</FONT></B> sockaddr    *ifa_netmask;
        <B><FONT COLOR="#228B22">union</FONT></B> {
            <B><FONT COLOR="#228B22">struct</FONT></B> sockaddr *ifu_broadaddr;
            <B><FONT COLOR="#228B22">struct</FONT></B> sockaddr *ifu_dstaddr;
        } ifa_ifu;
        #define    ifa_broadaddr ifa_ifu.ifu_broadaddr
        #define    ifa_dstaddr   ifa_ifu.ifu_dstaddr
        <B><FONT COLOR="#228B22">void</FONT></B>        *ifa_data;
    };
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">static</FONT></B> bool <B><FONT COLOR="#0000FF">YGORNETWORKING_VERBOSE</FONT></B>(false);

<I><FONT COLOR="#B22222">//Some basic string functions to construct canned requests, responses, etc..
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Basic_HTTP_Request_Header(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;hostandport);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Basic_HTTP_Request_Header(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;hostandport, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;request);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Basic_HTTP_Response_Text_Header(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;thetext);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Basic_HTTP_Response_File_Header(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename);   <I><FONT COLOR="#B22222">//Loads file into response.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Basic_HTTP_Response_File_Header_Only(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Range_HTTP_Response_File_Header_Only(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename, off_t range_l, off_t range_u);

<I><FONT COLOR="#B22222">//Some simple, non-nonsense, low-customizability routines for sending HTTP requests.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Simple_HTTP_Request(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;host, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;request);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Simple_HTTPS_Request(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;host, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;port = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;request = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);   <I><FONT COLOR="#B22222">//Currently implemented using pipe/wget! FIXME
</FONT></I>

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------- IP Address utilities ---------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//These routines are fairly hacky. They attempt to determine ip addresses using whatever method
</FONT></I><I><FONT COLOR="#B22222">// possible. Output format is &lt;device name&gt; &lt;address&gt;
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//The 'local' routines check the local machine for the dhcp/static address.
</FONT></I><I><FONT COLOR="#B22222">//The 'distant' routines hackishly request the ip from a remote server.
</FONT></I><I><FONT COLOR="#B22222">//In between, any NAT which occurs is essentially invisible.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Future plans are to investigate the various hole-punching schemes and (newer) NAT traversal
</FONT></I><I><FONT COLOR="#B22222">// protocols.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Get_All_Local_IP4_Addresses(<B><FONT COLOR="#228B22">void</FONT></B>);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Get_All_Local_IP6_Addresses(<B><FONT COLOR="#228B22">void</FONT></B>);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Get_All_Local_IP_Addresses(<B><FONT COLOR="#228B22">void</FONT></B>);

<I><FONT COLOR="#B22222">//These 'distant' functions may or may not have an associated name. Do not rely on it...
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Get_All_Distant_IP_Addresses(<B><FONT COLOR="#228B22">void</FONT></B>);



<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------- clone(2) Shuttle Struct --------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This struct is a simple wrapper for converting Server_and_Client class members into an object
</FONT></I><I><FONT COLOR="#B22222">// which can be cast to (void *). 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//It is used to pass in member variables (and functions...) to the clone(2) function, which 
</FONT></I><I><FONT COLOR="#B22222">// requires a (void *)-able function argument.
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> YgorNetworking_Server_and_Client_Clone_Shuttle {
    <B><FONT COLOR="#228B22">int</FONT></B> SERVER_sockfd; 
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; USERS_SERVER_DIALOG_LAMBDA;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; DEFAULT_SERVER_DIALOG_LAMBDA;
    <B><FONT COLOR="#228B22">int</FONT></B> SERVER_new_fd;
    <B><FONT COLOR="#228B22">char</FONT></B> SERVER_s[INET6_ADDRSTRLEN];
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> SERVER_PORT; 
    <B><FONT COLOR="#228B22">void</FONT></B> *Stack; 
};


<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------- Server_and_Client: a TCP networking class -----------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class can operate as both a client and a server. This is useful in cases where an entity
</FONT></I><I><FONT COLOR="#B22222">// is required to pass network requests around. This class should be sufficient for the purposes
</FONT></I><I><FONT COLOR="#B22222">// of handling the networking aspects of a simple network 'node' or entity.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//This interface is a WIP. If something needs tweaking by the user (timeouts, forking model, 
</FONT></I><I><FONT COLOR="#B22222">// etc..) then provide a public member function to call between ..Init() and ..Connect() or
</FONT></I><I><FONT COLOR="#B22222">// ..Wait() members. Try to avoid renaming or destroying members if possible.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>class Server_and_Client {
    <B><FONT COLOR="#5F9EA0">private</FONT></B>:
        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Experimental things.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::mutex Blocklist_Mutex;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;std::string&gt; Blocklist;
<I><FONT COLOR="#B22222">//        #if defined YGORNETWORKING_USE_THREAD_POOL
</FONT></I>            taskpool threadpool;
<I><FONT COLOR="#B22222">//        #endif
</FONT></I>
        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Server-specific things.
</FONT></I>        bool SERVER_INITIALIZED;              <I><FONT COLOR="#B22222">//Denotes whether or not the server has been Init()'d.
</FONT></I>        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> SERVER_PORT;                 <I><FONT COLOR="#B22222">//Which port to listen on.
</FONT></I>        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> SERVER_BACKLOG;              <I><FONT COLOR="#B22222">//The number of pending connections in the queue.
</FONT></I>
        <I><FONT COLOR="#B22222">//This is a user-provided dialog function. It handles how the server sends and receives.
</FONT></I>        <I><FONT COLOR="#B22222">// The argument is a file descriptor, which is needed to send or receive.
</FONT></I>        <I><FONT COLOR="#B22222">// The second is the host (destination) address.
</FONT></I>        <I><FONT COLOR="#B22222">// The third is the host (destination) port.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; USERS_SERVER_DIALOG_LAMBDA;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; DEFAULT_SERVER_DIALOG_LAMBDA;
   
        <I><FONT COLOR="#B22222">//------ The following server-specific things are probably not of interest to the outside.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> SERVER_sockfd, SERVER_new_fd;     <I><FONT COLOR="#B22222">//We listen on sock_fd and get new connections on new_fd.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> SERVER_yes, SERVER_rv;            <I><FONT COLOR="#B22222">//&quot;yes&quot; is a simple int(1). &quot;rv&quot; is a multiple-use return val.
</FONT></I>        size_t SERVER_accept_timeout_sec;     <I><FONT COLOR="#B22222">//These control how long the server will wait for a connection.
</FONT></I>        size_t SERVER_accept_timeout_usec;    <I><FONT COLOR="#B22222">// If time runs out, the server will probably exit()!
</FONT></I>        size_t SERVER_recv_timeout_sec;       <I><FONT COLOR="#B22222">//These control how long the server will wait on a message
</FONT></I>        size_t SERVER_recv_timeout_usec;      <I><FONT COLOR="#B22222">// (send() and recv()) before failing. This could be useful
</FONT></I>        size_t SERVER_send_timeout_sec;       <I><FONT COLOR="#B22222">//  for catching disconnected clients/servers but should
</FONT></I>        size_t SERVER_send_timeout_usec;      <I><FONT COLOR="#B22222">//  not be set too short (to better handle flaky networks.)
</FONT></I>        <B><FONT COLOR="#228B22">char</FONT></B> SERVER_s[INET6_ADDRSTRLEN+1];    <I><FONT COLOR="#B22222">//Stores the incoming (client) address (after connecting).
</FONT></I>        <B><FONT COLOR="#228B22">struct</FONT></B> addrinfo SERVER_hints, *SERVER_servinfo, *SERVER_p;
        <B><FONT COLOR="#228B22">struct</FONT></B> sockaddr_storage SERVER_their_addr;   <I><FONT COLOR="#B22222">//Connector's connection's metadata. See also SERVER_s.
</FONT></I>        socklen_t SERVER_sin_size;
        <B><FONT COLOR="#228B22">struct</FONT></B> sigaction SERVER_sa;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::thread Connection_Thread;  <I><FONT COLOR="#B22222">//Gets launched/detached whenever a connection is established.
</FONT></I>
        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Client-specific things.
</FONT></I>        bool CLIENT_INITIALIZED;              <I><FONT COLOR="#B22222">//Denotes whether or not the server has been Init()'d.
</FONT></I>        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> CLIENT_PORT;                 <I><FONT COLOR="#B22222">//Which port to connect to.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string CLIENT_ADDRESS;           <I><FONT COLOR="#B22222">//The address the client should attempt to contact.
</FONT></I>
        <I><FONT COLOR="#B22222">//This is a user-provided dialog function. It handles how the client sends and receives.
</FONT></I>        <I><FONT COLOR="#B22222">// The argument is a file descriptor, which is needed to send or receive.
</FONT></I>        <I><FONT COLOR="#B22222">// The second is the host (destination) address.
</FONT></I>        <I><FONT COLOR="#B22222">// The third is the host (destination) port.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; USERS_CLIENT_DIALOG_LAMBDA; 
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; DEFAULT_CLIENT_DIALOG_LAMBDA;

        <I><FONT COLOR="#B22222">//------ The following client-specific things are probably not of interest to the outside.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B>  CLIENT_sockfd, CLIENT_rv;
        size_t CLIENT_recv_timeout_sec;
        size_t CLIENT_recv_timeout_usec;
        size_t CLIENT_send_timeout_sec;
        size_t CLIENT_send_timeout_usec;
        <B><FONT COLOR="#228B22">char</FONT></B> CLIENT_s[INET6_ADDRSTRLEN+1];
        <B><FONT COLOR="#228B22">struct</FONT></B> addrinfo CLIENT_hints, *CLIENT_servinfo, *CLIENT_p;

        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//General helper member functions.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> *Get_in_addr(<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr *);

    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <I><FONT COLOR="#B22222">//Constructors, Destructor.
</FONT></I>        Server_and_Client(<B><FONT COLOR="#228B22">void</FONT></B>);

        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Server-specific member functions.
</FONT></I>        bool Server_Init(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port, std::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; server_dialog);
        bool Server_Init(std::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; server_dialog);
        bool Server_Init(<B><FONT COLOR="#228B22">void</FONT></B>);

        bool Server_Wait_for_Connection(<B><FONT COLOR="#228B22">void</FONT></B>);

        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Client-specific member functions.
</FONT></I>        bool Client_Init(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port, std::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; client_dialog);
        bool Client_Init(std::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; client_dialog);
        bool Client_Init(<B><FONT COLOR="#228B22">void</FONT></B>);

        bool Client_Connect(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;address);

        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//General member functions.
</FONT></I>        bool Set_No_Timeouts(<B><FONT COLOR="#228B22">void</FONT></B>);

        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Experimental things: Server ONLY.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Add_To_Blocklist(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;host);
        <B><FONT COLOR="#228B22">void</FONT></B> Remove_From_Blocklist(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;host);
        bool Is_In_Blocklist(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;host);

};


<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------- Beacon_and_Radio: a UDP multicasting class -----------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class can operate as both a sender and a receiver. It is designed to announce messages
</FONT></I><I><FONT COLOR="#B22222">// across networks, and is generally not designed to *respond* to received messages. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//This interface is a WIP. If something needs tweaking by the user (timeouts, forking model, 
</FONT></I><I><FONT COLOR="#B22222">// etc..) then provide a public member function to call between ..Init() and ..Connect() or
</FONT></I><I><FONT COLOR="#B22222">// ..Wait() members. Try to avoid renaming or destroying members if possible.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>class Beacon_and_Radio {
    <B><FONT COLOR="#5F9EA0">private</FONT></B>:
        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Radio-specific things.
</FONT></I>        bool RADIO_INITIALIZED;              <I><FONT COLOR="#B22222">//Denotes whether or not the radio has been Init()'d.
</FONT></I>        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> RADIO_PORT;                 <I><FONT COLOR="#B22222">//Which port to listen on.
</FONT></I><I><FONT COLOR="#B22222">//        long int RADIO_BACKLOG;              //The number of pending connections in the queue.
</FONT></I>        bool RADIO_LOOP;                     <I><FONT COLOR="#B22222">//Instead of closing socket, loop forever.
</FONT></I>
        <I><FONT COLOR="#B22222">//This is a user-provided dialog function. It handles how the radio sends messages.
</FONT></I>        <I><FONT COLOR="#B22222">// The first argument is a file descriptor, which is needed to send.
</FONT></I>        <I><FONT COLOR="#B22222">// The second is the host (destination) address. *In this case: the multicast address.*
</FONT></I>        <I><FONT COLOR="#B22222">// The third is the host (destination) port.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; USERS_RADIO_DIALOG_LAMBDA;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; DEFAULT_RADIO_DIALOG_LAMBDA;
   
        <I><FONT COLOR="#B22222">//------ The following radio-specific things are probably not of interest to the outside.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> RADIO_sockfd;                    <I><FONT COLOR="#B22222">//We listen on sock_fd. UDP is connectionless, so no beacon fd.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> RADIO_yes, RADIO_rv;             <I><FONT COLOR="#B22222">//&quot;yes&quot; is a simple int(1). &quot;rv&quot; is a multiple-use return val.
</FONT></I>        size_t RADIO_recv_timeout_sec;       <I><FONT COLOR="#B22222">//These control how long the beacon will wait in recv().
</FONT></I>        size_t RADIO_recv_timeout_usec;      <I><FONT COLOR="#B22222">// They are typically very long.
</FONT></I>        <B><FONT COLOR="#228B22">char</FONT></B> RADIO_s[INET6_ADDRSTRLEN+1];    <I><FONT COLOR="#B22222">//Stores the radio's address we end up using.
</FONT></I>        <B><FONT COLOR="#228B22">struct</FONT></B> addrinfo RADIO_hints, *RADIO_servinfo, *RADIO_p;
<I><FONT COLOR="#B22222">//        socklen_t RADIO_sin_size;
</FONT></I>        <B><FONT COLOR="#228B22">struct</FONT></B> sigaction RADIO_sa;

        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Beacon-specific things.
</FONT></I>        bool BEACON_INITIALIZED;              <I><FONT COLOR="#B22222">//Denotes whether or not the radio has been Init()'d.
</FONT></I>        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> BEACON_PORT;                 <I><FONT COLOR="#B22222">//Which port to connect to.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string BEACON_ADDRESS;           <I><FONT COLOR="#B22222">//The multicast address the beacon should tune in to.
</FONT></I>        bool BEACON_LOOP;                     <I><FONT COLOR="#B22222">//Instead of closing socket, loop forever. User should sleep().
</FONT></I>        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> BEACON_TTL_HOPS;        <I><FONT COLOR="#B22222">//The number of hops before message expires. Chosing 1 
</FONT></I>                                              <I><FONT COLOR="#B22222">// will ensure the multicast does not leave a LAN. Max is 255.
</FONT></I>
        <I><FONT COLOR="#B22222">//This is a user-provided dialog function. It handles how the beacon receives.
</FONT></I>        <I><FONT COLOR="#B22222">// The first argument is a file descriptor, which is needed to receive.
</FONT></I>        <I><FONT COLOR="#B22222">// The second is the host (destination) address. *In this case: the multicast address.*
</FONT></I>        <I><FONT COLOR="#B22222">// The third is the host (destination) port.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; USERS_BEACON_DIALOG_LAMBDA; 
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; DEFAULT_BEACON_DIALOG_LAMBDA;

        <I><FONT COLOR="#B22222">//------ The following beacon-specific things are probably not of interest to the outside.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B>  BEACON_sockfd, BEACON_rv;
        size_t BEACON_send_timeout_sec;       <I><FONT COLOR="#B22222">//These control how long the beacon will wait in send().
</FONT></I>        size_t BEACON_send_timeout_usec;      <I><FONT COLOR="#B22222">// It should be very short because UDP is connectionless.
</FONT></I>        <B><FONT COLOR="#228B22">char</FONT></B> BEACON_s[INET6_ADDRSTRLEN+1];    <I><FONT COLOR="#B22222">//Holds the intended multicast address. 
</FONT></I>        <B><FONT COLOR="#228B22">struct</FONT></B> addrinfo BEACON_hints, *BEACON_servinfo, *BEACON_p;

        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//General helper member functions.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> *Get_in_addr(<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr *);

    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <I><FONT COLOR="#B22222">//Constructors, Destructor.
</FONT></I>        Beacon_and_Radio(<B><FONT COLOR="#228B22">void</FONT></B>);

        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Radio-specific member functions.
</FONT></I>        bool Radio_Init(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port, std::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; radio_dialog);
        bool Radio_Init(std::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; radio_dialog);
        bool Radio_Init(<B><FONT COLOR="#228B22">void</FONT></B>);

        bool Radio_Tune_In(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;address); <I><FONT COLOR="#B22222">//Valid multicast IP's: [224.0.0.0, 239.255.255.255].
</FONT></I>
        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Beacon-specific member functions.
</FONT></I>        bool Beacon_Init(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port, std::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; beacon_dialog);
        bool Beacon_Init(std::function&lt;bool (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; beacon_dialog);
        bool Beacon_Init(<B><FONT COLOR="#228B22">void</FONT></B>);

        bool Beacon_Transmit(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;address); <I><FONT COLOR="#B22222">//Valid multicast IP's: [224.0.0.0, 239.255.255.255].
</FONT></I>
        <I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//General member functions.
</FONT></I>        bool Set_No_Timeouts(<B><FONT COLOR="#228B22">void</FONT></B>);
        bool Set_No_Loop_Radio(<B><FONT COLOR="#228B22">void</FONT></B>);
        bool Set_No_Loop_Beacon(<B><FONT COLOR="#228B22">void</FONT></B>);

        bool Set_TTL_Hops_Beacon(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>); <I><FONT COLOR="#B22222">//See source for reasonable values. Usually ~ &lt;32.
</FONT></I>};

#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file13">
<H1>YgorNoise.h 13/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file12">prev</A>][<A HREF="#file14">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorNoise.h
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_NOISE_HDR_GRD_H</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_NOISE_HDR_GRD_H</FONT>

<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------- Simple Perlin Noise. -----------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">float</FONT></B> <B><FONT COLOR="#0000FF">Perlin_Noise_3D</FONT></B>(<B><FONT COLOR="#228B22">float</FONT></B> vec[3]);


<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------ Generic, Integer, Non-Smooth Noise --------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//These are not (intentionally?) coherent noise generators, but they are consistent. They could be used to
</FONT></I><I><FONT COLOR="#B22222">// identify agents to one another, given a random input. They are obviously not *good* for this purpose, 
</FONT></I><I><FONT COLOR="#B22222">// but are better than a static keyword-based authentication.
</FONT></I>uint64_t <B><FONT COLOR="#0000FF">Number_Jumbler_A</FONT></B>(uint64_t x);



#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file14">
<H1>YgorPerformance.h 14/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file13">prev</A>][<A HREF="#file15">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorPerformance.h
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_PERFORMANCE_HDR_GRD_H</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_PERFORMANCE_HDR_GRD_H</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ctime&gt;</FONT></B>

<I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------- Timing Routines ------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">YgorPerformance_Get_Time</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>);
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">YgorPerformance_dt_from_last</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>);

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGORPERF_TIMESTAMP_DT_IS_DEFINED</FONT>
    #define YGORPERF_TIMESTAMP_DT_IS_DEFINED
    #define YGORPERF_TIMESTAMP_DT       {std::cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;--(T) File: &quot;</FONT></B> &lt;&lt; __FILE__; \
                                        <B><FONT COLOR="#5F9EA0">std</FONT></B>::cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, Line: &quot;</FONT></B> &lt;&lt; __LINE__; \
                                        <B><FONT COLOR="#5F9EA0">std</FONT></B>::cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; \
                                        YgorPerformance_dt_from_last(); \
                                        <B><FONT COLOR="#5F9EA0">std</FONT></B>::cerr.flush(); }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

</PRE>
<HR>
<A NAME="file15">
<H1>YgorPlot.h 15/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file14">prev</A>][<A HREF="#file16">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorPlot.h - Simple plotting routines which wrap around Gnuplot, (GNU)plotutils, a postscript plotting library, or good-ol'-fashioned 
</FONT></I><I><FONT COLOR="#B22222">// roll-your-own plotting routines.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//The idea behind this file is to easily have some plotting facilities within a program without having to deal directly with pipes and
</FONT></I><I><FONT COLOR="#B22222">// plotting formats in situ. 
</FONT></I>


#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGORPLOT_H__AN_OBSCURE_STRING_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGORPLOT_H__AN_OBSCURE_STRING_</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>  //Used for popen.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>  //Used for FILE.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;map&gt;</FONT></B>     //Required for plotting maps of samples_1D's.

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>  //Used for the macros FUNCINFO, FUNCWARN, FUNCERR.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMath.h&quot;</FONT></B>  //Needed for helper plotting routines.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorFilesDirs.h&quot;</FONT></B> //Needed for filename checking.


<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------- Plotter - A Plotutils-based class ---------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class is a minimal class for plotting. To inject data, you input it directly into a stream.
</FONT></I><I><FONT COLOR="#B22222">// Plotutils is nice - in theory, but the support for many things is poor. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//This class should be used for plotting 2D contours on a 2D plane. It works very well for this.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTES:
</FONT></I><I><FONT COLOR="#B22222">//  FILE *graph_pipe = popen(&quot;~/plotutils-2.4.1/graph/graph -a -C -W .004 -g 3 -L Title -X Abscissa -Y Ordinate -T X -&quot;, &quot;w&quot;);
</FONT></I><I><FONT COLOR="#B22222">//  const std::string PLOTTING_INITIATOR = &quot;graph -T X -C -m 1 -q 0.3 &quot;;
</FONT></I><I><FONT COLOR="#B22222">//  const std::string PLOTTING_INITIATOR = &quot;graph -T X --bitmap-size \&quot;1000x1000\&quot; -h 0.8 -w 0.8 -l 0.1 -r 0.1 -C -q 0.3  2&gt;/dev/null &quot;;
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> std::string PLOTTING_INITIATOR_SCREEN = <B><FONT COLOR="#BC8F8F">&quot;graph -T X  --bitmap-size \&quot;1000x1000\&quot; -C &quot;</FONT></B>;
<B><FONT COLOR="#228B22">const</FONT></B> std::string PLOTTING_INITIATOR_FILE   = <B><FONT COLOR="#BC8F8F">&quot;graph -T ps --bitmap-size \&quot;1000x1000\&quot; -C &quot;</FONT></B>;
<B><FONT COLOR="#228B22">const</FONT></B> std::string PLOTTING_INITIATOR_FILL   = <B><FONT COLOR="#BC8F8F">&quot; -q 0.3 &quot;</FONT></B>;     <I><FONT COLOR="#B22222">//This option will fill the area under curves. It is ON by default.
</FONT></I>
<B><FONT COLOR="#228B22">const</FONT></B> std::string PLOTTING_INITIATOR_BLACK_HOLE = <B><FONT COLOR="#BC8F8F">&quot; 2&gt;/dev/null &quot;</FONT></B>;

class Plotter {
    <B><FONT COLOR="#5F9EA0">private</FONT></B>:
        <I><FONT COLOR="#B22222">//These are plotutils-specific counters used by this class for various reasons.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> linestyle_m; <I><FONT COLOR="#B22222">//Handles the linestyles so that they can be iterated over by calling a member function.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> linestyle_s;

    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        FILE *fp;
        <B><FONT COLOR="#228B22">int</FONT></B> status;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;       <I><FONT COLOR="#B22222">//Provides a stream-like method of plotting. Passes data onto plotting_data string prior to plotting.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string plotting_data; 

        <I><FONT COLOR="#B22222">//Constructor, Destructor.
</FONT></I>        <I><FONT COLOR="#B22222">//Add more constructors as needed. Do not break this simple plotutils-based constructor, though.
</FONT></I>        Plotter() : ss(std::stringstream::in | std::stringstream::out ) {  
            fp = popen( (PLOTTING_INITIATOR_SCREEN + PLOTTING_INITIATOR_FILL + PLOTTING_INITIATOR_BLACK_HOLE).c_str(), <B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B> );
            linestyle_m = 1;
            linestyle_s = 1;

            <B><FONT COLOR="#A020F0">if</FONT></B>(fp == NULL) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to open a pipe!&quot;</FONT></B>);
        }

        Plotter(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename) : ss(std::stringstream::in | std::stringstream::out ) {
            <B><FONT COLOR="#A020F0">if</FONT></B>( Does_File_Exist_And_Can_Be_Read(filename) ){
                <B><FONT COLOR="#228B22">const</FONT></B> std::string safer = Get_Unique_Sequential_Filename( filename );
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempting to overwrite an existing plot \&quot;&quot;</FONT></B> &lt;&lt; filename &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\&quot;. Proceeding with output filename \&quot;&quot;</FONT></B> &lt;&lt; safer &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B>);
                fp = popen( (PLOTTING_INITIATOR_FILE + PLOTTING_INITIATOR_FILL + <B><FONT COLOR="#BC8F8F">&quot; &gt; &quot;</FONT></B> + safer    + PLOTTING_INITIATOR_BLACK_HOLE).c_str(), <B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B> );
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                fp = popen( (PLOTTING_INITIATOR_FILE + PLOTTING_INITIATOR_FILL + <B><FONT COLOR="#BC8F8F">&quot; &gt; &quot;</FONT></B> + filename + PLOTTING_INITIATOR_BLACK_HOLE).c_str(), <B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B> );
            }
            linestyle_m = 1;
            linestyle_s = 1;

            <B><FONT COLOR="#A020F0">if</FONT></B>(fp == NULL) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to open a pipe!&quot;</FONT></B>);
        }

        ~Plotter() {
            <B><FONT COLOR="#A020F0">if</FONT></B>(fp == NULL){
                status = pclose(fp);
                <B><FONT COLOR="#A020F0">if</FONT></B>(status == -1){
                    FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to close pipe. Is the process still active? \&quot;pclose\&quot; reports error &quot;</FONT></B> &lt;&lt; status);
                }
                <I><FONT COLOR="#B22222">//else{
</FONT></I>                <I><FONT COLOR="#B22222">//    //Use macros described under wait() to inspect `status' in order
</FONT></I>                <I><FONT COLOR="#B22222">//    // to determine success/failure of command executed by popen()
</FONT></I>                <I><FONT COLOR="#B22222">// }
</FONT></I>            }
        };

        <I><FONT COLOR="#B22222">//Methods.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Iterate_Linestyle(<B><FONT COLOR="#228B22">void</FONT></B>);
        <I><FONT COLOR="#B22222">//void Title_Current_Line(const std::string &amp;in);   //plotutils, currently, cannot even create a legend - it is on the 'low priority' TO-DO list &lt;eyeroll&gt;...
</FONT></I>        bool Plot(<B><FONT COLOR="#228B22">void</FONT></B>);

        <I><FONT COLOR="#B22222">//bool Clear(void);
</FONT></I>
        <I><FONT COLOR="#B22222">// Getters, Setter, etc.. ?
</FONT></I>
};

<I><FONT COLOR="#B22222">//------------------------------------------------------------ Plotter-helpers -----------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//Containers of Contours of points.
</FONT></I>template &lt;class T&gt; <B><FONT COLOR="#228B22">void</FONT></B> Plot_Container_of_Contour_of_Points( T begin, T end){
    Plotter a_plot;
    a_plot.ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;# Default, simple plot for container of contours of vec3's: &quot;</FONT></B> &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = begin; it != end; ++it){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> iter = it-&gt;points.begin(); iter != it-&gt;points.end(); iter++){
            a_plot.ss &lt;&lt; iter-&gt;x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
            a_plot.ss &lt;&lt; iter-&gt;y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
            <I><FONT COLOR="#B22222">//a_plot.ss &lt;&lt; iter-&gt;z &lt;&lt; &quot; &quot;;
</FONT></I>            a_plot.ss &lt;&lt; std::endl;
        }
        a_plot.Iterate_Linestyle();
    }
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot_Container_of_Contour_of_Points</FONT></B>( std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator begin, std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator end );

template &lt;class T&gt; <B><FONT COLOR="#228B22">void</FONT></B> Plot_Container_of_Contour_of_Points_to_File( T begin, T end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in ){
    Plotter a_plot(in);
    a_plot.ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;# Default, simple plot for container of vec3's: &quot;</FONT></B> &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = begin; it != end; ++it){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> iter = it-&gt;points.begin(); iter != it-&gt;points.end(); iter++){
            a_plot.ss &lt;&lt; iter-&gt;x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
            a_plot.ss &lt;&lt; iter-&gt;y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
            <I><FONT COLOR="#B22222">//a_plot.ss &lt;&lt; iter-&gt;z &lt;&lt; &quot; &quot;;
</FONT></I>            a_plot.ss &lt;&lt; std::endl;
        }
        a_plot.Iterate_Linestyle();
    }
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot_Container_of_Contour_of_Points_to_File</FONT></B>( std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator begin, std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in );


<I><FONT COLOR="#B22222">//Containers of Containers of points.                                                                     (Where is this used? Why don't I have a template specialization?)
</FONT></I>template &lt;class T&gt; <B><FONT COLOR="#228B22">void</FONT></B> Plot_Container_of_Container_of_Points( T begin, T end){
    Plotter a_plot;
    a_plot.ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;# Default, simple plot for container of containers of vec3's: &quot;</FONT></B> &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = begin; c_it != end; ++c_it){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = c_it-&gt;begin(); it != c_it-&gt;end(); ++it){
            a_plot.ss &lt;&lt; it-&gt;x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
            a_plot.ss &lt;&lt; it-&gt;y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
            <I><FONT COLOR="#B22222">//a_plot.ss &lt;&lt; it-&gt;z &lt;&lt; &quot; &quot;;
</FONT></I>            a_plot.ss &lt;&lt; std::endl;
        }
        a_plot.Iterate_Linestyle();
    }
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<I><FONT COLOR="#B22222">//Containers of samples_1D's of points.
</FONT></I>template &lt;class T&gt; <B><FONT COLOR="#228B22">void</FONT></B> Plot_Container_of_Samples_1D( T begin, T end){
    Plotter a_plot;
    a_plot.ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;# Default, simple plot for container of 1D sequential samples: &quot;</FONT></B> &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = begin; it != end; ++it){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = it-&gt;samples.begin(); s_it != it-&gt;samples.end(); ++s_it){
            a_plot.ss &lt;&lt; s_it-&gt;x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
            a_plot.ss &lt;&lt; s_it-&gt;y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
            a_plot.ss &lt;&lt; std::endl;
        }
        a_plot.Iterate_Linestyle();
    }
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot_Container_of_Samples_1D</FONT></B>(std::list&lt;samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;&gt;::const_iterator begin, std::list&lt;samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;&gt;::const_iterator end);
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot_Container_of_Samples_1D</FONT></B>(std::list&lt;samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator begin, std::list&lt;samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator end);

<I><FONT COLOR="#B22222">//Map: std::map&lt;K,samples_1D&lt;T&gt;&gt;
</FONT></I>template &lt;class T&gt; <B><FONT COLOR="#228B22">void</FONT></B> Plot_Map_of_Samples_1D( T begin, T end){
    Plotter a_plot;
    a_plot.ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;# Default, simple plot for container of 1D sequential samples: &quot;</FONT></B> &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = begin; it != end; ++it){
        <I><FONT COLOR="#B22222">//Name is (std::string) it-&gt;first.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = it-&gt;second.samples.begin(); s_it != it-&gt;second.samples.end(); ++s_it){
            a_plot.ss &lt;&lt; s_it-&gt;x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
            a_plot.ss &lt;&lt; s_it-&gt;y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
            a_plot.ss &lt;&lt; std::endl;
        }
        a_plot.Iterate_Linestyle();
    }
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot_Map_of_Samples_1D</FONT></B>(std::map&lt;std::string,samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;&gt;::const_iterator begin, std::map&lt;std::string,samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;&gt;::const_iterator end);
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot_Map_of_Samples_1D</FONT></B>(std::map&lt;std::string,samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator begin, std::map&lt;std::string,samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator end);



<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------- Plotter2 - A GNUplot-based class ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class is a minimal class for interface for GNUplot. It tries to augment the Plotter (Plotutils) class where possible.
</FONT></I><I><FONT COLOR="#B22222">// This class is for 2D data - anything which could fit in a samples_1D. Data is not sorted, so it *can* draw contours, but
</FONT></I><I><FONT COLOR="#B22222">// they won't be filled. Titles are OK.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//This class is a 'data sponge'. It is not written to handle huge amounts of data. It is written to be easy to use. If you
</FONT></I><I><FONT COLOR="#B22222">// need to handle lots of data, write it to file first!
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Internally, data is stored in samples_1D. When needed (i.e. in Plot()) the data is assembled into GNUplot plotting 
</FONT></I><I><FONT COLOR="#B22222">// commands, a pipe is opened, and the script is piped. The data is embedded in the script. The script can be saved and
</FONT></I><I><FONT COLOR="#B22222">// called manually with a simple &quot;gnuplot&gt; load '/.../.../savedfile'&quot;. This seems like a good way to produce decent 
</FONT></I><I><FONT COLOR="#B22222">// later-editable graphs which cannot get separated from their data.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: [ echo &quot;plot \&quot;&lt; echo -e '4 5\n 3 2'\&quot; w lp pt 2&quot; | gnuplot ] == [ gnuplot&gt; plot &quot;&lt; echo -e '4 5\n 3 2'&quot; w lp pt 2 ].
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> Plotter2_Helper {
    samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; data; <I><FONT COLOR="#B22222">//The 2D data we will be plotting.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string title;       <I><FONT COLOR="#B22222">//A title identifying this particular line/data.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string type;        <I><FONT COLOR="#B22222">//Point/line type: 'lines', 'points', or 'linespoints'
</FONT></I>};
class Plotter2 {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; header, footer;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;Plotter2_Helper&gt; data;
        Plotter2_Helper working;               <I><FONT COLOR="#B22222">//Where we 'cache' data.
</FONT></I>
        <I><FONT COLOR="#B22222">//Constructor, Destructor.
</FONT></I>        Plotter2();
        ~Plotter2();

        <I><FONT COLOR="#B22222">//Internal methods. Do not use unless you know what you are doing.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Apply_Basic_Header_Customizations(<B><FONT COLOR="#228B22">void</FONT></B>);
        <B><FONT COLOR="#228B22">void</FONT></B> Apply_Basic_Footer_Customizations(<B><FONT COLOR="#228B22">void</FONT></B>);
        <B><FONT COLOR="#228B22">void</FONT></B> Append_Header(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B>;
        <B><FONT COLOR="#228B22">void</FONT></B> Append_StrDat(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B>;
        <B><FONT COLOR="#228B22">void</FONT></B> Append_Footer(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B>;

        <I><FONT COLOR="#B22222">//Methods.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Set_Global_Title(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);

        <I><FONT COLOR="#B22222">//Routines which use the working buffer and have internal state.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Set_Current_Line_Title(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
        <B><FONT COLOR="#228B22">void</FONT></B> Set_Current_Line_Type(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);   <I><FONT COLOR="#B22222">//'lines', 'points', or 'linespoints' (latter is default)
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Insert(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y);
        <B><FONT COLOR="#228B22">void</FONT></B> Next_Line(<B><FONT COLOR="#228B22">void</FONT></B>); 
    
        <I><FONT COLOR="#B22222">//Routines which have minimal internal state.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Insert_samples_1D(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;data, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;linetype = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
        <B><FONT COLOR="#228B22">void</FONT></B> Insert_map_of_string_and_samples_1D(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;std::string, samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;linetype = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
        <I><FONT COLOR="#B22222">// ... implement more YgorMath class routines here ...
</FONT></I>
        <I><FONT COLOR="#B22222">//Various plotting options.
</FONT></I>        bool Plot(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool Plot_as_PDF(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;Filename) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//May overwrite existing files!
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string Dump_as_String(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;  <I><FONT COLOR="#B22222">//aka 'plot to string'
</FONT></I>};

<I><FONT COLOR="#B22222">//This is a sort of 'tiling plotter'. It wraps individual (unconnected) plots in the most basic way.
</FONT></I><I><FONT COLOR="#B22222">// This class does not (currently) provide a working space like Plotter2 does. Add it if needed.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Due to awkward multiplot handling in GNUplot (e.g not refreshable in wxt) it is best to 
</FONT></I><I><FONT COLOR="#B22222">// plot to file and open a pdf renderer to view. File overwriting/appending is handled entirely
</FONT></I><I><FONT COLOR="#B22222">// by GNUplot, so it may be possible to choose a simple name like &quot;/tmp/Plot.pdf&quot; and simply
</FONT></I><I><FONT COLOR="#B22222">// overwrite it repeatedly..
</FONT></I>class MultiPlotter2 {
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;Plotter2&gt; subplots;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; header, footer;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string global_title;

        <I><FONT COLOR="#B22222">//Constructor, Destructor.
</FONT></I>        MultiPlotter2();
        ~MultiPlotter2();

        <I><FONT COLOR="#B22222">//Internal methods. Do not use unless you know what you are doing.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Apply_Basic_Header_Customizations(<B><FONT COLOR="#228B22">void</FONT></B>);
        <B><FONT COLOR="#228B22">void</FONT></B> Apply_Basic_Footer_Customizations(<B><FONT COLOR="#228B22">void</FONT></B>);
        <B><FONT COLOR="#228B22">void</FONT></B> Append_Header(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B>;
        <B><FONT COLOR="#228B22">void</FONT></B> Append_SubPlots(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B>;
        <B><FONT COLOR="#228B22">void</FONT></B> Append_Footer(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B>;
        <B><FONT COLOR="#228B22">void</FONT></B> Open_Multiplot_Environ(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B>;
        <B><FONT COLOR="#228B22">void</FONT></B> Close_Multiplot_Environ(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B>;


        <I><FONT COLOR="#B22222">//Methods.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Set_Global_Title(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);

        <I><FONT COLOR="#B22222">//Routines which have minimal internal state.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Insert_Plotter2(<B><FONT COLOR="#228B22">const</FONT></B> Plotter2 &amp;in);

        <I><FONT COLOR="#B22222">//Various plotting options.
</FONT></I>        bool Plot(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool Plot_as_PDF(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;Filename) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//May overwrite existing files!
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string Dump_as_String(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;  <I><FONT COLOR="#B22222">//aka 'plot to string'
</FONT></I>};

<I><FONT COLOR="#B22222">//------------------------------------------------------------- Plotter2-helpers -----------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//Map: std::map&lt;K,samples_1D&lt;T&gt;&gt;
</FONT></I>template &lt;class T&gt; <B><FONT COLOR="#228B22">void</FONT></B> Plot2_Map_of_Samples_1D( T begin, T end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title){
    Plotter2 a_plot;
    a_plot.Set_Global_Title(title);    

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = begin; it != end; ++it){
        a_plot.Set_Current_Line_Title(it-&gt;first);

        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = it-&gt;second.samples.begin(); s_it != it-&gt;second.samples.end(); ++s_it){
            a_plot.Insert(s_it-&gt;x, s_it-&gt;y);
        }
        a_plot.Next_Line();
    }
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot2_Map_of_Samples_1D</FONT></B>(std::map&lt;std::string,samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;&gt;::const_iterator begin, std::map&lt;std::string,samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;&gt;::const_iterator end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title);
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot2_Map_of_Samples_1D</FONT></B>(std::map&lt;std::string,samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator begin, std::map&lt;std::string,samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title);


<I><FONT COLOR="#B22222">//Map: std::map&lt;samples_1D&lt;T&gt;,K&gt;
</FONT></I><I><FONT COLOR="#B22222">// or  std::vector&lt;std::pair&lt;samples_1D&lt;T&gt;,K&gt;&gt;
</FONT></I>template &lt;class T&gt; <B><FONT COLOR="#228B22">void</FONT></B> Plot3_Map_of_Samples_1D( T begin, T end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title){
    Plotter2 a_plot;
    a_plot.Set_Global_Title(title);

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = begin; it != end; ++it){
        a_plot.Set_Current_Line_Title(it-&gt;second);

        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = it-&gt;first.samples.begin(); s_it != it-&gt;first.samples.end(); ++s_it){
            a_plot.Insert(s_it-&gt;x, s_it-&gt;y);
        }
        a_plot.Next_Line();
    }
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot3_Map_of_Samples_1D</FONT></B>(std::map&lt;samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;,std::string&gt;::const_iterator begin, std::map&lt;samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;,std::string&gt;::const_iterator end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title);
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot3_Map_of_Samples_1D</FONT></B>(std::map&lt;samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,std::string&gt;::const_iterator begin, std::map&lt;samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,std::string&gt;::const_iterator end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title);

template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot3_Map_of_Samples_1D</FONT></B>(std::vector&lt;std::pair&lt;samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;,std::string&gt;&gt;::const_iterator begin, std::vector&lt;std::pair&lt;samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;,std::string&gt;&gt;::const_iterator end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title);
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot3_Map_of_Samples_1D</FONT></B>(std::vector&lt;std::pair&lt;samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,std::string&gt;&gt;::const_iterator begin, std::vector&lt;std::pair&lt;samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,std::string&gt;&gt;::const_iterator end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title);




<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------- Plotter3 - A GNUplot-based class ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class is a WIP, minimal class interface for GNUplot. It tries to augment the Plotter (Plotutils) class where possible.
</FONT></I><I><FONT COLOR="#B22222">// Namely, contours are NOT filled by default, titles/legends are allowed, and a more rigid input scheme is devised to simplify development.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This is strictly a R^3 plotter. For R^2 plotting, see Plotter2.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This is setup currently to plot contours floating in space. There are no surfaces (or if they are, they are not 'volume' surfaces!)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTES:
</FONT></I><I><FONT COLOR="#B22222">//  echo &quot;plot \&quot;&lt; echo -e '4 5\n 3 2'\&quot; w lp pt 2&quot; | gnuplot
</FONT></I><I><FONT COLOR="#B22222">//  ==
</FONT></I><I><FONT COLOR="#B22222">//  gnuplot&gt; plot &quot;&lt; echo -e '4 5\n 3 2'&quot; w lp pt 2
</FONT></I>
<B><FONT COLOR="#228B22">const</FONT></B> std::string YGORPLOT3_H_PLOT_COMMAND(<B><FONT COLOR="#BC8F8F">&quot;gnuplot -persist &quot;</FONT></B>); <I><FONT COLOR="#B22222">//&amp;&gt;/dev/null&quot;);
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> std::string YGORPLOT3_H_PIPE_PREP(R<B><FONT COLOR="#BC8F8F">&quot;***(  set xlabel 'x' ; set ylabel 'y' ; set zlabel 'z' ; splot )***&quot;</FONT></B> ); <I><FONT COLOR="#B22222">// set view equal xyz ; splot )***&quot; );
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> std::string YGORPLOT3_H_PIPE_BEGIN_SENDING_DATA(R<B><FONT COLOR="#BC8F8F">&quot;***(&quot;</FONT></B>&lt; echo -e ')***<B><FONT COLOR="#BC8F8F">&quot; );                  //&quot;</FONT></B><I><FONT COLOR="#B22222">//
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> std::string YGORPLOT3_H_PIPE_FINISH_SENDING_DATA(R<B><FONT COLOR="#BC8F8F">&quot;***('&quot;</FONT></B>)***<B><FONT COLOR="#BC8F8F">&quot; );          //&quot;</FONT></B><I><FONT COLOR="#B22222">//
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> std::string YGORPLOT3_H_PIPE_NEXT_SERIES(<B><FONT COLOR="#BC8F8F">&quot; , &quot;</FONT></B>);

class Plotter3 {
    <B><FONT COLOR="#5F9EA0">private</FONT></B>:
        FILE *fp;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;

        <I><FONT COLOR="#B22222">//Global settings. These do not get flushed.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string global_title;

        <I><FONT COLOR="#B22222">//Per-series (i.e. per-line) settings. These get flushed after a call to Next_Line. Call them prior to inserting data.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string current_line_title;  <I><FONT COLOR="#B22222">// 'Ygor Data - #6'
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string current_line_use;    <I><FONT COLOR="#B22222">// 'lines', 'points', or 'linespoints'.
</FONT></I>        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> current_line_style;     <I><FONT COLOR="#B22222">// Used with Gnuplot's &quot;lt&quot; specifier.
</FONT></I> 
    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <I><FONT COLOR="#B22222">//Constructor, Destructor.
</FONT></I>        <I><FONT COLOR="#B22222">//Add more constructors as needed. Do not break this simple plotutils-based constructor, though.
</FONT></I>        Plotter3() : ss(std::stringstream::in | std::stringstream::out){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!(fp = popen(YGORPLOT3_H_PLOT_COMMAND.c_str(), <B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>))) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to open a pipe!&quot;</FONT></B>);
            current_line_use   = <B><FONT COLOR="#BC8F8F">&quot;lp&quot;</FONT></B>;
            current_line_style = 1;
            ss &lt;&lt; YGORPLOT3_H_PIPE_PREP;
            ss &lt;&lt; YGORPLOT3_H_PIPE_BEGIN_SENDING_DATA;
        }
        ~Plotter3(){
            <B><FONT COLOR="#A020F0">if</FONT></B>(fp != nullptr){
                <B><FONT COLOR="#A020F0">if</FONT></B>(pclose(fp) == -1) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to close pipe. Is the process still active?&quot;</FONT></B>);
            }
        };

        <I><FONT COLOR="#B22222">//Methods.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Set_Global_Title(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
        <B><FONT COLOR="#228B22">void</FONT></B> Set_Current_Line_Title(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
        <B><FONT COLOR="#228B22">void</FONT></B> Set_Current_Line_Use(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
        
        <B><FONT COLOR="#228B22">void</FONT></B> Insert(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;x, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;y, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;z);
        <B><FONT COLOR="#228B22">void</FONT></B> Next_Line(<B><FONT COLOR="#228B22">void</FONT></B>); 
        <B><FONT COLOR="#228B22">void</FONT></B> Next_Line_Same_Style(<B><FONT COLOR="#228B22">void</FONT></B>);
        
        bool Plot(<B><FONT COLOR="#228B22">void</FONT></B>);
};

<I><FONT COLOR="#B22222">//------------------------------------------------------------- Plotter3-helpers -----------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//List: std::list&lt;contour_of_points&lt;T&gt;&gt;
</FONT></I>template &lt;class T&gt; <B><FONT COLOR="#228B22">void</FONT></B> Plot3_List_of_contour_of_points(T begin, T end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title){
    Plotter3 a_plot;
    a_plot.Set_Global_Title(title);

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = begin; c_it != end; ++c_it){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = c_it-&gt;points.begin(); p_it != c_it-&gt;points.end(); ++p_it){
            a_plot.Insert(p_it-&gt;x, p_it-&gt;y, p_it-&gt;z);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>(c_it-&gt;closed){
            <B><FONT COLOR="#228B22">auto</FONT></B> p_it = c_it-&gt;points.begin();
            a_plot.Insert(p_it-&gt;x, p_it-&gt;y, p_it-&gt;z);
        }
        a_plot.Next_Line_Same_Style();
    }
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot3_List_of_contour_of_points</FONT></B>(std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;&gt;::const_iterator begin, std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;&gt;::const_iterator end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title);
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot3_List_of_contour_of_points</FONT></B>(std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator begin, std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title);


<I><FONT COLOR="#B22222">//Each contour_collection represents a 3D structure. We plot all 3D structures in the list. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//List: std:list&lt;contour_collection&lt;T&gt;&gt;
</FONT></I>template &lt;class T&gt; <B><FONT COLOR="#228B22">void</FONT></B> Plot3_List_of_contour_collections(T begin, T end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title){
    Plotter3 a_plot;
    a_plot.Set_Global_Title(title);

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> cc_it = begin; cc_it != end; ++cc_it){
        a_plot.Set_Current_Line_Use(<B><FONT COLOR="#BC8F8F">&quot;lines&quot;</FONT></B>); <I><FONT COLOR="#B22222">//Avoid showing points because they quickly obscure the lines.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = cc_it-&gt;contours.begin(); c_it != cc_it-&gt;contours.end(); ++c_it){
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = c_it-&gt;points.begin(); p_it != c_it-&gt;points.end(); ++p_it){
                a_plot.Insert(p_it-&gt;x, p_it-&gt;y, p_it-&gt;z);
            }
            <B><FONT COLOR="#A020F0">if</FONT></B>(c_it-&gt;closed){
                <B><FONT COLOR="#228B22">auto</FONT></B> p_it = c_it-&gt;points.begin();
                a_plot.Insert(p_it-&gt;x, p_it-&gt;y, p_it-&gt;z);
            }
            <B><FONT COLOR="#A020F0">if</FONT></B>(c_it != --(cc_it-&gt;contours.end())){
                a_plot.Next_Line_Same_Style(); <I><FONT COLOR="#B22222">//For a given 3D structure, plot all contours with same linetype.
</FONT></I>            }
        }
        a_plot.Next_Line();
    }
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot3_List_of_contour_collections</FONT></B>(std::list&lt;contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;&gt;::const_iterator begin, std::list&lt;contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;&gt;::const_iterator end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title);
template <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plot3_List_of_contour_collections</FONT></B>(std::list&lt;contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator begin, std::list&lt;contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator end, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title);




#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file16">
<H1>YgorSerialize.h 16/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file15">prev</A>][<A HREF="#file17">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorSerialize.h - Helper routines for serializing data types to and from 
</FONT></I><I><FONT COLOR="#B22222">//  string or uint8_t memory blocks.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: These routines MAY or MAY NOT insert extra data for containers and
</FONT></I><I><FONT COLOR="#B22222">// classes. Do NOT mix these routines with other techniques (eg. memcpy or 
</FONT></I><I><FONT COLOR="#B22222">// other direct read methods) unless you are certain that no hints are 
</FONT></I><I><FONT COLOR="#B22222">// being used.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: If data was encoded using a 'PUT(..)', ensure it is decoded using
</FONT></I><I><FONT COLOR="#B22222">// the accompanying 'GET(...)'. Extra information is placed between objects
</FONT></I><I><FONT COLOR="#B22222">// which make simple memcpy() unable to safely reconstruct the data!
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: These routines do not serialize enough information to *fully*
</FONT></I><I><FONT COLOR="#B22222">// construct most objects. The metadata about whether data is a list or a
</FONT></I><I><FONT COLOR="#B22222">// vector or an array are up to the user. These routines are essentially
</FONT></I><I><FONT COLOR="#B22222">// to be used as *tools* for implementing your own Serialize()/Deserialize()
</FONT></I><I><FONT COLOR="#B22222">// member functions!
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_SERIALIZE_HDR_GRD_H</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_SERIALIZE_HDR_GRD_H</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;memory&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdint&gt;</FONT></B>   //For uint8_t, uint32_t, etc..

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>


<I><FONT COLOR="#B22222">//This macro function simplifies error reporting in many use-cases of the
</FONT></I><I><FONT COLOR="#B22222">// particular style of serialization here.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// What it does: An indicator bool (l_OK) is checked. If TRUE, then a bool 
</FONT></I><I><FONT COLOR="#B22222">// pointer for propagating errors is checked for validity. If not valid,
</FONT></I><I><FONT COLOR="#B22222">// die. If valid, emit a warning and propagate the failure to the caller.
</FONT></I><I><FONT COLOR="#B22222">//   
</FONT></I><I><FONT COLOR="#B22222">//   if(l_OK){
</FONT></I><I><FONT COLOR="#B22222">//        if(OK == nullptr){
</FONT></I><I><FONT COLOR="#B22222">//            FUNCERR(failmsg &lt;&lt; &quot; Cannot continue&quot;);
</FONT></I><I><FONT COLOR="#B22222">//        }else{  
</FONT></I><I><FONT COLOR="#B22222">//            FUNCWARN(failmsg &lt;&lt; &quot; Bailing&quot;); 
</FONT></I><I><FONT COLOR="#B22222">//            return std::move(in);  
</FONT></I><I><FONT COLOR="#B22222">//        }
</FONT></I><I><FONT COLOR="#B22222">//    }
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// To use:
</FONT></I><I><FONT COLOR="#B22222">//   buf = SERIALIZE::Put(&amp;l_OK, std::move(buf),....);
</FONT></I><I><FONT COLOR="#B22222">//   SERIALIZE_FUNCWARN_OR_DIE(!l_OK,OK,&quot;Could not Put ...&quot;, std::move(buf));
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// or:
</FONT></I><I><FONT COLOR="#B22222">//  ..... Some_Function(bool *OK, std::unique_ptr in, uint64_t *avar, ...){
</FONT></I><I><FONT COLOR="#B22222">//      SERIALIZE_FUNCWARN_OR_DIE((avar == nullptr),OK,&quot;Encountered a nullptr at ...&quot;,std::move(in));
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">SERIALIZE_WARNFAIL_OR_DIE</FONT>
    #define SERIALIZE_WARNFAIL_OR_DIE(l_OK,OK,failmsg,pntr)  <B><FONT COLOR="#A020F0">if</FONT></B>((l_OK)){ \
        <B><FONT COLOR="#A020F0">if</FONT></B>((OK) == nullptr){  FUNCERR(failmsg &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; Cannot continue&quot;</FONT></B>); \
        }<B><FONT COLOR="#A020F0">else</FONT></B>{  FUNCWARN(failmsg &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; Bailing&quot;</FONT></B>); <B><FONT COLOR="#A020F0">return</FONT></B> (pntr);  } \
    }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


namespace SERIALIZE {

    <I><FONT COLOR="#B22222">//These routines are the *core* routines which the user should use. They 
</FONT></I>    <I><FONT COLOR="#B22222">// will seamlessly handle intrinsic types (integer, char, floating point) 
</FONT></I>    <I><FONT COLOR="#B22222">// and more complex types which require writing extra metainfo. Through
</FONT></I>    <I><FONT COLOR="#B22222">// template specialization, this all happens behind the scenes.
</FONT></I>    template &lt;class T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
    Put(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, T val);

    template &lt;class T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
    Get(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, T *val);

    <I><FONT COLOR="#B22222">//Used for safely storing the sizes of things, up to a maximum of the
</FONT></I>    <I><FONT COLOR="#B22222">// max uint64_t - 1. To save space, the amount of bytes used is variable.
</FONT></I>
    <B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> uint64_t max_vw_size; <I><FONT COLOR="#B22222">//Theoretical maximum variable-width size.
</FONT></I>    <B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> uint64_t max_fw_size; <I><FONT COLOR="#B22222">//Theoretical maximum fixed-width size.
</FONT></I>
    <B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> uint64_t max_string_head_size; <I><FONT COLOR="#B22222">//Theoretical maximum.
</FONT></I>
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;uint8_t[]&gt; 
    Put_Size(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, uint64_t val);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;uint8_t[]&gt;
    Put_Fixed_Width_Size(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, uint64_t val);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;uint8_t[]&gt; 
    Get_Size(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, uint64_t *val);

    <I><FONT COLOR="#B22222">//Used for verifying parts of data with a plain string.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;uint8_t[]&gt;
    Matches_At(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;seq);


    <I><FONT COLOR="#B22222">//For writing buffers ala memcpy. This is a thin wrapper around memcpy
</FONT></I>    <I><FONT COLOR="#B22222">// that acts more like the other functions.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;uint8_t[]&gt;
    Put_Raw(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, <B><FONT COLOR="#228B22">void</FONT></B> *raw, uint64_t num_bytes);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;uint8_t[]&gt;
    Get_Raw(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, <B><FONT COLOR="#228B22">void</FONT></B> *raw, uint64_t num_bytes);


    <I><FONT COLOR="#B22222">//-----------------------------------------------------------------
</FONT></I>    <I><FONT COLOR="#B22222">//Below routines may disappear. If they are needed, try adding the 
</FONT></I>    <I><FONT COLOR="#B22222">// required functionality to the 'PUT(...)' and 'GET(...)' above.
</FONT></I>    <I><FONT COLOR="#B22222">//-----------------------------------------------------------------
</FONT></I>

    <I><FONT COLOR="#B22222">//For all types of strings, including std::string (==std::basic_string&lt;char&gt;)
</FONT></I>    template &lt;class T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
    Get_String(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, std::basic_string&lt;T&gt; *val);

    template &lt;class T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
    Put_String(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, std::basic_string&lt;T&gt; val);


    <I><FONT COLOR="#B22222">//For storing std::list, std::vector, std::array, std::forward_list, std::deque, etc.. of intrinsic types.
</FONT></I>    <I><FONT COLOR="#B22222">// Anything with size(), begin(), and end() members, and with T::value_type being intrinsic is OK.
</FONT></I>    template &lt;class T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
    Get_Sequence_Container(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, T *val);

    template &lt;class T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
    Put_Sequence_Container(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, <B><FONT COLOR="#228B22">const</FONT></B> T &amp;val);


} <I><FONT COLOR="#B22222">//namespace SERIALIZE
</FONT></I>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B> //<FONT COLOR="#B8860B">YGOR_SERIALIZE_HDR_GRD_H</FONT>
</PRE>
<HR>
<A NAME="file17">
<H1>YgorStats.h 17/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file16">prev</A>][<A HREF="#file18">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorStats.h
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_STATS_H_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_STATS_H_</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>

namespace Stats {

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">P_From_StudT_1Tail</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> tval, <B><FONT COLOR="#228B22">double</FONT></B> dof);
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">P_From_StudT_2Tail</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> tval, <B><FONT COLOR="#228B22">double</FONT></B> dof);

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">P_From_StudT_Diff_Means_From_Uneq_Vars</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> M1, <B><FONT COLOR="#228B22">double</FONT></B> S1, <B><FONT COLOR="#228B22">double</FONT></B> N1, <B><FONT COLOR="#228B22">double</FONT></B> M2, <B><FONT COLOR="#228B22">double</FONT></B> S2, <B><FONT COLOR="#228B22">double</FONT></B> N2);

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Q_From_ChiSq_Fit</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> chi_square, <B><FONT COLOR="#228B22">double</FONT></B> dof);

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Unbiased_Var_Est</FONT></B>(std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; in);

} <I><FONT COLOR="#B22222">//namespace Stats.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file18">
<H1>YgorString.h 18/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file17">prev</A>][<A HREF="#file19">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorString.h - Convenient functions for dealing with text in strings.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_STRING_LIBRARY_H_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_STRING_LIBRARY_H_</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;map&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;utility&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;memory&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;set&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>  //Needed for set_intersection(..);

<I><FONT COLOR="#B22222">//#include &lt;regex&gt;                    //Fuck you, silent compiler failing.
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;boost/regex.hpp&gt;</FONT></B>


<I><FONT COLOR="#B22222">//To turn off user literals, define a macro like so (or pass in to compiler with -DYGOR_STRING_...
</FONT></I><I><FONT COLOR="#B22222">// NOTE: This is a compile-time macro (NOT a header-only thing!)
</FONT></I><I><FONT COLOR="#B22222">//#define YGOR_STRING_TURN_OFF_USER_LITERALS
</FONT></I>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_STRING_TURN_OFF_USER_LITERALS</FONT>
<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------ Handy User-Literals ----------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string operator <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> _s(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* str, size_t len);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------- String Type Conversions --------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Given a string, copy the data into a unique buffer of type T. 
</FONT></I>template &lt;class T&gt; std::unique_ptr&lt;T[]&gt; str_to_buf(bool *OK, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, uint64_t *size);


<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------ Self-contained N-gram routines -----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I>namespace NGRAMS {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> CHARS  = 0x1;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> WORDS  = 0x2;
}
<B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt; NGrams_With_Occurence(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;thestring, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> numb_of_ngrams, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> length_of_ngrams, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> &amp;type);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;std::string&gt; NGrams(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;thestring, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> numb_of_ngrams, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> length_of_ngrams, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> &amp;type);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;std::string&gt; NGram_Matches(<B><FONT COLOR="#228B22">const</FONT></B> std::set&lt;std::string&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> std::set&lt;std::string&gt; &amp;B);
<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">NGram_Match_Count</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::set&lt;std::string&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> std::set&lt;std::string&gt; &amp;B);


<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------- Substring and Subsequence routines ----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Returns the longest common sequential substring. ie. 'ABCDEF' and 'ACDEF' gives 'CDEF'.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string LongestCommonSubstring(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;B);

<I><FONT COLOR="#B22222">//Returns the longest common subsequence. ie. 'ABCDEF' and 'ACDEF' gives 'ACDEF'.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string LongestCommonSubsequence(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;B);

<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------- Common text transformations ------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I>namespace CANONICALIZE {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> TO_UPPER  =  1;  <I><FONT COLOR="#B22222">//Uppercase the characters, if possible.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> LOCALIZE  =  2;  <I><FONT COLOR="#B22222">//Transform the letters to the current locale.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> TRIM_ENDS =  4;  <I><FONT COLOR="#B22222">//Trim whitespace to the left of first, to the right of last char.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> TRIM      =  8;  <I><FONT COLOR="#B22222">//Trim the edges and shrink long whitespace to a single space.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> TRIM_ALL  = 16;  <I><FONT COLOR="#B22222">//Remove ALL whitespace.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> TO_AZ     = 32;  <I><FONT COLOR="#B22222">//Remove all non [ A-Za-z] characters.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> TO_NUM    = 64;  <I><FONT COLOR="#B22222">//Remove all non [ 0-9.-] characters.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> TO_NUMAZ  = 128; <I><FONT COLOR="#B22222">//Remove all non [ A-Za-z0-9.-] characters.
</FONT></I>}
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string &amp; Canonicalize_String(std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> &amp; );
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Canonicalize_String2(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> &amp;mask);  <I><FONT COLOR="#B22222">//&lt;--- prefer this version
</FONT></I>
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Detox_String(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in); <I><FONT COLOR="#B22222">//Attempt to ~intelligently replace non-simple chars like spaces and commas.
</FONT></I>
<I><FONT COLOR="#B22222">//Filesystem-unaware routines. Do not send escaped file/pathnames to these functions. They work on '/'s.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Get_Parent_Directory(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;path); <I><FONT COLOR="#B22222">//Removes lowest filename or dir, returns parent dir. File, '.' oblivious!
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Get_Bare_Filename(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;fullname); <I><FONT COLOR="#B22222">//Returns substr after last '/'. If no '/', returns input string.
</FONT></I>
<I><FONT COLOR="#B22222">//Compare sections of two strings for equality. After safely pulling out the sections, perform canonicalization on the
</FONT></I><I><FONT COLOR="#B22222">// segments before comparison. This is useful for ignoring case and whitespace, for example.
</FONT></I>bool <B><FONT COLOR="#0000FF">Safely_Compare_Strings</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;A, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> from_A, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> to_A, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> mask_A, 
                            <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;B, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> from_B, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> to_B, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> mask_B);


<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------ Math expression transformations ----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Remove_Unneeded_Surrounding_Parenthesis(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">char</FONT></B> L = <B><FONT COLOR="#BC8F8F">'('</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> R = <B><FONT COLOR="#BC8F8F">')'</FONT></B>);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Wrap_Comma_Separated_Stuff_At_Same_Depth(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">char</FONT></B> L = <B><FONT COLOR="#BC8F8F">'('</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> R = <B><FONT COLOR="#BC8F8F">')'</FONT></B>);
bool <B><FONT COLOR="#0000FF">Contains_Unmatched_Char_Pairs</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">char</FONT></B> L = <B><FONT COLOR="#BC8F8F">'('</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> R = <B><FONT COLOR="#BC8F8F">')'</FONT></B>);
<I><FONT COLOR="#B22222">//bool Contains_Unbalanced_Char_Pairs(...)  ---&gt; detect '([a)]' errors.  TODO
</FONT></I>
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Remove_Preceeding_Chars(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;chars);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Remove_Trailing_Chars(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;chars);

<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------- Common text conversions --------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string inttostring(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> number);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string floattostring(<B><FONT COLOR="#228B22">float</FONT></B> number);

template &lt;class T&gt;   std::string Xtostring(T numb);
template &lt;class T&gt;   std::string XtoPreciseString(T numb);
template &lt;class T&gt;   T           stringtoX(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;text);
template &lt;class T&gt;   bool        Is_String_An_X(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;text);

<I><FONT COLOR="#B22222">//This is useful for parsing a config file. Provide a key like &quot;aval = &quot; and if the line is &quot;aval = 6&quot; then you'll
</FONT></I><I><FONT COLOR="#B22222">// get a 6 back.
</FONT></I>template &lt;class T&gt;
bool <B><FONT COLOR="#0000FF">GetValueIfKeyMatches</FONT></B>(T *out, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;key , <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> key_mask, 
                                  <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;line, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> line_mask);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Convert_Unprintables_to_Hex(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Quote_Static_for_Bash(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Quote_Expandable_for_Bash(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);

<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------- Generic String-related Routines -----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Generate_Random_String_of_Length(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> len);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Lineate_Vector(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::string&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;separator);

<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------- Basic parsing routines ---------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//These were inherited from Project - Rugine for the purposes of using them in Project - DICOMAutomaton. They may need some
</FONT></I><I><FONT COLOR="#B22222">// reworking.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//    FIXME - Cleanup and move things to the appropriate location!
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: 'BEHAVIOUR' can be 'd', 'l', or 'r'. See source for info about what these do.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; &amp;BYOVectorSplit(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;s, <B><FONT COLOR="#228B22">char</FONT></B> delim, std::vector&lt;std::string&gt; &amp;elems, <B><FONT COLOR="#228B22">char</FONT></B> BEHAVIOUR); 
<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; SplitStringToVector(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;s, <B><FONT COLOR="#228B22">char</FONT></B> delim, <B><FONT COLOR="#228B22">char</FONT></B> BEHAVIOUR);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; SplitVector(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::string&gt; &amp;s, <B><FONT COLOR="#228B22">char</FONT></B> delim, <B><FONT COLOR="#228B22">char</FONT></B> BEHAVIOUR);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; SplitStringToVector(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;s, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;delim, <B><FONT COLOR="#228B22">char</FONT></B> BEHAVIOUR);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::string ReplaceAllInstances(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;regex, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;replacement);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::string PurgeCharsFromString(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, std::string purge_chars);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; GetUrls( std::vector&lt;std::string&gt; &amp;in );
<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; GetUrls( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in );

<B><FONT COLOR="#5F9EA0">std</FONT></B>::string GetFirstNumber(std::string &amp;in);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::string GetFirstRegex(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;source, boost::regex &amp;regex_the_query);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string GetFirstRegex(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;source, std::string query);
<I><FONT COLOR="#B22222">//std::string GetFirstRegex(std::string source, std::string query);
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string GetFirstRegex(std::vector&lt;std::string&gt; &amp;source, std::string query);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; GetAllRegex(std::vector&lt;std::string&gt; &amp;source, boost::regex &amp;regex_the_query);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; GetAllRegex(std::vector&lt;std::string&gt; &amp;source, std::string query);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; GetAllRegex(std::string &amp;source, std::string query);   <I><FONT COLOR="#B22222">//NOTE: DO NOT USE THIS ONE!
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; GetAllRegex2(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;source, std::string query);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::string GetLineNBelow( std::vector&lt;std::string&gt; &amp;source, std::string query, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N);

<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;std::string&gt;&gt; GetSubVectorFromTo( std::vector&lt;std::string&gt; &amp;in, std::string from, std::string to);

<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------- URL-handling routines ---------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Basic_Encode_URL(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::string Basic_Decode_URL(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;std::string&gt;&gt; Basic_Decode_Form_URL(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in); <I><FONT COLOR="#B22222">//Used to decode POST/GET HTML form data.
</FONT></I>
<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------- Text Reflow Routines ----------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Breaks a text blob on all &quot;\n\n&quot;s and removes all &quot;\n&quot;. Used internally by the other reflow functions.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; Break_Text_Into_Paragraphs(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in); 

<I><FONT COLOR="#B22222">/*
//Breaks some reflowed text into a text blob (inserting &quot;\n\n&quot; between paragraphs and &quot;\n&quot; between lines).
std::string Break_Paragraphs_Into_Text(const std::vector&lt;std::string&gt; &amp;in);
*/</FONT></I>

<I><FONT COLOR="#B22222">//Returns a broken vector which fits within the given max width.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Takes a single line. Knows nothing about paragraphs.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; Reflow_Line_to_Fit_Width_Left_Just(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> W = 80, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> indent = 0);

<I><FONT COLOR="#B22222">//Returns a broken vector of possibly multiple paragraphs which fits within the given max width and is indented.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Takes a linear collection of paragraphs. Assumes paragraphs are separated by &quot;\n\n&quot;.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; Reflow_Text_to_Fit_Width_Left_Just(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> W = 80, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> indent = 0);

<I><FONT COLOR="#B22222">//Returns a broken vector composed of (possibly multiple) paragraphs which are laid side-by-side. 
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; Reflow_Adjacent_Texts_to_Fit_Width_Left_Just(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;inL, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> WL, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> indentL, 
                                                                      <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;sep,
                                                                      <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;inR, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> WR, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> indentR);

<I><FONT COLOR="#B22222">//Centers a given line to a specified width by padding the left side with ' 's.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Reflow_Line_Align_Center(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> W = 80);

#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file19">
<H1>YgorTime.h 19/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file18">prev</A>][<A HREF="#file20">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorTime.h
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_TIME_HDR_GRD_H</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_TIME_HDR_GRD_H</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ctime&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;memory&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorSerialize.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------- time_mark class - a simple class for holding timestamps --------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class has (roughly, no less than) second-resolution timing. It uses epoch time (i.e. some arbitrary point in time) as the 
</FONT></I><I><FONT COLOR="#B22222">// reference point.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//The underlying representation may change. Do not use this for anything that has to properly account for daylight savings, or 
</FONT></I><I><FONT COLOR="#B22222">// leap seconds, or less-than-seconds inherent resolution. This class is mostly good for logging or timestamps. Do NOT depend on
</FONT></I><I><FONT COLOR="#B22222">// any particular treatment of, say, daylight savings time, etc..
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>class time_mark {
    <B><FONT COLOR="#5F9EA0">private</FONT></B>:
        <I><FONT COLOR="#B22222">//This holds the basic time info. It is sequential time since epoch (&quot;Epoch time.&quot;).
</FONT></I>        time_t When;

    <B><FONT COLOR="#5F9EA0">public</FONT></B>:
        <I><FONT COLOR="#B22222">//Constructors, destructor.
</FONT></I>        time_mark();  <I><FONT COLOR="#B22222">//Sets the time as current time. (Do not change this!)
</FONT></I>        time_mark(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;);
        ~time_mark();

        <I><FONT COLOR="#B22222">//Methods.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Set_current_time(<B><FONT COLOR="#228B22">void</FONT></B>); <I><FONT COLOR="#B22222">//Set to current time...
</FONT></I>
        time_mark &amp; operator=(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;);
        bool operator==(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Compared only to the second.
</FONT></I>        bool operator&lt;(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool operator&gt;(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
        bool operator&lt;=(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Compared only to the second.
</FONT></I>        bool operator&gt;=(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Compared only to the second.
</FONT></I>
        <I><FONT COLOR="#B22222">//Time-shift (of specified time_mark) factories.
</FONT></I>        time_mark One_Day_Earlier_Than(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;T) <B><FONT COLOR="#228B22">const</FONT></B>;
        time_mark One_Day_Later_Than(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;T) <B><FONT COLOR="#228B22">const</FONT></B>;  

        <I><FONT COLOR="#B22222">//Time-shift (of *this) factories.
</FONT></I>        time_mark Less_By_Seconds(int64_t) <B><FONT COLOR="#228B22">const</FONT></B>;
        time_mark More_By_Seconds(int64_t) <B><FONT COLOR="#228B22">const</FONT></B>;

        time_mark Same_Day_Earliest() <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Earliest time_mark occuring on the same day.
</FONT></I>        time_mark Same_Day_Latest() <B><FONT COLOR="#228B22">const</FONT></B>;   <I><FONT COLOR="#B22222">//Latest   time_mark occuring on the same day.
</FONT></I>

        <I><FONT COLOR="#B22222">//In-place time shifts.
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Regress_One_Day(); <I><FONT COLOR="#B22222">//aka &quot;rewind&quot;
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> Advance_One_Day();

        <B><FONT COLOR="#228B22">void</FONT></B> Regress_By_Seconds(int64_t);
        <B><FONT COLOR="#228B22">void</FONT></B> Advance_By_Seconds(int64_t);



        <I><FONT COLOR="#B22222">//Distance-based comparisons.
</FONT></I>        bool Is_within_X_seconds(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;T, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> X) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Can be + or - from the event. Absolute distance from event in seconds.
</FONT></I>
        <I><FONT COLOR="#B22222">//These will return:  (T_in - T_this).
</FONT></I>        time_t Diff_in_Seconds(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;T) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Can be either positive or negative. Resolution: 1sec.
</FONT></I>        time_t Diff_in_Days(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;T) <B><FONT COLOR="#228B22">const</FONT></B>; <I><FONT COLOR="#B22222">//Can be either positive or negative. Resolution: 1day.
</FONT></I>
        <I><FONT COLOR="#B22222">//Absolute comparisons.
</FONT></I>        bool Have_same_day(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;T) <B><FONT COLOR="#228B22">const</FONT></B>;  <I><FONT COLOR="#B22222">//NOTE: This is same day only (not same month, not same year!) Compares only the number.
</FONT></I>
        bool Occur_on_same_day(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;T) <B><FONT COLOR="#228B22">const</FONT></B>;  <I><FONT COLOR="#B22222">//Same day. Same month and year too.
</FONT></I>

        <I><FONT COLOR="#B22222">//Input/Output functions.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string Dump_as_string(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;       <I><FONT COLOR="#B22222">//Format: `date +%Y\/%m\/%d-%H:%M:%S`
</FONT></I>        bool Read_from_string(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in); <I><FONT COLOR="#B22222">//Format: `date +%Y\/%m\/%d-%H:%M:%S`
</FONT></I>
        <I><FONT COLOR="#B22222">//Serialize (deeply) to buffer starting at *offset. See source for more info.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;uint8_t[]&gt; Serialize(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t *tot_size) <B><FONT COLOR="#228B22">const</FONT></B>;
        <I><FONT COLOR="#B22222">//Deserialize (deeply) from buffer starting at *offset. See source for more info.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;uint8_t[]&gt; Deserialize(bool *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t tot_size);

        <I><FONT COLOR="#B22222">//Serialization helpers.
</FONT></I>        uint64_t Theo_Max_Serialization_Size(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;

};


#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

</PRE>
<HR>
<A NAME="file20">
<H1>YgorURITools.h 20/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file19">prev</A>][<A HREF="#file21">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorURITools.h.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_UTILITIES_URITOOLS_H_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGOR_UTILITIES_URITOOLS_H_</FONT>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;utility&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

<I><FONT COLOR="#B22222">//############################################################################
</FONT></I><I><FONT COLOR="#B22222">//NOTE: See the source for more detailed information regarding each function.
</FONT></I><I><FONT COLOR="#B22222">//############################################################################
</FONT></I>
<I><FONT COLOR="#B22222">//Send a GET request to a server to receive the item with the given url. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// NOTE: Not guaranteed to be native code: it will probably invoke a shell 
</FONT></I><I><FONT COLOR="#B22222">// program (wget, curl, ...).
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Request_URL(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;url);

<I><FONT COLOR="#B22222">//Pull all links from a file. Each link is accompanied with the raw text found between the tags.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Get_Links(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;source);

<I><FONT COLOR="#B22222">//Pull all given tags' attributes from an HTML string. Each link is accompanied with the raw text found within the tag.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Get_Tags_Attributes(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;source, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;tag, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;attr);

<I><FONT COLOR="#B22222">//Clean links (decode encoded-URL's, convert relative links to absolute, etc..) which have
</FONT></I><I><FONT COLOR="#B22222">// been spit out by Get_Links (or similar, simple link scraping routine.)
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Clean_Links(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::pair&lt;std::string, std::string&gt; &gt; &amp;thelinks, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;base);

<I><FONT COLOR="#B22222">//Remove duplicate links. Prefer those links with non-empty descriptions, but otherwise remove the first.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Remove_Duplicate_Links(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::pair&lt;std::string, std::string&gt;&gt; &amp;thelinks);

<I><FONT COLOR="#B22222">//Filter links based on two regex criteria (one for the links, one for the text.)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: To ignore one of the criteria, provide an empty string.
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Filter_Whitelist_Links(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::pair&lt;std::string, std::string&gt;&gt; &amp;thelinks, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;link_regex, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;text_regex);
<B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Filter_Blacklist_Links(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::pair&lt;std::string, std::string&gt;&gt; &amp;thelinks, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;link_regex, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;text_regex);

<I><FONT COLOR="#B22222">//Attempt to guess a (reasonable) mime type. 
</FONT></I><B><FONT COLOR="#5F9EA0">std</FONT></B>::string Guess_Mime_Type(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename);


#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file21">
<H1>YgorVIDEOTools.h 21/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file20">prev</A>][<A HREF="#file22">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorVIDEOTools.h - A collection of routines for working with video and video files.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">VIDEOTOOLS_HDR_GRD_H_</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">VIDEOTOOLS_HDR_GRD_H_</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;utility&gt;</FONT></B>

<B><FONT COLOR="#5F9EA0">std</FONT></B>::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; YgorVIDEOTools_Get_Video_Dimensions(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename); <I><FONT COLOR="#B22222">//W, H. Both are -1 if error is encountered.
</FONT></I>

#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
</PRE>
<HR>
<A NAME="file22">
<H1>YgorAlgorithms.cc 22/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file21">prev</A>][<A HREF="#file23">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorAlgorithms.cc.
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;functional&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;limits&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;numeric&gt;</FONT></B>   //For std::accumulate(...).
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;map&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;tuple&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;random&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iomanip&gt;</FONT></B> //For the MD5 conversion from uint128_t to std::string.

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;External/SpookyHash/SpookyV2.h&quot;</FONT></B>
<I><FONT COLOR="#B22222">//#include &quot;External/SpookyHash/SpookyV2.cpp&quot;
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;External/MD5/md5.h&quot;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorAlgorithms.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMath.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorStats.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorPlot.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorTime.h&quot;</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGORALGORITHMS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    #define YGORALGORITHMS_INCLUDE_ALL_SPECIALIZATIONS
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------- NMSimplex ----------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">// Nothing here right now - header-only.
</FONT></I>
<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------- For_Each_In_Parallel -----------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">// Nothing here right now - header-only.
</FONT></I>
<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------- Nonparametric Regression ----------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I>

namespace NPRLL { <I><FONT COLOR="#B22222">//NPRLL - Non-Parametric Regression: Local Linear Smoothing.
</FONT></I>
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> l_vector_kernel(<B><FONT COLOR="#228B22">double</FONT></B> x){
        <I><FONT COLOR="#B22222">//This can be chosen by the user. See http://en.wikipedia.org/wiki/Kernel_(statistics) for info.
</FONT></I>    
        <I><FONT COLOR="#B22222">//Tricube:
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> xabs(YGORABS(x));
        <B><FONT COLOR="#A020F0">if</FONT></B>(xabs &gt;= 1.0) <B><FONT COLOR="#A020F0">return</FONT></B> 0.0;
        <B><FONT COLOR="#A020F0">return</FONT></B> (70.0/81.0)*std::pow(1.0 - xabs*xabs*xabs, 3.0);
    
        <I><FONT COLOR="#B22222">//Gaussian:
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B> std::exp(-0.5*x*x)/std::sqrt(2.0*M_PI);
    }
    
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> l_vector_S(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;data, <B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> j_power){
        <B><FONT COLOR="#228B22">double</FONT></B> out(0.0);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = data.samples.begin(); p_it != data.samples.end(); ++p_it){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> dx((p_it-&gt;x - x));
            out += l_vector_kernel(dx/h)*std::pow(dx, j_power);
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> out;
    }
    
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">inline</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; l_vector_b(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;data, <B><FONT COLOR="#228B22">double</FONT></B> x){
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out(data.samples.size());
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> S1(l_vector_S(h,data,x,1.0)), S2(l_vector_S(h,data,x,2.0));
        size_t cnt(0);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = data.samples.begin(); p_it != data.samples.end(); ++p_it, ++cnt){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> dx((p_it-&gt;x - x));
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> bi(l_vector_kernel(dx/h)*(S2 - dx*S1));
            out[cnt] = bi;
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
    }
    
    <B><FONT COLOR="#228B22">static</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; l_vector(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;data , <B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">bool</FONT></B> *OK){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Provided a nullptr when it was not expected&quot;</FONT></B>);
        *OK = false;
    
        <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isnormal(h) || (h &lt;= 0.0)){ *OK = false; <B><FONT COLOR="#A020F0">return</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(); }
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; bs = l_vector_b(h,data,x);
    
        <I><FONT COLOR="#B22222">//Divide each b_i by the sum of all b_i's.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> b_sum(std::accumulate(bs.begin(), bs.end(), 0.0));
        <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isnormal(b_sum) || !std::isnormal(1.0/b_sum)){ *OK = false; <B><FONT COLOR="#A020F0">return</FONT></B> std::move(bs); }
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> b_it = bs.begin(); b_it != bs.end(); ++b_it) *b_it /= b_sum;
    
        *OK = true; <B><FONT COLOR="#A020F0">return</FONT></B> std::move(bs);
    }
    
    <B><FONT COLOR="#228B22">double</FONT></B> Get_Smoothed_at_X(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, <B><FONT COLOR="#228B22">bool</FONT></B> *OK){
        <I><FONT COLOR="#B22222">//Returns the estimated (smoothed) function value at the given x and smoothing parameter h.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Provided a nullptr when it was not expected&quot;</FONT></B>);
        *OK = false;
    
        <I><FONT COLOR="#B22222">//Generate the linear combination of 'l's to combine the Y values.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; ls(l_vector(h,in,x,OK));
        <B><FONT COLOR="#A020F0">if</FONT></B>(*OK == false){ <B><FONT COLOR="#A020F0">return</FONT></B> -1.0;
            <I><FONT COLOR="#B22222">//This is typically due to choice of h being too small, but may be due to many other things.
</FONT></I>            <I><FONT COLOR="#B22222">// The easiest solution is to try avoid this h. Even better, use cross validation to get the
</FONT></I>            <I><FONT COLOR="#B22222">// best value of h. This routine will handle these sorts of errors and should return a 'nice'
</FONT></I>            <I><FONT COLOR="#B22222">// choice of h.
</FONT></I>        }
    
        <B><FONT COLOR="#228B22">double</FONT></B> fval(0.0);
        size_t cnt(0);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = in.samples.begin(); p_it != in.samples.end(); ++p_it, ++cnt)  fval += p_it-&gt;y * ls[cnt];
    
        *OK = true; <B><FONT COLOR="#A020F0">return</FONT></B> fval;
    }
    
    <I><FONT COLOR="#B22222">//Given an h, a position x, and the log of MSE data, evaluate an estimator of the variance (\hat{\sigma}^{2}(x)).
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//This is almost exactly the same as the generic function evaluation routine (called herein), but also performs an
</FONT></I>    <I><FONT COLOR="#B22222">// inverse transformation on the data, bringing it back from log space.
</FONT></I>    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> Get_MSE_at_X(<B><FONT COLOR="#228B22">double</FONT></B> h_conf, <B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;log_mse_data_in, <B><FONT COLOR="#228B22">bool</FONT></B> *OK){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Provided a nullptr when it was not expected&quot;</FONT></B>);
        *OK = false;
    
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> log_of_mse = Get_Smoothed_at_X(h_conf,x,log_mse_data_in,OK);
        <B><FONT COLOR="#A020F0">if</FONT></B>(*OK == false) <B><FONT COLOR="#A020F0">return</FONT></B> -1.0;
    
        *OK = true; <B><FONT COLOR="#A020F0">return</FONT></B> std::exp(log_of_mse);
    }
    
    <B><FONT COLOR="#228B22">double</FONT></B> Get_Conf_at_X(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">double</FONT></B> conf_h, <B><FONT COLOR="#228B22">double</FONT></B> c, <B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;log_mse_data_in, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;data, <B><FONT COLOR="#228B22">bool</FONT></B> *OK){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Provided a nullptr when it was not expected&quot;</FONT></B>);
        *OK = false;
    
        <I><FONT COLOR="#B22222">//Get the l-vector at this x.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; ls(l_vector(h,data,x,OK));
        <B><FONT COLOR="#A020F0">if</FONT></B>(*OK == false) <B><FONT COLOR="#A020F0">return</FONT></B> -1.0;
    
        <I><FONT COLOR="#B22222">//Get the value of the mean-squared-error at this x.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> mse = Get_MSE_at_X(conf_h,x,log_mse_data_in,OK);
        <B><FONT COLOR="#A020F0">if</FONT></B>(*OK == false) <B><FONT COLOR="#A020F0">return</FONT></B> -1.0;
        <B><FONT COLOR="#A020F0">if</FONT></B>(mse &lt; 0.0){ *OK = false; <B><FONT COLOR="#A020F0">return</FONT></B> -1.0; }
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> me = std::sqrt(mse); <I><FONT COLOR="#B22222">//Convert \sigma^2 (ie. the mean-squared-error or variance estimator) into \sigma.
</FONT></I>    
        <I><FONT COLOR="#B22222">//Compute ||l(x)||.
</FONT></I>        <B><FONT COLOR="#228B22">double</FONT></B> l_norm(0.0);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = ls.begin(); it != ls.end(); ++it) l_norm += (*it)*(*it);
        l_norm = std::sqrt(l_norm);
    
        *OK = true; <B><FONT COLOR="#A020F0">return</FONT></B> c*me*l_norm; <I><FONT COLOR="#B22222">//Now +- this with the smoothed function to get confidence bands!
</FONT></I>    }
    
    <B><FONT COLOR="#228B22">double</FONT></B> Get_Cross_Validation_Leave_One_Out(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in){
        <I><FONT COLOR="#B22222">//This function should gracefully handle infinities, computational errors, and any other sort of shit
</FONT></I>        <I><FONT COLOR="#B22222">// which would derail a lesser program. The user expects to be able to 'just use it' to find an optimal
</FONT></I>        <I><FONT COLOR="#B22222">// h parameter, and the algorithm searching for the best h parameter should be hand-held through the
</FONT></I>        <I><FONT COLOR="#B22222">// process in case bad results show up.
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">//Therefore, at the slightest sign of computational shenanigans, we return the largest (positive)
</FONT></I>        <I><FONT COLOR="#B22222">// non-inf value we can. The user can easily catch it, and the algorithm will simply consider it a
</FONT></I>        <I><FONT COLOR="#B22222">// (highly) non-optimal h.
</FONT></I>        <B><FONT COLOR="#228B22">bool</FONT></B> OK;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> N(static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(in.samples.size()));
        <B><FONT COLOR="#228B22">double</FONT></B> out(0.0);
    
        size_t cnt(0);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = in.samples.begin(); p_it != in.samples.end(); ++p_it, ++cnt){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> x(p_it-&gt;x);
            <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; ls(l_vector(h,in,x,&amp;OK));
            <B><FONT COLOR="#A020F0">if</FONT></B>(OK == false) <B><FONT COLOR="#A020F0">return</FONT></B> std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::max();
    
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> Lii(ls[cnt]);
    
            <I><FONT COLOR="#B22222">//----------------------
</FONT></I>            <I><FONT COLOR="#B22222">//Compute estimate function value ($\hat{r}$).
</FONT></I>            <B><FONT COLOR="#228B22">double</FONT></B> rhat(0.0);
            size_t ccnt(0);
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> pp_it = in.samples.begin(); pp_it != in.samples.end(); ++pp_it, ++ccnt){
                rhat += pp_it-&gt;y * ls[ccnt];
            }
            <I><FONT COLOR="#B22222">//-----------------------    
</FONT></I>            
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> numer((p_it-&gt;y - rhat)*(p_it-&gt;y - rhat));
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> denom((1.0 - Lii)*(1.0 - Lii));
            
            <B><FONT COLOR="#A020F0">if</FONT></B>(numer == 0.0) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B>((denom == 0.0) || !std::isnormal(numer/denom)){
                <B><FONT COLOR="#A020F0">return</FONT></B> std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::max();
            }
            out += numer/denom;
        }
    
        <B><FONT COLOR="#A020F0">return</FONT></B> out/N;
    }
    
    <B><FONT COLOR="#228B22">double</FONT></B> Get_Cross_Validation_Generalized_CV(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in){
        <I><FONT COLOR="#B22222">//This function should gracefully handle infinities, computational errors, and any other sort of shit
</FONT></I>        <I><FONT COLOR="#B22222">// which would derail a lesser program. The user expects to be able to 'just use it' to find an optimal
</FONT></I>        <I><FONT COLOR="#B22222">// h parameter, and the algorithm searching for the best h parameter should be hand-held through the
</FONT></I>        <I><FONT COLOR="#B22222">// process in case bad results show up.
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">//Therefore, at the slightest sign of computational shenanigans, we return the largest (positive)
</FONT></I>        <I><FONT COLOR="#B22222">// non-inf value we can. The user can easily catch it, and the algorithm will simply consider it a
</FONT></I>        <I><FONT COLOR="#B22222">// (highly) non-optimal h.
</FONT></I>        <B><FONT COLOR="#228B22">bool</FONT></B> OK;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> N(static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(in.samples.size()));
        <B><FONT COLOR="#228B22">double</FONT></B> out(0.0);
    
        size_t cnt(0);
        <B><FONT COLOR="#228B22">double</FONT></B> TrL(0.0); <I><FONT COLOR="#B22222">//Trace of L (sum of all Lii).
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = in.samples.begin(); p_it != in.samples.end(); ++p_it, ++cnt){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> xi(p_it-&gt;x);
            <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; ls(l_vector(h,in,xi,&amp;OK));
            <B><FONT COLOR="#A020F0">if</FONT></B>(OK == false) <B><FONT COLOR="#A020F0">return</FONT></B> std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::max();
    
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> Lii(ls[cnt]);
            TrL += Lii;
    
            <I><FONT COLOR="#B22222">//----------------------
</FONT></I>            <I><FONT COLOR="#B22222">//Compute estimate function value ($\hat{r}$).
</FONT></I>            <B><FONT COLOR="#228B22">double</FONT></B> rhat(0.0);
            size_t ccnt(0);
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> pp_it = in.samples.begin(); pp_it != in.samples.end(); ++pp_it, ++ccnt){
                rhat += pp_it-&gt;y * ls[ccnt];
            }
            <I><FONT COLOR="#B22222">//-----------------------    
</FONT></I>            
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> numer = (p_it-&gt;y - rhat)*(p_it-&gt;y - rhat);
            out += numer;
        }
    
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> denom = (1.0 - TrL/N)*(1.0 - TrL/N);
    
        <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isnormal(denom) || !std::isnormal(out/denom)){
            <B><FONT COLOR="#A020F0">return</FONT></B> std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::max();
        }
        out /= denom;
        <B><FONT COLOR="#A020F0">return</FONT></B> out/N;
    }
    
    <B><FONT COLOR="#228B22">double</FONT></B> Find_Optimal_H(<B><FONT COLOR="#228B22">double</FONT></B> h_0, <B><FONT COLOR="#228B22">double</FONT></B> h_scale, <B><FONT COLOR="#228B22">double</FONT></B> cv_tol, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N_iters, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, <B><FONT COLOR="#228B22">bool</FONT></B> show_info, <B><FONT COLOR="#228B22">bool</FONT></B> *OK){
        <I><FONT COLOR="#B22222">//Given a starting point (h_0) and a suspected 'scale' of the problem (ie. how much we need to move h to see a difference)
</FONT></I>        <I><FONT COLOR="#B22222">// we try a minimization scheme to search for an optimal smoothing parameter h.
</FONT></I>        <I><FONT COLOR="#B22222">// 
</FONT></I>        <I><FONT COLOR="#B22222">//This routine is not impervious to local minima or poorly chosen scale. 
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Provided a nullptr when it was not expected&quot;</FONT></B>);
        *OK = false;
    
        <I><FONT COLOR="#B22222">//This is the function we will minimize. We can use the generalized cross validation score, or leave-one-out, or whatever.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> func_to_min = [&amp;in](<B><FONT COLOR="#228B22">double</FONT></B> p[]) -&gt; <B><FONT COLOR="#228B22">double</FONT></B> {
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> l_h = p[0];
            <I><FONT COLOR="#B22222">//const double cv = Get_Cross_Validation_Generalized_CV(l_h, in);
</FONT></I>            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> cv = Get_Cross_Validation_Leave_One_Out(l_h, in);
            <B><FONT COLOR="#A020F0">return</FONT></B> cv;
        };
    
        <I><FONT COLOR="#B22222">//These are the parameters which will be passed in to the function.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dimen = 1;
        <B><FONT COLOR="#228B22">double</FONT></B> params[dimen];
        <B><FONT COLOR="#228B22">double</FONT></B> optimal_h, lowest_func_val;
    
        <I><FONT COLOR="#B22222">//Fill the parameters with some best-guesses.
</FONT></I>        params[0] = h_0;
    
        <I><FONT COLOR="#B22222">//NMSimplex&lt;double&gt; minimizer(dimension, characteristic length, max number of iters, ftol);
</FONT></I>        NMSimplex&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; minimizer(dimen, h_scale, N_iters, cv_tol);
        minimizer.init(params, func_to_min);
    
        <I><FONT COLOR="#B22222">//Iterate through the procedure, breaking on errors or df &lt; ftol.
</FONT></I>        <B><FONT COLOR="#A020F0">while</FONT></B>(minimizer.iter() == 0){
            <B><FONT COLOR="#A020F0">if</FONT></B>(show_info){
                minimizer.get_params(params);
                FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Smallest func val is: &quot;</FONT></B> &lt;&lt; minimizer.func_vals[minimizer.curr_min] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; at h = &quot;</FONT></B> &lt;&lt; params[0] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; on iteration #&quot;</FONT></B> &lt;&lt; minimizer.iteration);
<I><FONT COLOR="#B22222">//                std::cout &lt;&lt; &quot;Smallest func val is: &quot; &lt;&lt; minimizer.func_vals[minimizer.curr_min];
</FONT></I><I><FONT COLOR="#B22222">//                std::cout &lt;&lt; &quot; at h = &quot; &lt;&lt; params[0];
</FONT></I><I><FONT COLOR="#B22222">//                std::cout &lt;&lt; &quot; on iteration #&quot; &lt;&lt; minimizer.iteration &lt;&lt; std::endl; 
</FONT></I>            }
        }
    
        <I><FONT COLOR="#B22222">//Error of some kind.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(minimizer.iter() == -1){ *OK = false; <B><FONT COLOR="#A020F0">return</FONT></B> -1.0; }
    
        minimizer.get_all(func_to_min,params,lowest_func_val);
        optimal_h = params[0];
    
        <I><FONT COLOR="#B22222">//Max number of iterations exceeded. This may or may not be an error. We might still decide to just
</FONT></I>        <I><FONT COLOR="#B22222">// 'roll with it' at this point. The best thing to do is plot cv versus h and visually inspect!
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(minimizer.iter() ==  1){ *OK = false; <B><FONT COLOR="#A020F0">return</FONT></B> optimal_h; }
    
        <I><FONT COLOR="#B22222">//If we get here, df &lt; ftol, so it is a success.
</FONT></I>        *OK = true; <B><FONT COLOR="#A020F0">return</FONT></B> optimal_h;
    }
    
    <I><FONT COLOR="#B22222">//This function computes an estimate of 'c' - the 'confidence' scale which is used in computing the confidence bands.
</FONT></I>    <I><FONT COLOR="#B22222">// It varies with the input data and the choice of confidence percentage (ie. 95% confidence bands). This function 
</FONT></I>    <I><FONT COLOR="#B22222">// also determines an approximate estimate of k_0 - the leading order 'geometrical manifold volume' which is used to
</FONT></I>    <I><FONT COLOR="#B22222">// compute 'c'. It is not a terribly precide computation of k_o, and may be altered in the future.
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> Find_C(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">double</FONT></B> confidence, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, <B><FONT COLOR="#228B22">bool</FONT></B> *OK){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Provided a nullptr when it was not expected&quot;</FONT></B>);
        *OK = false;
    
        <I><FONT COLOR="#B22222">//Note:  95% = 100%*(1-\alpha). Therefore,  alpha = 0.05 -&gt; 95% confidence, similarly
</FONT></I>        <I><FONT COLOR="#B22222">// alpha = 0.1 -&gt; 90% confidence and alpha = 0.5 -&gt; 50% confidence, etc.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> alpha = 1.0 - (confidence/100.0);
        <B><FONT COLOR="#A020F0">if</FONT></B>(!isininc(0.001, alpha, 0.999)){ *OK = false; <B><FONT COLOR="#A020F0">return</FONT></B> -1.0; }
    
        <I><FONT COLOR="#B22222">//We step over each point and perform numerical integration. This is not very precise. A better approach would 
</FONT></I>        <I><FONT COLOR="#B22222">// involve adaptive integration. In nearly-constant variance data, I expect this to be sufficiently accurate 
</FONT></I>        <I><FONT COLOR="#B22222">// for the purposes of generating confidence intervals.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> p1_it = in.samples.begin();
        <B><FONT COLOR="#228B22">auto</FONT></B> p2_it = ++(in.samples.begin());
        <B><FONT COLOR="#228B22">double</FONT></B> k0(0.0);
        <B><FONT COLOR="#A020F0">for</FONT></B>(  ; p2_it != in.samples.end(); ++p1_it, ++p2_it){
            <I><FONT COLOR="#B22222">//const double x(0.5(p2_it-&gt;x + p1_it-&gt;x));
</FONT></I>            <I><FONT COLOR="#B22222">//const double dx(p2_it-&gt;x - p1_it-&gt;x);
</FONT></I>    
            <I><FONT COLOR="#B22222">//At each point, compute and normalize the l-vectors.
</FONT></I>            <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; ls_1(l_vector(h,in,p1_it-&gt;x,OK));
            <B><FONT COLOR="#A020F0">if</FONT></B>(*OK == false) <B><FONT COLOR="#A020F0">return</FONT></B> std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::max();
            <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; ls_2(l_vector(h,in,p2_it-&gt;x,OK));
            <B><FONT COLOR="#A020F0">if</FONT></B>(*OK == false) <B><FONT COLOR="#A020F0">return</FONT></B> std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::max();
    
            {
              <B><FONT COLOR="#228B22">double</FONT></B> ls_1_norm(0.0);
              <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = ls_1.begin(); it != ls_1.end(); ++it) ls_1_norm += (*it)*(*it);
              ls_1_norm = std::sqrt(ls_1_norm);
              <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isnormal(1.0/ls_1_norm)){ *OK = false; <B><FONT COLOR="#A020F0">return</FONT></B> -1.0; }
              <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = ls_1.begin(); it != ls_1.end(); ++it) *it /= ls_1_norm;
            }
    
            {
              <B><FONT COLOR="#228B22">double</FONT></B> ls_2_norm(0.0);
              <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = ls_2.begin(); it != ls_2.end(); ++it) ls_2_norm += (*it)*(*it);
              ls_2_norm = std::sqrt(ls_2_norm);
              <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isnormal(1.0/ls_2_norm)){ *OK = false; <B><FONT COLOR="#A020F0">return</FONT></B> -1.0; }
              <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = ls_2.begin(); it != ls_2.end(); ++it) *it /= ls_2_norm;
            }
    
            <I><FONT COLOR="#B22222">//Compute ||T'(x)||*dx at this x. Because we use the centre-point approximation, we can say that
</FONT></I>            <I><FONT COLOR="#B22222">// at this point we have ||T'(x)||*dx = sqrt( Sum_j of (T(x_{j+1}) - T(x_{j}))^2 ).
</FONT></I>            <B><FONT COLOR="#228B22">double</FONT></B> shtl(0.0);
            {
                <B><FONT COLOR="#228B22">auto</FONT></B> t1_it = ls_1.begin();
                <B><FONT COLOR="#228B22">auto</FONT></B> t2_it = ls_2.begin();
                <B><FONT COLOR="#A020F0">for</FONT></B>(  ; (t2_it != ls_2.end()) &amp;&amp; (t1_it != ls_1.end()); ++t1_it, ++t2_it){
                    shtl += ((*t2_it) - (*t1_it))*((*t2_it) - (*t1_it));
                }
                shtl = std::sqrt(shtl);
                <I><FONT COLOR="#B22222">//shtl /= dx;
</FONT></I>            }
            k0 += shtl; <I><FONT COLOR="#B22222">// *dx;
</FONT></I>        }
    
        <I><FONT COLOR="#B22222">//Now, using our rough k0, compute the corresponding c.
</FONT></I>        <B><FONT COLOR="#228B22">double</FONT></B> c;
        {
          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> numer = (1.0/std::sqrt(2.0*M_PI)) + (k0/M_PI);
          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> denom = 0.05;
          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> theln = std::log(numer/denom);
          <B><FONT COLOR="#A020F0">if</FONT></B>(theln &lt; 0.0){ *OK = false; <B><FONT COLOR="#A020F0">return</FONT></B> -1.0; }
          c = std::sqrt(2.0*theln);
        }
    
        *OK = true; <B><FONT COLOR="#A020F0">return</FONT></B> c;
    }
    
    <I><FONT COLOR="#B22222">//This function takes the data's optimal h and returns log(MSE) data which is itself suitable for regression.
</FONT></I>    samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; Log_of_MSE(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, <B><FONT COLOR="#228B22">bool</FONT></B> *OK){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Provided a nullptr when it was not expected&quot;</FONT></B>);
        *OK = false;
    
        <I><FONT COLOR="#B22222">//Get a (smoothed) estimate of the input data on the input data x_i's.
</FONT></I>        samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; s_f(Get_Smoothed_at_Xi(h,in,OK));
        <B><FONT COLOR="#A020F0">if</FONT></B>(*OK == false) <B><FONT COLOR="#A020F0">return</FONT></B> std::move(s_f);
    
        <I><FONT COLOR="#B22222">//Now, transform the data using F[smoothed_f_i] = ln( (Y_i - smoothed_f_i)**2 ) where Y_i is the input Y at the point X_i
</FONT></I>        <I><FONT COLOR="#B22222">// where smoothed_f_i was calculated.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> p_it = in.samples.begin();
        <B><FONT COLOR="#228B22">auto</FONT></B> s_it = s_f.samples.begin();
        <B><FONT COLOR="#A020F0">for</FONT></B>( ; (p_it != in.samples.end()) &amp;&amp; (s_it != s_f.samples.end()); ++p_it, ++s_it){
            s_it-&gt;y = std::log( (s_it-&gt;y - p_it-&gt;y)*(s_it-&gt;y - p_it-&gt;y) );
        }
    
        *OK = true; <B><FONT COLOR="#A020F0">return</FONT></B> std::move(s_f);
    }
   
    <I><FONT COLOR="#B22222">//This is strictly a convenience function.
</FONT></I>    <I><FONT COLOR="#B22222">//Breaks up the input data into (xmax-xmin)/dx equal-length parts. Samples the smoothed function at each. 
</FONT></I>    samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; Get_Smoothed_Evenly_Spaced(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">double</FONT></B> dx, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, <B><FONT COLOR="#228B22">bool</FONT></B> *OK){
        <I><FONT COLOR="#B22222">//Return constant-separation (dx) smoothed function data.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Provided a nullptr when it was not expected&quot;</FONT></B>);
        *OK = false;
    
        samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> xmin(in.samples.front().x);
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> xmax(in.samples.back().x);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> x = xmin; x &lt; xmax; x += dx){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> fval(Get_Smoothed_at_X(h,x,in,OK));
            <B><FONT COLOR="#A020F0">if</FONT></B>(*OK == false) <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
            out.samples.push_back(vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(x, fval));
        }
    
        *OK = true; <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
    }
    
    <I><FONT COLOR="#B22222">//For the given input (x_i,y_i), generate smoothed output (x_i,s_y_i) at the (exact) same x_i. This is used internally
</FONT></I>    <I><FONT COLOR="#B22222">// and might be of interest to the user as a convenience function.
</FONT></I>    samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; Get_Smoothed_at_Xi(<B><FONT COLOR="#228B22">double</FONT></B> h, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, <B><FONT COLOR="#228B22">bool</FONT></B> *OK){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Provided a nullptr when it was not expected&quot;</FONT></B>);
        *OK = false;
    
        <I><FONT COLOR="#B22222">//Generate a (smoothed) estimate of the input data on the input data x_i's.
</FONT></I>        samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; s_f(in); <I><FONT COLOR="#B22222">//&quot;smoothed function&quot;
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = s_f.samples.begin(); p_it != s_f.samples.end(); ++p_it){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> fval = Get_Smoothed_at_X(h,p_it-&gt;x,in,OK);
            <B><FONT COLOR="#A020F0">if</FONT></B>(*OK == false) <B><FONT COLOR="#A020F0">return</FONT></B> std::move(s_f);
            p_it-&gt;y = fval;
        }
        *OK = true; <B><FONT COLOR="#A020F0">return</FONT></B> std::move(s_f);
    }


    <I><FONT COLOR="#B22222">//This function should work for most cases. Given some data, it attempts to smooth it. It then computes smoothed data
</FONT></I>    <I><FONT COLOR="#B22222">// using Get_Smoothed_at_Xi(...). No info about h or c is given back - just the data.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Only use this if you are satisfied with the output and/or have previously investigated the effect of h on the data.
</FONT></I>    samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; Attempt_Auto_Smooth(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, <B><FONT COLOR="#228B22">bool</FONT></B> *OK){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Provided a nullptr when it was not expected&quot;</FONT></B>);
        *OK = false;

        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> xmin      = in.samples.front().x;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> xmax      = in.samples.back().x;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> N         = static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(in.samples.size());
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> avg_dx    = (xmax - xmin)/N;

        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> h_0       = (xmax - xmin)/5.0;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> h_scale   = 5.0 * avg_dx;

        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> h_optimal = Find_Optimal_H(h_0, h_scale, 1E-7, 5000, in, false, OK);
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == false) <B><FONT COLOR="#A020F0">return</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;();

        *OK = true; <B><FONT COLOR="#A020F0">return</FONT></B> Get_Smoothed_at_Xi(h_optimal, in, OK);
    }

    <I><FONT COLOR="#B22222">//This routine will perform a battery of tests against some data. It should be suitable for initial exploration of some
</FONT></I>    <I><FONT COLOR="#B22222">// data. 
</FONT></I>    <I><FONT COLOR="#B22222">// NOTE: -To kill the process, send a nullptr for OK. Otherwise, errors will be signaled through it.
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> Attempt_Auto_Analysis(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;data, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;Title <I><FONT COLOR="#B22222">/*=&quot;&quot;*/</FONT></I>, <B><FONT COLOR="#228B22">bool</FONT></B> only_show_final <I><FONT COLOR="#B22222">/*=true*/</FONT></I>, Plotter2 *plotter <I><FONT COLOR="#B22222">/*=nullptr*/</FONT></I>, <B><FONT COLOR="#228B22">bool</FONT></B> *OK <I><FONT COLOR="#B22222">/*=nullptr*/</FONT></I>){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
        <B><FONT COLOR="#228B22">bool</FONT></B> l_OK(false);  <I><FONT COLOR="#B22222">//Local OK signalling.
</FONT></I>
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> xmin       = data.samples.front().x;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> xmax       = data.samples.back().x;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> N          = static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(data.samples.size());
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> avg_dx     = (xmax - xmin)/N;

        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> h_0        = (xmax - xmin)/5.0;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> h_scale    = 5.0 * avg_dx;
        <B><FONT COLOR="#228B22">const</FONT></B> std::string title = (Title.empty()) ? <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> : Title + <B><FONT COLOR="#BC8F8F">&quot; - &quot;</FONT></B>;


        <I><FONT COLOR="#B22222">//Plot of specific smoothed function compared with original data.
</FONT></I>        {
            <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; hs({0.001, 0.01, 0.1, 1.0, 10.0, 25.0, 37.0, 50.0, 100.0, 150.0, 200.0, 300.0 });
            <B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;std::string, samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; plot_shtl;
            plot_shtl[<B><FONT COLOR="#BC8F8F">&quot;Original&quot;</FONT></B>] = data;
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> hs_it = hs.begin(); hs_it != hs.end(); ++hs_it){
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> smoothed = NPRLL::Get_Smoothed_Evenly_Spaced(*hs_it, 2.0, data, &amp;l_OK); 
                <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK) plot_shtl[<B><FONT COLOR="#BC8F8F">&quot;h = &quot;</FONT></B>_s + Xtostring(*hs_it)] = smoothed;
            }
            <B><FONT COLOR="#A020F0">if</FONT></B>(!only_show_final) Plot2_Map_of_Samples_1D(plot_shtl.begin(), plot_shtl.end(), title + <B><FONT COLOR="#BC8F8F">&quot;Different smoothing parameters&quot;</FONT></B>);
        }
    
        <I><FONT COLOR="#B22222">//Examine the cross-validation score over a range of h's.
</FONT></I>        {
            <B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;std::string, samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; plot_shtl;
            {
              samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; cvs_loo, cvs_gcv;
              <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> h = 0.5; h &lt; 500.0; h += 2.0){
                  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> cv_loo = NPRLL::Get_Cross_Validation_Leave_One_Out(h,data);
                  <B><FONT COLOR="#A020F0">if</FONT></B>(cv_loo &gt; 1E50){ <I><FONT COLOR="#B22222">/* cvs_loo.samples.push_back(vec2&lt;double&gt;(h,-50.0)); */</FONT></I>
                  }<B><FONT COLOR="#A020F0">else</FONT></B>{             cvs_loo.samples.push_back(vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(h,cv_loo));
                  }
                  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> cv_gcv = NPRLL::Get_Cross_Validation_Generalized_CV(h,data);
                  <B><FONT COLOR="#A020F0">if</FONT></B>(cv_gcv &gt; 1E50){ <I><FONT COLOR="#B22222">/* cvs_gcv.samples.push_back(vec2&lt;double&gt;(h,-50.0)); */</FONT></I>
                  }<B><FONT COLOR="#A020F0">else</FONT></B>{             cvs_gcv.samples.push_back(vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(h,cv_gcv));
                  }
              }
              plot_shtl[<B><FONT COLOR="#BC8F8F">&quot;Leave-one-out CV&quot;</FONT></B>] = cvs_loo;
              plot_shtl[<B><FONT COLOR="#BC8F8F">&quot;Generalized CV&quot;</FONT></B>]   = cvs_gcv;
            }
            <B><FONT COLOR="#A020F0">if</FONT></B>(!only_show_final) Plot2_Map_of_Samples_1D(plot_shtl.begin(), plot_shtl.end(), title + <B><FONT COLOR="#BC8F8F">&quot;Cross-validation vs h&quot;</FONT></B>);
        }
    
        <I><FONT COLOR="#B22222">//Perform a full-featured analysis. Starting with raw data, perform non-parametric regression, compute some
</FONT></I>        <I><FONT COLOR="#B22222">// 95% confidence intervals, and plot: the data, the smoothed data, and the confidence bands.
</FONT></I>        {
            <B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;std::string, samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; plot_shtl;
            plot_shtl[<B><FONT COLOR="#BC8F8F">&quot;Original Data&quot;</FONT></B>] = data;
    
            <I><FONT COLOR="#B22222">//Smoothed function approximation (quantized on each x_i).
</FONT></I>            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> verbose_optimal_h = false;
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> h_optimal = NPRLL::Find_Optimal_H(h_0, h_scale, 1E-7, 5000, data, verbose_optimal_h, &amp;l_OK);
            <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){  
                <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to determine an optimal h. Value returned was &quot;</FONT></B> &lt;&lt; h_optimal);
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to determine an optimal h. Value returned was &quot;</FONT></B> &lt;&lt; h_optimal);
                <B><FONT COLOR="#A020F0">return</FONT></B>;
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Found optimal h = &quot;</FONT></B> &lt;&lt; h_optimal);
            }
    
            {
              <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> smoothed = Get_Smoothed_Evenly_Spaced(h_optimal, avg_dx, data, &amp;l_OK);
              <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == true) plot_shtl[<B><FONT COLOR="#BC8F8F">&quot;Smoothed Optimally&quot;</FONT></B>] = smoothed;  <I><FONT COLOR="#B22222">//Should be '~Optimally' but makes it annoying to plot.
</FONT></I>            }
    
            <I><FONT COLOR="#B22222">//--------------------------------------
</FONT></I>            <I><FONT COLOR="#B22222">//Compute necessary info to evaluate the confidence bands (not quite of the smooth function approximation, but close!).
</FONT></I>            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> log_mse_est = NPRLL::Log_of_MSE(h_optimal, data, &amp;l_OK);
            <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
                <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Encountered error computing log of MSE estimate data&quot;</FONT></B>);
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to compute log of MSE estimate data&quot;</FONT></B>);
                <B><FONT COLOR="#A020F0">return</FONT></B>;
            }    
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> conf_h_0       = 100.0;
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> conf_h_scale   = 5.0;
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> conf_h_optimal = NPRLL::Find_Optimal_H(conf_h_0, conf_h_scale, 1E-7, 5000, log_mse_est, verbose_optimal_h, &amp;l_OK);
            <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
                <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Encountered error computing smoothed function&quot;</FONT></B>);
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to compute smoothed function&quot;</FONT></B>);
                <B><FONT COLOR="#A020F0">return</FONT></B>;
            }

            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> c = NPRLL::Find_C(h_optimal, 95.0, data, &amp;l_OK);
            {
              samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; plot_l, plot_u;
              <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> x = xmin; x &lt; xmax; x += 2.0*avg_dx){
                  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> fval = NPRLL::Get_Smoothed_at_X(h_optimal, x, data, &amp;l_OK);
                  <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> band = NPRLL::Get_Conf_at_X(h_optimal, conf_h_optimal, c, x, log_mse_est, data, &amp;l_OK);
                  <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    
                  plot_l.samples.push_back(vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(x,fval - band));
                  plot_u.samples.push_back(vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(x,fval + band));
              }
              plot_shtl[<B><FONT COLOR="#BC8F8F">&quot;Lower band - 95%&quot;</FONT></B>] = plot_l;
              plot_shtl[<B><FONT COLOR="#BC8F8F">&quot;Upper band - 95%&quot;</FONT></B>] = plot_u;
            }
   
            <B><FONT COLOR="#A020F0">if</FONT></B>(plotter != nullptr){
                plotter-&gt;Set_Global_Title(title + <B><FONT COLOR="#BC8F8F">&quot;NPRLL&quot;</FONT></B>); <I><FONT COLOR="#B22222">//User can override this later.
</FONT></I>                plotter-&gt;Insert_map_of_string_and_samples_1D(plot_shtl);
            }<B><FONT COLOR="#A020F0">else</FONT></B>{ 
                Plot2_Map_of_Samples_1D(plot_shtl.begin(), plot_shtl.end(), title + <B><FONT COLOR="#BC8F8F">&quot;NPRLL&quot;</FONT></B>);
            }
        }

        <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
        <B><FONT COLOR="#A020F0">return</FONT></B>;
    }

} <I><FONT COLOR="#B22222">//end of namespace NPRLL.
</FONT></I>

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------- Architecture-independant Non-cryptographic Hashes --------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I>uint64_t <B><FONT COLOR="#0000FF">Consistent_Hash_64</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#A020F0">if</FONT></B>(in.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> static_cast&lt;uint64_t&gt;(1337);

    SpookyHash H;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> *p = static_cast&lt;<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> *&gt;(const_cast&lt;<B><FONT COLOR="#228B22">char</FONT></B> *&gt;(in.c_str()));
    <B><FONT COLOR="#228B22">const</FONT></B> uint64_t seed(1337331337);
    <B><FONT COLOR="#A020F0">return</FONT></B> H.Hash64(p, in.size(), seed);
}

<I><FONT COLOR="#B22222">//MD5 hash.
</FONT></I>std::unique_ptr&lt;uint8_t[]&gt; MD5_Hash(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t bytecnt, std::string *hash){
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(hash == nullptr){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr instead of a space to store resulting hash. Cannot continue&quot;</FONT></B>);
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr instead of a space to store resulting hash. Bailing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(!hash-&gt;empty()){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Passed a non-empty hash store. Assuming appending hashes is desired&quot;</FONT></B>);
    }

    <B><FONT COLOR="#5F9EA0">MD5</FONT></B>::Context working;
    <B><FONT COLOR="#5F9EA0">MD5</FONT></B>::Init(&amp;working);
    <B><FONT COLOR="#5F9EA0">MD5</FONT></B>::Update(&amp;working, (<B><FONT COLOR="#228B22">void</FONT></B> *)(in.get()), bytecnt);

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *result = <B><FONT COLOR="#A020F0">new</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>[16+1];
    result[16] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
    <B><FONT COLOR="#5F9EA0">MD5</FONT></B>::Final(result, &amp;working);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;
    ss &lt;&lt; std::hex &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 16; ++i) ss &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B>&gt;(result[i]);
    <B><FONT COLOR="#A020F0">delete</FONT></B>[] result;
    *hash += ss.str();

    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}


<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------- Fitting Algorithms ----------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I>

<I><FONT COLOR="#B22222">//This driver is wrapped by the other routines. Preferentially use them.
</FONT></I>std::tuple&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;
<B><FONT COLOR="#0000FF">Ygor_Fit_Driver</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *wasOK,
             <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
             <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,
             <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars,
             uint32_t fitflags,
             <B><FONT COLOR="#228B22">bool</FONT></B> Verbose,
             <B><FONT COLOR="#228B22">double</FONT></B> char_len,
             <B><FONT COLOR="#228B22">int</FONT></B> max_iters,
             <B><FONT COLOR="#228B22">double</FONT></B> ftol ){


    <B><FONT COLOR="#A020F0">if</FONT></B>(wasOK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr bool. Unable to signal whether evaluation worked or not&quot;</FONT></B>);
    *wasOK = false;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::tuple&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; out;

    <I><FONT COLOR="#B22222">// ----------------- Sanity checking -------------------
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!f || data.empty() || vars.empty()){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Given insufficient or incomplete information to perform fit. Bailing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> out;

    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::DIM2) &amp;&amp; !isininc(2,data.front().size(),3)){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Given too much or too little data for 2D fit. Bailing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> out;

    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::DIM3) &amp;&amp; !isininc(3,data.front().size(),4)){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Given too much or too little data for 3D fit. Bailing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> out;

    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(!BITMASK_BITS_ARE_SET(fitflags,YGORFIT::LSS) &amp;&amp; !BITMASK_BITS_ARE_SET(fitflags,YGORFIT::LMS)){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Need to specify least-sum of squares or least-median of squares. Bailing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> out;

    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        <I><FONT COLOR="#B22222">//All rows have same number of cols.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> it = data.begin();
        size_t numcols = it-&gt;size();
        <B><FONT COLOR="#A020F0">do</FONT></B>{
            <B><FONT COLOR="#A020F0">if</FONT></B>(numcols != it-&gt;size()){
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Found two rows which differ in number of columns. Please pad to identical sizes. Bailing&quot;</FONT></B>);
                <B><FONT COLOR="#A020F0">return</FONT></B> out;
            }
            numcols = it-&gt;size();
        }<B><FONT COLOR="#A020F0">while</FONT></B>((++it) != data.end());
    }


    <I><FONT COLOR="#B22222">// ---------------- Setup -----------------
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> DOF = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(data.size()) - static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(vars.size()); 
    <B><FONT COLOR="#228B22">const</FONT></B> size_t numb_of_fit_parameters = vars.size();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> N_COLS = data.front().size();

    <I><FONT COLOR="#B22222">// ---------------- 'sticky' statistical quantities for later use ------------------- 
</FONT></I>    <I><FONT COLOR="#B22222">//We capture the best when we see them in case the max number of iterations is exceeded
</FONT></I>    <I><FONT COLOR="#B22222">// and the routine craps out prematurely. In theory, the best should be the last (when 
</FONT></I>    <I><FONT COLOR="#B22222">// ftol is achieved).
</FONT></I>    <B><FONT COLOR="#228B22">bool</FONT></B> Performed_First_Pass = false; <I><FONT COLOR="#B22222">//On the first pass through (only), we will compute this for later use.
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> F_data_mean = 0.0;
    <B><FONT COLOR="#228B22">double</FONT></B> best_SStot = std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::max();  <I><FONT COLOR="#B22222">// = sum_i (fi - fmean)^2.
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> best_SSres = std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::max();  <I><FONT COLOR="#B22222">// = sum_i (fi - f_meas_i)^2  aka ~what we are minimizing.
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> best_WSSR  = std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::max();  <I><FONT COLOR="#B22222">// same as SSres but contains a weighting factor. This what we are minimizing.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; best_SRs;

    <I><FONT COLOR="#B22222">// ----------------- minimization lambda ------------------
</FONT></I>    <B><FONT COLOR="#228B22">bool</FONT></B> failure_inside_func_to_min = false;   <I><FONT COLOR="#B22222">//Escape signal. If this is set (within func_to_min), iteration halts asap.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> func_to_min = [&amp;](<B><FONT COLOR="#228B22">double</FONT></B> p[]) -&gt; <B><FONT COLOR="#228B22">double</FONT></B> {
        <I><FONT COLOR="#B22222">//We want to minimize WSSR = 'weighted sum of squares of residuals' = 'weighted residual sum of squares'
</FONT></I>        <I><FONT COLOR="#B22222">// by adjusting A,B,C,...  The unweighted SSres is equivalent to WSSR when wi = 1.0;
</FONT></I>        <B><FONT COLOR="#228B22">double</FONT></B> SStot(0.0), SSres(0.0), WSSR(0.0);
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; SRs;

        <I><FONT COLOR="#B22222">//Iterate over rows of data.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> r_it = data.begin(); r_it != data.end(); ++r_it){
            <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; X; <I><FONT COLOR="#B22222">//x-values. This will always be 1 for f(x), 2 for f(x,y), etc..
</FONT></I>            <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; P; <I><FONT COLOR="#B22222">//Parameters. We just convert from double[] to std::list.
</FONT></I>            <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;numb_of_fit_parameters; ++i) P.push_back(p[i]);
            <B><FONT COLOR="#228B22">double</FONT></B> W(0.0);
            <B><FONT COLOR="#228B22">double</FONT></B> F_data;

            <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::DIM2) &amp;&amp; (N_COLS == 2)){
                <I><FONT COLOR="#B22222">// Data:   &lt;X_i&gt; &lt;F_i&gt;
</FONT></I>                X.push_back(r_it-&gt;front());
                F_data = r_it-&gt;back();
                W = 1.0; <I><FONT COLOR="#B22222">//Effectively no weighting.
</FONT></I>         
            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::DIM2) &amp;&amp; (N_COLS == 3)){
                <I><FONT COLOR="#B22222">// Data:   &lt;X_i&gt; &lt;F_i&gt; &lt;_F_i&gt;
</FONT></I>                X.push_back(r_it-&gt;front());
                F_data = *std::next(r_it-&gt;begin());
                W = r_it-&gt;back();

            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::DIM3) &amp;&amp; (N_COLS == 3)){
                <I><FONT COLOR="#B22222">// Data:   &lt;X_i&gt; &lt;Y_i&gt; &lt;F_i&gt;
</FONT></I>                X.push_back(*std::next(r_it-&gt;begin(),0));
                X.push_back(*std::next(r_it-&gt;begin(),1));
                F_data = r_it-&gt;back();
                W = 1.0; <I><FONT COLOR="#B22222">//Effectively no weighting.
</FONT></I>
            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::DIM3) &amp;&amp; (N_COLS == 4)){
                <I><FONT COLOR="#B22222">// Data:   &lt;X_i&gt; &lt;Y_i&gt; &lt;F_i&gt; &lt;_F_i&gt;
</FONT></I>                X.push_back(*std::next(r_it-&gt;begin(),0));
                X.push_back(*std::next(r_it-&gt;begin(),1));
                F_data = *std::next(r_it-&gt;begin(),2);
                W = r_it-&gt;back();

            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Currently cannot understand what type of analysis you are asking for. Implement it here&quot;</FONT></B>);
                failure_inside_func_to_min = true;
                <B><FONT COLOR="#A020F0">return</FONT></B> -1.0;

            }
 
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> F_func = f(X,P);
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> SR = (F_func - F_data)*(F_func - F_data); <I><FONT COLOR="#B22222">//Squared residual.
</FONT></I>            SRs.push_back(SR);

            <I><FONT COLOR="#B22222">//Uncertainties override.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::UNCERT_CAUCHY)){
                W = (1.0 + 4.0*SR); <I><FONT COLOR="#B22222">//Cauchy distribution. Should help LSS reject outliers better.
</FONT></I>            }

            <I><FONT COLOR="#B22222">//Sanity checking.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(W == 0.0){
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Somehow ended up with zero uncertainty. This routine cannot handle zero uncertainty&quot;</FONT></B>);
                failure_inside_func_to_min = true;
                <B><FONT COLOR="#A020F0">return</FONT></B> -1.0;
            }

            <I><FONT COLOR="#B22222">//Stats storage.
</FONT></I>            WSSR += SR/(W*W);
            <B><FONT COLOR="#A020F0">if</FONT></B>(!Performed_First_Pass){ 
                F_data_mean += F_data;
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                SSres += SR; <I><FONT COLOR="#B22222">//+=(func - func_data)*(func - func_data)
</FONT></I>                SStot += (F_data - F_data_mean)*(F_data - F_data_mean);
            }
        }
   
        <I><FONT COLOR="#B22222">//Stick the Sticky statistics, if appropriate.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(!Performed_First_Pass){
            Performed_First_Pass = true;
            F_data_mean /= static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(data.size());
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(WSSR &lt; best_WSSR){
            best_WSSR  = WSSR;
            best_SSres = SSres;
            best_SStot = SStot;
            best_SRs   = SRs;
        }

        <I><FONT COLOR="#B22222">//What does our objective function return?
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::LSS)){
            <I><FONT COLOR="#B22222">//Regular least-squares approach.
</FONT></I>            <B><FONT COLOR="#A020F0">return</FONT></B> WSSR;
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::LMS)){
            <I><FONT COLOR="#B22222">//NOTE: All statistics using this approach will be GARBAGE! (Use bootstrap instead!)
</FONT></I>            <B><FONT COLOR="#A020F0">return</FONT></B> Ygor_Median(SRs);
        }

        <I><FONT COLOR="#B22222">//------ We should never get here. -----
</FONT></I>        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Objective function not properly specified. Cannot continue&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> -1.0 - DOF;
    };

    <I><FONT COLOR="#B22222">//----------------- Minimization Setup -----------------
</FONT></I>    <I><FONT COLOR="#B22222">//These are the parameters which will be passed in to the function.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; min_params = nullptr;
    min_params.reset(<B><FONT COLOR="#A020F0">new</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>[numb_of_fit_parameters]);
    
    <I><FONT COLOR="#B22222">//Fill the parameters with some best-guesses.
</FONT></I>    {
      <B><FONT COLOR="#228B22">auto</FONT></B> varit = vars.begin();
      <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;numb_of_fit_parameters; ++i, ++varit){
          (min_params.get())[i] = *varit;
      }
    }

    <I><FONT COLOR="#B22222">//NMSimplex&lt;double&gt; minimizer(numb_of_fit_parameters, characteristic length, max number of iters, ftol);
</FONT></I>    NMSimplex&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; minimizer(numb_of_fit_parameters, char_len, max_iters, ftol);
    minimizer.init(min_params.get(), func_to_min);

    <I><FONT COLOR="#B22222">//-------------- Minimization computation ----------------
</FONT></I>    <B><FONT COLOR="#A020F0">while</FONT></B>(minimizer.iter() == 0){
        <B><FONT COLOR="#A020F0">if</FONT></B>(failure_inside_func_to_min == true){
            FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Encountered failure whilst trying to evaluate function to be minimized. Cannot continue&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> out;
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>(Verbose){
            <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout.precision(10);
            FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Minimization: At iteration &quot;</FONT></B> &lt;&lt; minimizer.iteration &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; the lowest value is &quot;</FONT></B> &lt;&lt; minimizer.func_vals[minimizer.curr_min]);
        }
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>(minimizer.iter() == -1){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Min scheme exited due to error. Maybe the initial params were not set?&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(minimizer.iter() ==  1){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Min scheme finished due to max num of iters being exceeded.&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::NON_CONVERG_IS_ERR)){
            *wasOK = false;
            <B><FONT COLOR="#A020F0">return</FONT></B> out;
        }
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((minimizer.iter() ==  2) &amp;&amp; Verbose) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Min scheme completed due to ftol &lt; ftol_min.&quot;</FONT></B>);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; best_params;
    minimizer.get_params(min_params.get());
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;numb_of_fit_parameters; ++i){
        best_params.push_back( (min_params.get())[i] );
    }

    <I><FONT COLOR="#B22222">//------------ output synthesis ------------- 
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::LSS)){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> chi_sq = best_WSSR;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> red_chi_sq = chi_sq/static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(DOF);
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Qvalue = Stats::Q_From_ChiSq_Fit(chi_sq, static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(DOF));
 
        <I><FONT COLOR="#B22222">//Not sure which is more useful. See http://en.wikipedia.org/wiki/Coefficient_of_determination. 
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> raw_coeff_deter = 1.0 - best_SSres/best_SStot; <I><FONT COLOR="#B22222">//Uses unweighted SSres, not weighted SSres. Use this if worried about weight scaling.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> mod_coeff_deter = 1.0 - best_WSSR/best_SStot;  <I><FONT COLOR="#B22222">//Uses weighted SSres. This is the consistent choice. Use this if in doubt.
</FONT></I>        <I><FONT COLOR="#B22222">//best_SRs contains an unordered listing of all squared-residuals and is suitable for inspection/verification of uncertainties.
</FONT></I>        out = std::make_tuple(best_params, chi_sq, Qvalue, DOF, red_chi_sq, raw_coeff_deter, mod_coeff_deter, best_SRs);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(BITMASK_BITS_ARE_SET(fitflags,YGORFIT::LMS)){
        <I><FONT COLOR="#B22222">//NOTE: If you are reading this and wondering what to do for stats: &quot;Use your bootstraps, Luke!&quot;
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> chi_sq = -1.0;  
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> red_chi_sq = -1.0;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Qvalue = -1.0;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> raw_coeff_deter = -1.0;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> mod_coeff_deter = -1.0;
        out = std::make_tuple(best_params, chi_sq, Qvalue, DOF, red_chi_sq, raw_coeff_deter, mod_coeff_deter, best_SRs);

    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unspecified fitting method. Unable to compute any stats or continue&quot;</FONT></B>);
    }
    *wasOK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


std::tuple&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;
<B><FONT COLOR="#0000FF">Ygor_Fit_LSS</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *wasOK,
             <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
             <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,        <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars,
             <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim,  <B><FONT COLOR="#228B22">bool</FONT></B> Verbose<I><FONT COLOR="#B22222">/*=false*/</FONT></I>,  <B><FONT COLOR="#228B22">double</FONT></B> char_len<I><FONT COLOR="#B22222">/*=0.6*/</FONT></I>,  <B><FONT COLOR="#228B22">int</FONT></B> max_iters<I><FONT COLOR="#B22222">/*=1500*/</FONT></I>,
             <B><FONT COLOR="#228B22">double</FONT></B> ftol<I><FONT COLOR="#B22222">/*=1E-6*/</FONT></I> ){

    uint32_t fitflags(0);
    <B><FONT COLOR="#A020F0">if</FONT></B>(dim == 2){        fitflags |= YGORFIT::DIM2;
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(dim == 3){  fitflags |= YGORFIT::DIM3;
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Cannot handle dimensions other than 2 [f(x)] or 3 [f(x,y)]. Cannot proceed&quot;</FONT></B>);
    }
    fitflags |= YGORFIT::LSS;

    <B><FONT COLOR="#A020F0">return</FONT></B> Ygor_Fit_Driver(wasOK,f,data,vars,fitflags,Verbose,char_len,max_iters,ftol);
}

std::tuple&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;
<B><FONT COLOR="#0000FF">Ygor_Fit_LMS</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *wasOK,
             <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
             <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,        <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars,
             <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim,  <B><FONT COLOR="#228B22">bool</FONT></B> Verbose<I><FONT COLOR="#B22222">/*=false*/</FONT></I>,  <B><FONT COLOR="#228B22">double</FONT></B> char_len<I><FONT COLOR="#B22222">/*=0.6*/</FONT></I>,  <B><FONT COLOR="#228B22">int</FONT></B> max_iters<I><FONT COLOR="#B22222">/*=1500*/</FONT></I>,
             <B><FONT COLOR="#228B22">double</FONT></B> ftol<I><FONT COLOR="#B22222">/*=1E-6*/</FONT></I> ){
    
    uint32_t fitflags(0);
    <B><FONT COLOR="#A020F0">if</FONT></B>(dim == 2){        fitflags |= YGORFIT::DIM2;
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(dim == 3){  fitflags |= YGORFIT::DIM3;
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Cannot handle dimensions other than 2 [f(x)] or 3 [f(x,y)]. Cannot proceed&quot;</FONT></B>);
    }
    fitflags |= YGORFIT::LMS;

    <B><FONT COLOR="#228B22">auto</FONT></B> tup = Ygor_Fit_Driver(wasOK,f,data,vars,fitflags,Verbose,char_len,max_iters,ftol);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> best_params = std::get&lt;0&gt;(tup);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> best_SRs    = std::get&lt;7&gt;(tup);
    <B><FONT COLOR="#A020F0">return</FONT></B> std::make_tuple(best_params,best_SRs);
}




std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; Ygor_Fit_Bootstrap_Driver(<B><FONT COLOR="#228B22">bool</FONT></B> *wasOK,
         <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
         <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,  <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars, uint32_t fitflags,
         <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N,   <B><FONT COLOR="#228B22">double</FONT></B> char_len,   <B><FONT COLOR="#228B22">int</FONT></B> max_iters,    <B><FONT COLOR="#228B22">double</FONT></B> ftol){

    *wasOK = false;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; out;
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i = 0; i &lt; vars.size(); ++i) out.push_back(std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;());

    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MAX_N_ERRS = 100*N;  <I><FONT COLOR="#B22222">//Will happen if single row is picked or some other unreasonable scenario.
</FONT></I>    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N_ERRS = 0;

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::random_device rdev;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::mt19937 re( rdev() ); <I><FONT COLOR="#B22222">//Random engine.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::uniform_int_distribution&lt;&gt; rd(0, data.size()-1); <I><FONT COLOR="#B22222">//Random distribution.
</FONT></I>
    <I><FONT COLOR="#B22222">//Fill up the substitute data buffer with randomly-chosen values.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; sub_data;
    <B><FONT COLOR="#A020F0">while</FONT></B>(sub_data.size() != data.size()){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> nth = rd(re);
        sub_data.push_back( *std::next(data.begin(),nth) );
    }

    <I><FONT COLOR="#B22222">//Perform fits with randomly-selected data until we have N samples of the parameters.
</FONT></I>    time_mark Began;
    <B><FONT COLOR="#A020F0">while</FONT></B>(true){
        <I><FONT COLOR="#B22222">//Select a row to discard and a row to inject. Try to get ~10% of the rows each time
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> x = 0.0; x &lt; 0.1*static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(sub_data.size()); x+=1.0){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> nth = rd(re), mth = rd(re);
            sub_data.erase( std::next(sub_data.begin(),nth) );
            sub_data.push_back( *std::next(data.begin(),mth) );
        }
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; fit_params;

        <B><FONT COLOR="#228B22">auto</FONT></B> tup = Ygor_Fit_Driver(wasOK,f,sub_data,vars,fitflags,false,char_len,max_iters,ftol);
        fit_params = std::get&lt;0&gt;(tup);

        <B><FONT COLOR="#A020F0">if</FONT></B>(*wasOK == false){
            ++N_ERRS;
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((out.front().size() % 10) == 0){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dt = static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(Began.Diff_in_Seconds(time_mark())) + 0.001;
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dbl_n  = static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(out.front().size());
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dbl_N  = static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(N);
            
            FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Estimated remaining time: &quot;</FONT></B> &lt;&lt; ((dbl_N/dbl_n)-1.0)*dt);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>(N_ERRS &gt;= MAX_N_ERRS){
            *wasOK = false;
            <B><FONT COLOR="#A020F0">return</FONT></B> out;
        }

        <I><FONT COLOR="#B22222">//Get the data.
</FONT></I>        {
          <B><FONT COLOR="#228B22">auto</FONT></B> fpit = fit_params.begin(); 
          <B><FONT COLOR="#228B22">auto</FONT></B> oit  = out.begin();
          <B><FONT COLOR="#A020F0">while</FONT></B>((fpit != fit_params.end()) &amp;&amp; (oit != out.end())){
              oit-&gt;push_back(*fpit);
              ++fpit;
              ++oit;
          }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>(static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(out.front().size()) &gt;= N) <B><FONT COLOR="#A020F0">break</FONT></B>;
    }

    <I><FONT COLOR="#B22222">//All rows have same number of cols.
</FONT></I>    {
      <B><FONT COLOR="#228B22">auto</FONT></B> it = out.begin();
      size_t numcols = it-&gt;size();
      <B><FONT COLOR="#A020F0">do</FONT></B>{
          <B><FONT COLOR="#A020F0">if</FONT></B>(numcols != it-&gt;size()){
              FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Failed to produce N samples of fitting parameters due to programming error&quot;</FONT></B>);
              <B><FONT COLOR="#A020F0">return</FONT></B> out;
          }
          numcols = it-&gt;size();
      }<B><FONT COLOR="#A020F0">while</FONT></B>((++it) != out.end());
    }

    *wasOK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}



std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;
<B><FONT COLOR="#0000FF">Ygor_Fit_Bootstrap_LSS</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *wasOK,
             <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
             <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,  <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim, 
             <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N,  <B><FONT COLOR="#228B22">double</FONT></B> char_len,  <B><FONT COLOR="#228B22">int</FONT></B> max_iters, <B><FONT COLOR="#228B22">double</FONT></B> ftol){

    uint32_t fitflags(0);
    <B><FONT COLOR="#A020F0">if</FONT></B>(dim == 2){        fitflags |= YGORFIT::DIM2;
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(dim == 3){  fitflags |= YGORFIT::DIM3;
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Cannot handle dimensions other than 2 [f(x)] or 3 [f(x,y)]. Cannot proceed&quot;</FONT></B>);
    }
    fitflags |= YGORFIT::LSS;
    fitflags |= YGORFIT::NON_CONVERG_IS_ERR;  <I><FONT COLOR="#B22222">//We want to ensure our stats aren't messed up by default params.
</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> Ygor_Fit_Bootstrap_Driver(wasOK,f,data,vars,fitflags,N,char_len,max_iters,ftol);
}

std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;
<B><FONT COLOR="#0000FF">Ygor_Fit_Bootstrap_LMS</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *wasOK,
             <B><FONT COLOR="#228B22">const</FONT></B> std::function&lt;<B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;X, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;Vars)&gt; &amp;f,
             <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;data,  <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;vars, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim, 
             <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N,  <B><FONT COLOR="#228B22">double</FONT></B> char_len,  <B><FONT COLOR="#228B22">int</FONT></B> max_iters, <B><FONT COLOR="#228B22">double</FONT></B> ftol){

    uint32_t fitflags(0);
    <B><FONT COLOR="#A020F0">if</FONT></B>(dim == 2){        fitflags |= YGORFIT::DIM2;
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(dim == 3){  fitflags |= YGORFIT::DIM3;
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Cannot handle dimensions other than 2 [f(x)] or 3 [f(x,y)]. Cannot proceed&quot;</FONT></B>);
    }
    fitflags |= YGORFIT::LMS;
    fitflags |= YGORFIT::NON_CONVERG_IS_ERR;  <I><FONT COLOR="#B22222">//We want to ensure our stats aren't messed up by default params.
</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> Ygor_Fit_Bootstrap_Driver(wasOK,f,data,vars,fitflags,N,char_len,max_iters,ftol);
}



</PRE>
<HR>
<A NAME="file23">
<H1>YgorCONFIGTools.cc 23/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file22">prev</A>][<A HREF="#file24">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorCONFIGTools.cc - A collection of routines for parsing/reading configuration files.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;fstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>

<I><FONT COLOR="#B22222">//#include &lt;regex&gt;   //C++11 support is currently incomplete for regex!
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;boost/regex.hpp&gt;</FONT></B> //Be sure to compile with -lboost_regex using this library.
<B><FONT COLOR="#228B22">const</FONT></B> boost::regex regex_first_non_whitespace_is_pound( R<B><FONT COLOR="#BC8F8F">&quot;***(^[[:blank:]]*#)***&quot;</FONT></B>, boost::regex::perl | boost::regex::icase );
<I><FONT COLOR="#B22222">//const boost::regex regex_contains_a_colon( R&quot;***(:)***&quot;, boost::regex::basic | boost::regex::icase );
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>         //Needed for FUNCINFO/FUNCWARN/FUNCERR macro-functions.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorFilesDirs.h&quot;</FONT></B>    //Needed for Does_File_Exist_And_Can_Be_Read(..)
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B>       //Needed for SplitStringToVector(...), Canonicalize_String(...).

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorCONFIGTools.h&quot;</FONT></B>    


<I><FONT COLOR="#B22222">//A simple config file is one where:
</FONT></I><I><FONT COLOR="#B22222">//  1) Each line is self-contained. There is no positional awareness (at least, no structural awareness.)
</FONT></I><I><FONT COLOR="#B22222">//  2) Each comment line begins with optional whitespace and non-optional '#'. Non-comment lines with a '#' is OK.
</FONT></I><I><FONT COLOR="#B22222">//  3) Each line is tokenized on some character (typically ':'.)
</FONT></I>std::vector&lt;std::vector&lt;std::string&gt;&gt; Tokenize_Simple_Config_File(std::string filename_in, std::string linetoken){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;std::string&gt;&gt; out;

    <I><FONT COLOR="#B22222">//Check if the file exists AND can be read. If it cannot, send out an empty vector.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( !Does_File_Exist_And_Can_Be_Read(filename_in) ) <B><FONT COLOR="#A020F0">return</FONT></B> out;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::fstream FI(filename_in.c_str(), std::ifstream::in);

    <I><FONT COLOR="#B22222">//Set up the regex we will need.
</FONT></I>    <I><FONT COLOR="#B22222">//const boost::regex regex_first_non_whitespace_is_pound( R&quot;***(^[[:blank:]]*#)***&quot;, boost::regex::perl | boost::regex::icase );
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> boost::regex regex_contains_a_linetoken( linetoken, boost::regex::basic | boost::regex::icase );
  
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string rawline;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; tokenizedline;
    <B><FONT COLOR="#A020F0">while</FONT></B>(!((getline(FI,rawline)).eof()) || !rawline.empty()){
        <B><FONT COLOR="#A020F0">if</FONT></B>( boost::regex_search(rawline, regex_first_non_whitespace_is_pound)){ <I><FONT COLOR="#B22222">//If the first non-whitespace character is #, then ignore.
</FONT></I>            rawline.clear();
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
<I><FONT COLOR="#B22222">//        if(  boost::regex_search(rawline, regex_first_non_whitespace_is_pound) ) continue;   //If the first non-whitespace character is #, then ignore.
</FONT></I><I><FONT COLOR="#B22222">//        if( !boost::regex_search(rawline, regex_contains_a_linetoken) ) continue;            //If the line does not contain :, then ignore.
</FONT></I>        <I><FONT COLOR="#B22222">//Split the line on the given linetoken.
</FONT></I>        tokenizedline = SplitStringToVector(rawline, linetoken, <B><FONT COLOR="#BC8F8F">'d'</FONT></B>);  <I><FONT COLOR="#B22222">//'d' for &quot;drop the delimiter.&quot;
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = tokenizedline.begin(); s_it != tokenizedline.end(); ++s_it){
            <I><FONT COLOR="#B22222">//Chomp off extra whitespace (all from front, all from back, shorten whitespace within to a single space.)
</FONT></I>            Canonicalize_String(*s_it, CANONICALIZE::TRIM);
        }

        <I><FONT COLOR="#B22222">//Push back the strings.
</FONT></I>        out.push_back( tokenizedline );
        rawline.clear();
    }
    FI.close();
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Config_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;inmem, std::string filename, std::string linetoken){
    <B><FONT COLOR="#228B22">const</FONT></B> std::string serialized = Serialize_Simple_Config_File( inmem, linetoken );
    <B><FONT COLOR="#A020F0">return</FONT></B> WriteStringToFile(serialized, filename);
}

<I><FONT COLOR="#B22222">//This function will take an in-memory config file and will serialize it. This is useful for, say, transmitting across a network.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Although the output is a serial, single string, the string will still contain newlines and other structural characters.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: In the output, lines are separated by newlines, as they are on file.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The data will be treated as text. No compression or binary serialization is performed.
</FONT></I>std::string Serialize_Simple_Config_File(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;deserialized, std::string linetoken){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> ds_it = deserialized.begin(); ds_it != deserialized.end(); ++ds_it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(ds_it-&gt;size() != 0){
            <I><FONT COLOR="#B22222">//We know there is at least one item on this line.
</FONT></I>            out += *(ds_it-&gt;begin());
            <I><FONT COLOR="#B22222">//Dump each additional item on this line. Each comes with a preceeding linetoken.
</FONT></I>            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> l_it = ++(ds_it-&gt;begin()); l_it != ds_it-&gt;end(); ++l_it){
                out += linetoken;
                out += *l_it;
            }
            <I><FONT COLOR="#B22222">//Indicate the line ending.
</FONT></I>            out += <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::vector&lt;std::vector&lt;std::string&gt;&gt; Deserialize_Simple_Config_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;serialized, std::string linetoken){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;std::string&gt;&gt; out;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss(serialized);

    <I><FONT COLOR="#B22222">//Set up the regex we will need.
</FONT></I>    <I><FONT COLOR="#B22222">//const boost::regex regex_first_non_whitespace_is_pound( R&quot;***(^[[:blank:]]*#)***&quot;, boost::regex::perl | boost::regex::icase );
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> boost::regex regex_contains_a_linetoken( linetoken, boost::regex::basic | boost::regex::icase );
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string rawline;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; tokenizedline;
    <B><FONT COLOR="#A020F0">while</FONT></B>(!((getline(ss,rawline)).eof()) || !rawline.empty()){
        <B><FONT COLOR="#A020F0">if</FONT></B>( boost::regex_search(rawline, regex_first_non_whitespace_is_pound)){ <I><FONT COLOR="#B22222">//If the first non-whitespace character is #, then ignore.
</FONT></I>            rawline.clear();
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
<I><FONT COLOR="#B22222">//        if( !boost::regex_search(rawline, regex_contains_a_linetoken) ) continue;          //If the line does not contain the linetoken, then ignore.
</FONT></I>        <I><FONT COLOR="#B22222">//Split the line on the given linetoken.
</FONT></I>        tokenizedline = SplitStringToVector(rawline, linetoken, <B><FONT COLOR="#BC8F8F">'d'</FONT></B>);  <I><FONT COLOR="#B22222">//'d' for &quot;drop the delimiter.&quot;
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = tokenizedline.begin(); s_it != tokenizedline.end(); ++s_it){
            <I><FONT COLOR="#B22222">//Chomp off extra whitespace (all from front, all from back, shorten whitespace within to a single space.)
</FONT></I>            Canonicalize_String(*s_it, CANONICALIZE::TRIM);
        }
        <I><FONT COLOR="#B22222">//Push back the strings.
</FONT></I>        out.push_back(tokenizedline);
        rawline.clear();
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//This function will take an in-memory config file and will serialize it twice, producing a truly-serial output (no newlines.)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//This is useful for dumping from one program to another (i.e. using std::cin to collect a serialized config file as a single input.)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine cannot handle content which contains newlines!
</FONT></I>std::vector&lt;std::vector&lt;std::string&gt;&gt; Double_Deserialize_Simple_Config_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;serialized, std::string separator, std::string linetoken){
    <B><FONT COLOR="#A020F0">if</FONT></B>(separator == linetoken) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;This function requires a different separator than the linetoken&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> serial = ReplaceAllInstances(serialized, linetoken, R<B><FONT COLOR="#BC8F8F">&quot;***(\n)***&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> Deserialize_Simple_Config_File(serial, separator);
}

std::string Double_Serialize_Simple_Config_File(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;deserialized, std::string separator, std::string linetoken){
    <B><FONT COLOR="#A020F0">if</FONT></B>(separator == linetoken) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;This function requires a different separator than the linetoken&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> r_it = deserialized.begin(); r_it != deserialized.end(); ++r_it){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = r_it-&gt;begin(); c_it != r_it-&gt;end(); ++c_it){
            <B><FONT COLOR="#A020F0">if</FONT></B>(c_it-&gt;find(<B><FONT COLOR="#BC8F8F">'\n'</FONT></B>) != std::string::npos) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;This routine cannot handle content which contains newlines. Please encode or remove them before calling this function&quot;</FONT></B>);
        }
    }
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> serial = Serialize_Simple_Config_File(deserialized, separator); <I><FONT COLOR="#B22222">//Still contains newlines.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> ReplaceAllInstances(serial, R<B><FONT COLOR="#BC8F8F">&quot;***(\n)***&quot;</FONT></B>, linetoken);
}



<I><FONT COLOR="#B22222">//Operations on in-memory configs. The burden is on the user to ensure the proper method is used for the config.
</FONT></I><I><FONT COLOR="#B22222">// For instance, some routines assume a simple 'a = b' format. Using these on a 'a = b = c' format, for instance,
</FONT></I><I><FONT COLOR="#B22222">// may produce unreliable output.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">YgorCONFIGTools_Is_X_Present_on_Leftmost</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;conf, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;X){
    <I><FONT COLOR="#B22222">//This function assumes very little. It should work on any config file. 
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//If the given string X is present on any leftmost line, we return 'true'. If it cannot be found, we return 'false.'
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: The string comparison is exact and is whitespace, case, etc.. dependant.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> conf_it = conf.begin(); conf_it != conf.end(); ++conf_it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(conf_it-&gt;size() != 0){
            <B><FONT COLOR="#A020F0">if</FONT></B>(X == *(conf_it-&gt;begin())) <B><FONT COLOR="#A020F0">return</FONT></B> true;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

std::string YgorCONFIGTools_Given_X_Get_First_B_When_XB(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;conf, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;X){
    <I><FONT COLOR="#B22222">//This function only looks at the first two items of a line. Lines with less items are ignored. Lines with more are
</FONT></I>    <I><FONT COLOR="#B22222">// treated as though they only have two items (the rest of the line is ignored.)
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//If the given string X is present on any leftmost line, we return the second item. If it cannot be found, we return an
</FONT></I>    <I><FONT COLOR="#B22222">// empty string.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: The string comparison is exact and is whitespace, case, etc.. dependant.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> conf_it = conf.begin(); conf_it != conf.end(); ++conf_it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(conf_it-&gt;size() &gt; 1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(X == *(conf_it-&gt;begin())) <B><FONT COLOR="#A020F0">return</FONT></B> *(++(conf_it-&gt;begin()));
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::string();
}



std::vector&lt;std::vector&lt;std::string&gt;&gt; YgorCONFIGTools_Get_All_Lines_With_X_Present_on_Leftmost(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;conf, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;X){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;std::string&gt;&gt; out;

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> l_it = conf.begin(); l_it != conf.end(); ++l_it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(l_it-&gt;size() != 0){
            <B><FONT COLOR="#A020F0">if</FONT></B>(X == *(l_it-&gt;begin())) out.push_back( *l_it );
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

</PRE>
<HR>
<A NAME="file24">
<H1>YgorContainers.cc 24/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file23">prev</A>][<A HREF="#file25">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorContainers.cc.
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>    //Needed for std::sort(..).
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorContainers.h&quot;</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    #define YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------ internal template helpers -------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//These are helper templates used for type deduction for use *within this file.*
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//How they work: we define a base struct for each data type we want to use. We make the default template contain a false bool.
</FONT></I><I><FONT COLOR="#B22222">// Then, we define a template specialization *specifically* for that type that has a true bool. Therefore, inspection of the 
</FONT></I><I><FONT COLOR="#B22222">// bool value will tell use whether or not the type is what we asked for. 
</FONT></I><I><FONT COLOR="#B22222">//template&lt;class T&gt; struct IS_THIS_OF_TYPE_LONG_INT {     static const bool value = false;   };
</FONT></I><I><FONT COLOR="#B22222">//template&lt;&gt;        struct IS_THIS_OF_TYPE_LONG_INT&lt;long int&gt; {  static const bool value = true; };
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//template&lt;class T&gt; struct IS_THIS_OF_TYPE_STD_STRING {     static const bool value = false;   };
</FONT></I><I><FONT COLOR="#B22222">//template&lt;&gt;        struct IS_THIS_OF_TYPE_STD_STRING&lt;std::string&gt; {  static const bool value = true; };
</FONT></I><I><FONT COLOR="#B22222">//THESE ARE NOT USED - They are here for reference!
</FONT></I><I><FONT COLOR="#B22222">// Use like:
</FONT></I><I><FONT COLOR="#B22222">// if( IS_THIS_OF_TYPE_LONG_INT&lt;T&gt;::value ) 
</FONT></I><I><FONT COLOR="#B22222">// or
</FONT></I><I><FONT COLOR="#B22222">// if( IS_THIS_OF_TYPE_LONG_INT&lt; decltype(rhs) &gt;::value )
</FONT></I>
<I><FONT COLOR="#B22222">//---- Are two types equal? ----   (ala boost::is_same(..)  and adapted from
</FONT></I><I><FONT COLOR="#B22222">//  http://stackoverflow.com/questions/1708867/check-type-of-element-in-stl-container-c .
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> UA, <B><FONT COLOR="#228B22">class</FONT></B> UB&gt; <B><FONT COLOR="#228B22">struct</FONT></B> ARE_THESE_TYPES_EQUAL      { <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> value = false; };
<I><FONT COLOR="#B22222">//Specialization for the case when UA == UB.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> U&gt;            <B><FONT COLOR="#228B22">struct</FONT></B> ARE_THESE_TYPES_EQUAL&lt;U,U&gt; { <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> value = true;  };



<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------- bimap -------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------------------------------
</FONT></I>

<I><FONT COLOR="#B22222">//----------------------------------------------------- Constructors ---------------------------------------------------------
</FONT></I>
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;  bimap&lt;TA,TB&gt;::bimap() { }

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, std::string&gt;::bimap();
    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;std::string, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::bimap();

    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>, std::string&gt;::bimap();
    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;std::string, <B><FONT COLOR="#228B22">float</FONT></B>&gt;::bimap();
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//--------------------------------------------------- Member functions -------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;  TA &amp; bimap&lt;TA,TB&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>[](<B><FONT COLOR="#228B22">const</FONT></B> TB &amp;in){
    <I><FONT COLOR="#B22222">//First, we have to check if the element exists yet. If it does, we return a reference to the corresponding element.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> iter = (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.begin(); iter != (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.end(); ++iter){
        <B><FONT COLOR="#A020F0">if</FONT></B>((*iter).second == in) <B><FONT COLOR="#A020F0">return</FONT></B> ((*iter).first);
    }
    <I><FONT COLOR="#B22222">//If the element did not exist, we create a new element and push out a reference to the corresponding element.
</FONT></I>    (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.push_back( std::pair&lt;TA,TB&gt;( TA(), in ) ); <I><FONT COLOR="#B22222">//Default instantiation.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> ((*(--((*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.end()))).first); <I><FONT COLOR="#B22222">//Return a reference to the last element.
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp;  bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, std::string&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>[](<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string &amp;  bimap&lt;std::string, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>[](<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp;in);

    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;  bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>, std::string&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>[](<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string &amp;  bimap&lt;std::string, <B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>[](<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This is a mirror reflection of the previous operator. We need to ensure that both functions are not instantiated
</FONT></I><I><FONT COLOR="#B22222">// when TA == TB.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;  TB &amp; bimap&lt;TA,TB&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>[](<B><FONT COLOR="#228B22">const</FONT></B> TA &amp;in){
    <I><FONT COLOR="#B22222">//First, we have to check if the element exists yet. If it does, we return a reference to the corresponding element.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> iter = (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.begin(); iter != (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.end(); ++iter){
        <B><FONT COLOR="#A020F0">if</FONT></B>((*iter).first == in) <B><FONT COLOR="#A020F0">return</FONT></B> ((*iter).second);
    }
    <I><FONT COLOR="#B22222">//If the element did not exist, we create a new element and push out a reference to the corresponding element.
</FONT></I>    (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.push_back( std::pair&lt;TA,TB&gt;( in, TB() ) ); <I><FONT COLOR="#B22222">//Default instantiation.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> ((*(--((*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.end()))).second); <I><FONT COLOR="#B22222">//Return a reference to the last element.
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::string &amp;  bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, std::string&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>[](<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp;in);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp;  bimap&lt;std::string, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>[](<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);

    <B><FONT COLOR="#228B22">template</FONT></B> std::string &amp;  bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>, std::string&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>[](<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;in);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;  bimap&lt;std::string, <B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>[](<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;    bimap&lt;TA,TB&gt; &amp; bimap&lt;TA,TB&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;TA,TB&gt; &amp;rhs) {
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;the_pairs.clear();
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = rhs.begin(); it != rhs.end(); ++it){
        (*<B><FONT COLOR="#A020F0">this</FONT></B>)[it-&gt;first] = it-&gt;second;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, std::string&gt; &amp;  bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, std::string&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, std::string&gt; &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;std::string, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;  bimap&lt;std::string, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;std::string, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;);

    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>, std::string&gt; &amp;  bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>, std::string&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;<B><FONT COLOR="#228B22">float</FONT></B>, std::string&gt; &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;std::string, <B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;  bimap&lt;std::string, <B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;std::string, <B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;    bimap&lt;TA,TB&gt; &amp; bimap&lt;TA,TB&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;TB,TA&gt; &amp;rhs) {
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;the_pairs.clear();
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = rhs.begin(); it != rhs.end(); ++it){
        (*<B><FONT COLOR="#A020F0">this</FONT></B>)[it-&gt;first] = it-&gt;second;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, std::string&gt; &amp;  bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, std::string&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;std::string, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;std::string, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;  bimap&lt;std::string, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, std::string&gt; &amp;);

    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>, std::string&gt; &amp;  bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>, std::string&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;std::string, <B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> bimap&lt;std::string, <B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;  bimap&lt;std::string, <B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;<B><FONT COLOR="#228B22">float</FONT></B>, std::string&gt; &amp;);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;   typename std::vector&lt;std::pair&lt;TA,TB&gt; &gt;::const_iterator  bimap&lt;TA,TB&gt;::begin(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.begin();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt; &gt;::const_iterator   bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::begin(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt;::const_iterator   bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::begin(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;

    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt; &gt;::const_iterator   bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::begin(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt;::const_iterator   bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::begin(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;   typename std::vector&lt;std::pair&lt;TA,TB&gt; &gt;::const_reverse_iterator  bimap&lt;TA,TB&gt;::rbegin(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.rbegin();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt; &gt;::const_reverse_iterator   bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::rbegin(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt;::const_reverse_iterator   bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::rbegin(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;

    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt; &gt;::const_reverse_iterator   bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::rbegin(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt;::const_reverse_iterator   bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::rbegin(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;   typename std::vector&lt;std::pair&lt;TA,TB&gt; &gt;::const_iterator  bimap&lt;TA,TB&gt;::end(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.end();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt; &gt;::const_iterator   bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::end(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt;::const_iterator   bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::end(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;

    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt; &gt;::const_iterator   bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::end(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt;::const_iterator   bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::end(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;   typename std::vector&lt;std::pair&lt;TA,TB&gt; &gt;::const_reverse_iterator  bimap&lt;TA,TB&gt;::rend(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.rend();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt; &gt;::const_reverse_iterator   bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::rend(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt;::const_reverse_iterator   bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::rend(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;

    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt; &gt;::const_reverse_iterator   bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::rend(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt;::const_reverse_iterator   bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::rend(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;   typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_iterator  bimap&lt;TA,TB&gt;::find( <B><FONT COLOR="#228B22">const</FONT></B> TA &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//We simply run through the elements to see if there is a corresponding element.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> iter = (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.begin(); iter != (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.end(); ++iter){
        <B><FONT COLOR="#A020F0">if</FONT></B>((*iter).first == in) <B><FONT COLOR="#A020F0">return</FONT></B> iter;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.end();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::find( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::find( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;

    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::find( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::find( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;   typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_iterator  bimap&lt;TA,TB&gt;::find( <B><FONT COLOR="#228B22">const</FONT></B> TB &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//We simply run through the elements to see if there is a corresponding element.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> iter = (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.begin(); iter != (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.end(); ++iter){
        <B><FONT COLOR="#A020F0">if</FONT></B>((*iter).second == in) <B><FONT COLOR="#A020F0">return</FONT></B> iter;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> (*<B><FONT COLOR="#A020F0">this</FONT></B>).the_pairs.end();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::find( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::find( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;

    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::find( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B>  std::vector&lt;std::pair&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::find( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>



<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt; <B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_iterator  bimap&lt;TA,TB&gt;::after( <B><FONT COLOR="#228B22">const</FONT></B> T &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//First, we determine if the element passed in exists.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> it = (*<B><FONT COLOR="#A020F0">this</FONT></B>).find(in);
    <B><FONT COLOR="#A020F0">if</FONT></B>( it == (*<B><FONT COLOR="#A020F0">this</FONT></B>).end() ) <B><FONT COLOR="#A020F0">return</FONT></B> it; <I><FONT COLOR="#B22222">//Return the not-found signal.
</FONT></I>    <I><FONT COLOR="#B22222">//If the element did exist, we iterate it appropriately.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( (++it) == (*<B><FONT COLOR="#A020F0">this</FONT></B>).end() ) <B><FONT COLOR="#A020F0">return</FONT></B> (*<B><FONT COLOR="#A020F0">this</FONT></B>).begin();  <I><FONT COLOR="#B22222">//Cyclic treatment!
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> it;
} 
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::after( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::after( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::after( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::after( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;

    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::after( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::after( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::after( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::after( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

 

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt; <B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  typename std::vector&lt; std::pair&lt;TA,TB&gt; &gt;::const_iterator  bimap&lt;TA,TB&gt;::before( <B><FONT COLOR="#228B22">const</FONT></B> T &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//First, we determine if the element passed in exists.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> it = (*<B><FONT COLOR="#A020F0">this</FONT></B>).find(in);
    <B><FONT COLOR="#A020F0">if</FONT></B>( it == (*<B><FONT COLOR="#A020F0">this</FONT></B>).end() ) <B><FONT COLOR="#A020F0">return</FONT></B> it; <I><FONT COLOR="#B22222">//Return the not-found signal.
</FONT></I>    <I><FONT COLOR="#B22222">//If the element did exist, we iterate it appropriately.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( it == (*<B><FONT COLOR="#A020F0">this</FONT></B>).begin() ) <B><FONT COLOR="#A020F0">return</FONT></B> --((*<B><FONT COLOR="#A020F0">this</FONT></B>).end());
    <B><FONT COLOR="#A020F0">return</FONT></B> (--it);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::before( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::before( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::before( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::before( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;

    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::before( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt; &gt;::const_iterator bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::before( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::before( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt; std::pair&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt;::const_iterator bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::before( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt; <B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; T bimap&lt;TA,TB&gt;::get_next( <B><FONT COLOR="#228B22">const</FONT></B> T &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//First, we take the given value and attempt to get an iterator to the element after it (cyclically.)
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;after(in);
    <B><FONT COLOR="#A020F0">if</FONT></B>( it == <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;end() ) <B><FONT COLOR="#A020F0">return</FONT></B> in;  <I><FONT COLOR="#B22222">//Simply return the value given.    Maybe we should throw an exception instead??
</FONT></I>
    <I><FONT COLOR="#B22222">//Now some tricky footwork. To keep this function general, we cannot indicate the .first or .second parts explicitly.
</FONT></I>    <I><FONT COLOR="#B22222">// Instead, we use type checking. Do not be frightened by the casts - the types are required to be identical!
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( ARE_THESE_TYPES_EQUAL&lt;TA,T&gt;::value ){
        <B><FONT COLOR="#A020F0">return</FONT></B> *(reinterpret_cast&lt;<B><FONT COLOR="#228B22">const</FONT></B> T*&gt;( &amp;(it-&gt;first) ));
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( ARE_THESE_TYPES_EQUAL&lt;TB,T&gt;::value ){
        <B><FONT COLOR="#A020F0">return</FONT></B> *(reinterpret_cast&lt;<B><FONT COLOR="#228B22">const</FONT></B> T*&gt;( &amp;(it-&gt;second) ));  
    }
    FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Attempted to perform impossible action. Was a wrong type passed to this bimap?&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> in;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::string bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::get_next( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>    bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::get_next( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::string bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::get_next( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>    bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::get_next( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;

    <B><FONT COLOR="#228B22">template</FONT></B> std::string bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::get_next( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>       bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::get_next( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::string bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::get_next( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>       bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::get_next( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt; <B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; T bimap&lt;TA,TB&gt;::get_previous( <B><FONT COLOR="#228B22">const</FONT></B> T &amp;in ) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//First, we take the given value and attempt to get an iterator to the element after it (cyclically.)
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;before(in);
    <B><FONT COLOR="#A020F0">if</FONT></B>( it == <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;end() ) <B><FONT COLOR="#A020F0">return</FONT></B> in;  <I><FONT COLOR="#B22222">//Simply return the value given.    Maybe we should throw an exception instead??
</FONT></I>
    <I><FONT COLOR="#B22222">//Now some tricky footwork. To keep this function general, we cannot indicate the .first or .second parts explicitly.
</FONT></I>    <I><FONT COLOR="#B22222">// Instead, we use type checking. Do not be frightened by the casts - the types are required to be identical!
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( ARE_THESE_TYPES_EQUAL&lt;TA,T&gt;::value ){
        <B><FONT COLOR="#A020F0">return</FONT></B> *(reinterpret_cast&lt;<B><FONT COLOR="#228B22">const</FONT></B> T*&gt;( &amp;((*it).first) ));
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( ARE_THESE_TYPES_EQUAL&lt;TB,T&gt;::value ){
        <B><FONT COLOR="#A020F0">return</FONT></B> *(reinterpret_cast&lt;<B><FONT COLOR="#228B22">const</FONT></B> T*&gt;( &amp;((*it).second) ));
    }
    FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Attempted to perform impossible action. Was a wrong type passed to this bimap?&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> in;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::string bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::get_previous( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::get_previous( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::string bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::get_previous( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::get_previous( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;

    <B><FONT COLOR="#228B22">template</FONT></B> std::string bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::get_previous( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::get_previous( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::string bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::get_previous( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::get_previous( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp; ) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;  <B><FONT COLOR="#228B22">void</FONT></B> bimap&lt;TA,TB&gt;::order_on_first(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#228B22">auto</FONT></B> lessthan = [](<B><FONT COLOR="#228B22">const</FONT></B> std::pair&lt;TA,TB&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> std::pair&lt;TA,TB&gt; &amp;B) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> A.first &lt; B.first;
    };
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::sort(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;the_pairs.begin(), <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;the_pairs.end(), lessthan);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::order_on_first(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::order_on_first(<B><FONT COLOR="#228B22">void</FONT></B>);

    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::order_on_first(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::order_on_first(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> TA, <B><FONT COLOR="#228B22">class</FONT></B> TB&gt;  <B><FONT COLOR="#228B22">void</FONT></B> bimap&lt;TA,TB&gt;::order_on_second(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#228B22">auto</FONT></B> lessthan = [](<B><FONT COLOR="#228B22">const</FONT></B> std::pair&lt;TA,TB&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> std::pair&lt;TA,TB&gt; &amp;B) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> A.second &lt; B.second;
    };
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::sort(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;the_pairs.begin(), <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;the_pairs.end(), lessthan);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORCONTAINERS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,std::string&gt;::order_on_second(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> bimap&lt;std::string,<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;::order_on_second(<B><FONT COLOR="#228B22">void</FONT></B>);

    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> bimap&lt;<B><FONT COLOR="#228B22">float</FONT></B>,std::string&gt;::order_on_second(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> bimap&lt;std::string,<B><FONT COLOR="#228B22">float</FONT></B>&gt;::order_on_second(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

</PRE>
<HR>
<A NAME="file25">
<H1>YgorDICOMTools.cc 25/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file24">prev</A>][<A HREF="#file26">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;memory&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;fstream&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iomanip&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;fstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;map&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;memory&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorFilesDirs.h&quot;</FONT></B>    //Needed for Does_File_Exist_And_Can_Be_Read(..)

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorDICOMTools.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">//Forward declarations.
</FONT></I><B><FONT COLOR="#228B22">union</FONT></B> small;
<B><FONT COLOR="#228B22">union</FONT></B> large;

<B><FONT COLOR="#228B22">class</FONT></B> piece;


<I><FONT COLOR="#B22222">//NOTE: This routine should NOT be used for actually parsing the file - this is designed to 
</FONT></I><I><FONT COLOR="#B22222">// be as quick as possible for simply checking if the file is DICOM or not. See the more appropriate
</FONT></I><I><FONT COLOR="#B22222">// validation routine for an alternative for parsing the file.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Is_File_A_DICOM_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in){
    <B><FONT COLOR="#A020F0">if</FONT></B>( !Does_File_Exist_And_Can_Be_Read(filename_in) ) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <I><FONT COLOR="#B22222">//As far as I can tell, all valid DICOM files have a 128-byte '\0\0\0...' header followed
</FONT></I>    <I><FONT COLOR="#B22222">// by 'DICM'. This is all we will check (at the moment?)
</FONT></I>
    <I><FONT COLOR="#B22222">//Open the file and prepare to read (a part of it) into memory.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::ifstream in(filename_in.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!in.is_open()) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> check_size = 128+4;            <I><FONT COLOR="#B22222">//The amount of bytes we want to read in.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::ifstream::pos_type l_size = in.tellg();  <I><FONT COLOR="#B22222">//Grab the size of the binary file.
</FONT></I>
    <I><FONT COLOR="#B22222">//If the file is smaller than the header, we know immediately it is not DICOM.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( check_size &gt; static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(l_size) ) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;<B><FONT COLOR="#228B22">char</FONT></B>[]&gt; mem ( <B><FONT COLOR="#A020F0">new</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> [check_size] );
<I><FONT COLOR="#B22222">//    mem.reset( new char [check_size] );
</FONT></I>    in.seekg(0, std::ios::beg);                   <I><FONT COLOR="#B22222">//Seek back to the beginning.
</FONT></I>    in.read((<B><FONT COLOR="#228B22">char</FONT></B> *)(mem.get()), check_size);
    in.close();

    <I><FONT COLOR="#B22222">//Now check the contents of the data we've read in.
</FONT></I>    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>( ; i &lt; 128; i++) <B><FONT COLOR="#A020F0">if</FONT></B>(mem[i] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(mem[i++] != <B><FONT COLOR="#BC8F8F">'D'</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(mem[i++] != <B><FONT COLOR="#BC8F8F">'I'</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(mem[i++] != <B><FONT COLOR="#BC8F8F">'C'</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(mem[i]   != <B><FONT COLOR="#BC8F8F">'M'</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <I><FONT COLOR="#B22222">//If we make it here, it is probably the case that 
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}


std::basic_string&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;  Simple_DICOM_Header( <B><FONT COLOR="#228B22">void</FONT></B> ){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::basic_string&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt; out;
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;128; ++i) out += static_cast&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;(<B><FONT COLOR="#BC8F8F">'\0'</FONT></B>);

    out += static_cast&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;(<B><FONT COLOR="#BC8F8F">'D'</FONT></B>);
    out += static_cast&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;(<B><FONT COLOR="#BC8F8F">'I'</FONT></B>);
    out += static_cast&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;(<B><FONT COLOR="#BC8F8F">'C'</FONT></B>);
    out += static_cast&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;(<B><FONT COLOR="#BC8F8F">'M'</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Is_Common_ASCII</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> &amp;in ){     <B><FONT COLOR="#A020F0">return</FONT></B> isininc((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>)(32),in,(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>)(126)); }
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==( <B><FONT COLOR="#228B22">const</FONT></B> large &amp;L, <B><FONT COLOR="#228B22">const</FONT></B> large &amp;R ){   <B><FONT COLOR="#A020F0">return</FONT></B> L.i == R.i;  }
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==( <B><FONT COLOR="#228B22">const</FONT></B> small &amp;L, <B><FONT COLOR="#228B22">const</FONT></B> small &amp;R ){   <B><FONT COLOR="#A020F0">return</FONT></B> L.i == R.i;  }

std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;( std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> large &amp;in ){

    <I><FONT COLOR="#B22222">//Dump as a single four-byte integer.
</FONT></I>    out &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">' '</FONT></B>) &lt;&lt; std::setw(10) &lt;&lt; in.i;

    <I><FONT COLOR="#B22222">//Dump as 4 one-byte integers.
</FONT></I>    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; (&quot;</FONT></B>;
    out &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &lt;&lt; std::setw(3) &lt;&lt; (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(in.c[0]) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B>;
    out &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &lt;&lt; std::setw(3) &lt;&lt; (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(in.c[1]) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B>;
    out &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &lt;&lt; std::setw(3) &lt;&lt; (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(in.c[2]) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B>;
    out &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &lt;&lt; std::setw(3) &lt;&lt; (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(in.c[3]) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;

    <I><FONT COLOR="#B22222">//Dump as 2 two-byte integers (in hex.)
</FONT></I>    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; (&quot;</FONT></B>;
    out &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &lt;&lt; std::setw(4) &lt;&lt; std::hex &lt;&lt; in.s[0].i &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B>;
    out &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &lt;&lt; std::setw(4) &lt;&lt; std::hex &lt;&lt; in.s[1].i &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;

    out &lt;&lt; std::dec;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;( std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> small &amp;in ){

    <I><FONT COLOR="#B22222">//Dump as a single two-byte integer.
</FONT></I>    out &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">' '</FONT></B>) &lt;&lt; std::setw(8) &lt;&lt; in.i;

    <I><FONT COLOR="#B22222">//Dump as 2 one-byte integers.
</FONT></I>    out  &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; (&quot;</FONT></B>;
    out &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &lt;&lt; std::setw(3) &lt;&lt; (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(in.c[0]) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B>;
    out &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &lt;&lt; std::setw(3) &lt;&lt; (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(in.c[1]) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;

    <I><FONT COLOR="#B22222">//Dump as a single two-byte integer (in hex.)
</FONT></I>    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; (&quot;</FONT></B>;
    out &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &lt;&lt; std::setw(4) &lt;&lt; std::hex &lt;&lt; in.i &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;

    out &lt;&lt; std::dec;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;( std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> std::basic_string&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt; &amp;in ){
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t x=0; x&lt;in.size(); ++x) out &lt;&lt; (<B><FONT COLOR="#228B22">char</FONT></B>)(in[x]);
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;( std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> piece &amp;in ){
    <I><FONT COLOR="#B22222">//Print the simple parts.
</FONT></I>    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;A = &quot;</FONT></B> &lt;&lt; in.A &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,  B(first) = &quot;</FONT></B> &lt;&lt; in.B.s[0] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,  B(secnd) = &quot;</FONT></B> &lt;&lt; in.B.s[1];

    <I><FONT COLOR="#B22222">//Print the data.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(in.data.size() != 0){
        out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,  data = \&quot;&quot;</FONT></B>;
        out &lt;&lt; in.data;
        out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//This is a sort of heuristic function - it attempts to 'guess' whether or not the given B denotes (only) the size of a pieces' data.
</FONT></I><I><FONT COLOR="#B22222">// Some elements require an extra 4 bytes (a pseudo 'C' parameter) to denote the size of the accompanying data.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Does_A_B_Not_Denote_A_Size</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> large &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> large &amp;B ){

    <I><FONT COLOR="#B22222">//Special cases with precedent, found via trial and error.
</FONT></I>    <I><FONT COLOR="#B22222">// -&gt; return &quot;false&quot; to force the &quot;B&quot; to be equal to the size of the data.
</FONT></I>    <I><FONT COLOR="#B22222">// -&gt; return &quot;true&quot;  to check (elsewhere) whether the last two bytes of B are the size, or the next four bytes are the size.
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>( A.i == static_cast&lt;uint32_t&gt;(65538)       ) <B><FONT COLOR="#A020F0">return</FONT></B> true;  

    <B><FONT COLOR="#A020F0">if</FONT></B>( A.i == static_cast&lt;uint32_t&gt;(5255174)     ) <B><FONT COLOR="#A020F0">return</FONT></B> false;    <I><FONT COLOR="#B22222">//Original: Found in RS files - I think these exclusively denote stringified contour data ( &quot;1.23/2.34/-5.56/1.24/2.45/...&quot; )  Typically from the 'BODY' contour.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( A.i == static_cast&lt;uint32_t&gt;(3758161918)  ) <B><FONT COLOR="#A020F0">return</FONT></B> false;    <I><FONT COLOR="#B22222">//Original: Found in RS files - I think these are 'elements with a length of data' or something.
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>( A.i == static_cast&lt;uint32_t&gt;(1081312)     ) <B><FONT COLOR="#A020F0">return</FONT></B> false;    <I><FONT COLOR="#B22222">//Found in CT files - Used to denote the image data, I think.
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>( A.i == static_cast&lt;uint32_t&gt;(1191942)     ) <B><FONT COLOR="#A020F0">return</FONT></B> false;    <I><FONT COLOR="#B22222">//Found in RS files - GDCMdump gives &quot;RT Referenced Study Sequence&quot;
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( A.i == static_cast&lt;uint32_t&gt;(4206598)     ) <B><FONT COLOR="#A020F0">return</FONT></B> false;    <I><FONT COLOR="#B22222">//Found in RS files - GDCMdump gives &quot;Contour Sequence&quot;
</FONT></I>

<B><FONT COLOR="#0000FF">if</FONT></B>( A.i == static_cast&lt;uint32_t&gt;(1060870)     ) <B><FONT COLOR="#A020F0">return</FONT></B> false;    <I><FONT COLOR="#B22222">//Found in RS files - GDCMdump gives &quot;Referenced Frame of Reference Sequence&quot;
</FONT></I><B><FONT COLOR="#0000FF">if</FONT></B>( A.i == static_cast&lt;uint32_t&gt;(3747846)     ) <B><FONT COLOR="#A020F0">return</FONT></B> false;    <I><FONT COLOR="#B22222">//Found in RS files - GDCMdump gives &quot;ROI Contour Sequence&quot;
</FONT></I><B><FONT COLOR="#0000FF">if</FONT></B>( A.i == static_cast&lt;uint32_t&gt;(1454086)     ) <B><FONT COLOR="#A020F0">return</FONT></B> false;    <I><FONT COLOR="#B22222">//Found in RS files - GDCMdump gives &quot;Contour Image Sequence&quot;
</FONT></I>
<I><FONT COLOR="#B22222">//Untested - likely matches.
</FONT></I><B><FONT COLOR="#0000FF">if</FONT></B>( A.i == static_cast&lt;uint32_t&gt;(1323014)     ) <B><FONT COLOR="#A020F0">return</FONT></B> false;    <I><FONT COLOR="#B22222">//Found in RS files - 3006,0014 
</FONT></I>




    <I><FONT COLOR="#B22222">//General scheme: Do the first two bytes of B look like a two-char identifier? (ie. UL, RS, DE, etc..)
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( Is_Common_ASCII(B.c[0])  &amp;&amp;  Is_Common_ASCII(B.c[1])  ){
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<I><FONT COLOR="#B22222">//This is a sort of heuristic function - it attempts to 'guess' whether or not the given B contains a two-byte 'data length' integer.
</FONT></I><I><FONT COLOR="#B22222">// This is a typical thing for a few elements near the header, but is rarely (if ever?) found in the body of a DICOM file. 
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Do_Last_Two_Bytes_of_B_Denote_A_Size</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> large &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> large &amp;B ){
    <I><FONT COLOR="#B22222">//These items have been found to have the last two bytes of B denote the size of the data.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//This is a whitelist.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( 
        (A.i == static_cast&lt;uint32_t&gt;(2))            <I><FONT COLOR="#B22222">//Original: Determined using RTSTRUCT files.
</FONT></I>        ||
        (A.i == static_cast&lt;uint32_t&gt;(131074))       <I><FONT COLOR="#B22222">//Original: Determined using RTSTRUCT files.
</FONT></I>        ||
        (A.i == static_cast&lt;uint32_t&gt;(196610))       <I><FONT COLOR="#B22222">//Original: Determined using RTSTRUCT files.
</FONT></I>        ||
        (A.i == static_cast&lt;uint32_t&gt;(1048578))      <I><FONT COLOR="#B22222">//Original: Determined using RTSTRUCT files.
</FONT></I>        ||
        (A.i == static_cast&lt;uint32_t&gt;(1179650))      <I><FONT COLOR="#B22222">//Original: Determined using RTSTRUCT files.
</FONT></I>      ) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<I><FONT COLOR="#B22222">//This is a sort of heuristic function - it attempts to 'guess' whether or not the given A and B will be followed by a four byte 
</FONT></I><I><FONT COLOR="#B22222">// 'data length' integer. This is a fairly rare case, it seems.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Do_Next_Four_Bytes_Denote_A_Size</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> large &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> large &amp;B ){
    <I><FONT COLOR="#B22222">//These items have been found to have the next four bytes denote the size of the data.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//This is a whitelist.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(  
        (A.i == static_cast&lt;uint32_t&gt;(65538))        <I><FONT COLOR="#B22222">//Original: Determined using RTSTRUCT files.
</FONT></I><I><FONT COLOR="#B22222">//||
</FONT></I><I><FONT COLOR="#B22222">//(A.i == static_cast&lt;uint32_t&gt;(1081312))
</FONT></I>
      ) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<I><FONT COLOR="#B22222">//This is a sort of heuristic function - it attempts to 'guess' whether or not the given element contains data which should be 
</FONT></I><I><FONT COLOR="#B22222">// expanded into children. Such data either can or cannot: some data is data like &quot;a string&quot; and some contains nested elements.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Can_This_Elements_Data_Be_Delineated</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> piece &amp;in ){
    <B><FONT COLOR="#A020F0">if</FONT></B>(
          <I><FONT COLOR="#B22222">//These are required to be true for any element.   
</FONT></I>          <I><FONT COLOR="#B22222">//
</FONT></I>          <I><FONT COLOR="#B22222">//NOTE: All other logic blocks must &amp;&amp; with this one. 
</FONT></I>            (
<I><FONT COLOR="#B22222">//                (in.data.size() != 0)     //This stops from attempting to expand elements with less than 8 bytes (ie. not enough room for an &quot;A&quot; and a &quot;B&quot;!)
</FONT></I><I><FONT COLOR="#B22222">//            &amp;&amp;
</FONT></I>                (in.data.size() &gt;= 8)     <I><FONT COLOR="#B22222">//This stops from attempting to expand elements with less than 8 bytes (ie. not enough room for an &quot;A&quot; and a &quot;B&quot;!)
</FONT></I>            &amp;&amp;
                (in.child.size() == 0)    <I><FONT COLOR="#B22222">//This means it has already been delineated - we do not want to (possibly over-) write data in this case.
</FONT></I>            )
          <I><FONT COLOR="#B22222">//These are basic filters. We can not whitelist, but we can override elements within this block.
</FONT></I>          <I><FONT COLOR="#B22222">// For example, when A = 3758161918, the first char of the data is NOT common ASCII, but this 
</FONT></I>          <I><FONT COLOR="#B22222">// criteria works well for most other blocks. 
</FONT></I>          &amp;&amp;
            (
                !Is_Common_ASCII(in.data[0])
            ||
                ( in.A.i == static_cast&lt;uint32_t&gt;(3758161918) )
            )
          <I><FONT COLOR="#B22222">//Exceptions.These items *appear* to have valid data, but do not.
</FONT></I>          <I><FONT COLOR="#B22222">//
</FONT></I>          <I><FONT COLOR="#B22222">//NOTE: This is a blacklist!
</FONT></I>          &amp;&amp;
            (
                ( in.A.i != static_cast&lt;uint32_t&gt;(65538) )         <I><FONT COLOR="#B22222">//Original: Found in RTSTRUCT file.
</FONT></I>            &amp;&amp;
                ( in.A.i != static_cast&lt;uint32_t&gt;(2) )             <I><FONT COLOR="#B22222">//Original: Found in RTSTRUCT file.
</FONT></I>            &amp;&amp;
                ( in.A.i != static_cast&lt;uint32_t&gt;(1081312) )       <I><FONT COLOR="#B22222">//Found in CT file -&gt; holds image data.
</FONT></I>            )
      ) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}


<I><FONT COLOR="#B22222">//Given iterators to the loaded file, we attempt to locate the 'DICM' where we expect it.
</FONT></I><I><FONT COLOR="#B22222">// If it is found, an iterator to the memory immediately after the 'DICM' is returned, otherwise
</FONT></I><I><FONT COLOR="#B22222">// we simply return end.
</FONT></I><B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> * <B><FONT COLOR="#0000FF">Validate_DICOM_Format</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *begin, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *end){
    <I><FONT COLOR="#B22222">//If the memory is too small, we couldn't possibly find it.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( std::distance(begin, end) &lt; 4 ) <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *)(end);

    large shuttle;

    <I><FONT COLOR="#B22222">//We continually read until we have read 4 consecutive non-\0 characters. Check that they are 'DICM'. 
</FONT></I>    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *space = (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *)(begin)+4, *dummy;
    large target;     target.c[0] = <B><FONT COLOR="#BC8F8F">'D'</FONT></B>;     target.c[1] = <B><FONT COLOR="#BC8F8F">'I'</FONT></B>;     target.c[2] = <B><FONT COLOR="#BC8F8F">'C'</FONT></B>;     target.c[3] = <B><FONT COLOR="#BC8F8F">'M'</FONT></B>;
    <B><FONT COLOR="#A020F0">for</FONT></B>( ; space != end; space++){
        dummy = space - 4;
        shuttle.c[0] = *(dummy++);
        shuttle.c[1] = *(dummy++);
        shuttle.c[2] = *(dummy++);
        shuttle.c[3] = *(dummy);

        <B><FONT COLOR="#A020F0">if</FONT></B>( (shuttle.c[0] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) &amp;&amp; (shuttle.c[1] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) &amp;&amp; (shuttle.c[2] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) &amp;&amp; (shuttle.c[3] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(shuttle.i == target.i){
                <I><FONT COLOR="#B22222">//Found it!
</FONT></I>                <B><FONT COLOR="#A020F0">return</FONT></B> space;
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                <I><FONT COLOR="#B22222">//Reaching this point may not be considered a failure - there may be 'noise' prior to reaching the 'DICM', but this
</FONT></I>                <I><FONT COLOR="#B22222">// assumes that there is nothing in the file (other that \0's) prior to the 'DICM'.
</FONT></I>                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to find 'DICM' in the memory region supplied&quot;</FONT></B>);
                <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *)(end);
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *)(end);
}


<I><FONT COLOR="#B22222">//Breaks a piece of memory into a sequence of 'pieces' (which are specific to the DICOM RTSTRUCT format.)
</FONT></I><I><FONT COLOR="#B22222">// The region of memory is not directly passed in, but rather is passed in via ~iterators to the beginning 
</FONT></I><I><FONT COLOR="#B22222">// and end of the memory block.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The data passed to this routine *needs* to be free of the 'DICM' magic file number.
</FONT></I>std::vector&lt;piece&gt; Parse_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *begin, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *end){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;piece&gt; out;

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::basic_string&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt; buff; <I><FONT COLOR="#B22222">//Stores temporary data.
</FONT></I>    large shuttle;

    <I><FONT COLOR="#B22222">//We do a read-interpret-read_data loop until we are at the end.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> i = begin;
    <B><FONT COLOR="#A020F0">while</FONT></B>(i &lt; end){
        piece outgoing;

        <I><FONT COLOR="#B22222">//Clear our storage from last time.
</FONT></I>        buff.clear();
 
        <I><FONT COLOR="#B22222">//Read in four bytes. This is the identifier for whatever we are about to read.
</FONT></I>        shuttle.c[0] = *(i++);  shuttle.c[1] = *(i++); shuttle.c[2] = *(i++);  shuttle.c[3] = *(i++);
        outgoing.A = shuttle;

        <I><FONT COLOR="#B22222">//Read in the next four bytes. Do so two at a time. These vary in interpretation.
</FONT></I>        shuttle.c[0] = *(i++);  shuttle.c[1] = *(i++); shuttle.c[2] = *(i++);  shuttle.c[3] = *(i++);
        outgoing.B = shuttle;

        <I><FONT COLOR="#B22222">//We now determine whether there is any data associated with this item or not. Some items *appear* to have data associated
</FONT></I>        <I><FONT COLOR="#B22222">// with them, but in fact do not. Such an item is the 'UL' item (File Meta Information Group Length.)
</FONT></I>        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> amount = 0; 

        <I><FONT COLOR="#B22222">//This criteria is a very brittle part of this program. It tries to guess which data needs to be delineated and
</FONT></I>        <I><FONT COLOR="#B22222">// broken into children. It uses heuristics which are built by patching previously encountered warnings and failures!
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">//There are three OBSERVED possibilities here:
</FONT></I>        <I><FONT COLOR="#B22222">// 1) The size is all 4 bytes of B (most common, espescially after the first few items near the header (compatability mode or something?) )
</FONT></I>        <I><FONT COLOR="#B22222">// 2) The last two bytes of B denote the size. I've only seen this for a handful of elements, so I've used a whitelist function for it.
</FONT></I>        <I><FONT COLOR="#B22222">// 3) The next 4 bytes (not yet read) must contain the size. This is the most rare. As far as I know, only one element does this
</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B>( Does_A_B_Not_Denote_A_Size( outgoing.A, outgoing.B ) ){
            <I><FONT COLOR="#B22222">//Now there are TWO OBSERVED possibilities:
</FONT></I>            <I><FONT COLOR="#B22222">// 2) the last two bytes of B denote the size.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>( Do_Last_Two_Bytes_of_B_Denote_A_Size( outgoing.A, outgoing.B ) ){
                <I><FONT COLOR="#B22222">//Grab the size from the last two bytes.
</FONT></I>                amount = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(outgoing.B.s[1].i);

            <I><FONT COLOR="#B22222">// 3) the next 4 bytes (not yet read) must contain the size.
</FONT></I>            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( Do_Next_Four_Bytes_Denote_A_Size( outgoing.A, outgoing.B ) ){
                <I><FONT COLOR="#B22222">//Read ahead 4 more bytes to get the size.
</FONT></I>                shuttle.c[0] = *(i++);  shuttle.c[1] = *(i++); shuttle.c[2] = *(i++);  shuttle.c[3] = *(i++);
                amount = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(shuttle.i);

            <I><FONT COLOR="#B22222">// The OTHER possibility - we encounter an element which may need to be whitelisted as either of the THREE above possibilities!
</FONT></I>            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Encountered an item which we have not previously encountered: A = &quot;</FONT></B> &lt;&lt; outgoing.A &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; and B = &quot;</FONT></B> &lt;&lt; outgoing.B &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;.&quot;</FONT></B>);
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;  Please determine how to read the element and add it to the appropriate whitelist function.&quot;</FONT></B>);
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;  Guessing how the item should be treated. Search the source for tag [ WWWW1 ] for more info.&quot;</FONT></B>);

                <I><FONT COLOR="#B22222">//NOTE: The below code is a poor attempt at GUESSING how the item works. Expect errors. It is not necessarily (likely) how the item should be treated.
</FONT></I>                <I><FONT COLOR="#B22222">//Attempt to &quot;guess&quot; the second probability, because it seems like a more common channel.. The appropriate whitelist in this case is Do_Last_Two_Bytes_of_B_Denote_A_Size(...)
</FONT></I>                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;  If no additional warnings/errors are encountered, consider adding this item to the appropriate whitelist (and then test it!)&quot;</FONT></B>);
                amount = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(outgoing.B.s[1].i);
            }

        <I><FONT COLOR="#B22222">//Otherwise the entire 4 bytes denote the number of bytes to read in.
</FONT></I>        <I><FONT COLOR="#B22222">// This is case 1).
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            amount = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(shuttle.i);
        }

        <I><FONT COLOR="#B22222">//Perform a sanity check - is there enough data left to make this data sane?
</FONT></I>        <I><FONT COLOR="#B22222">// If there is not, it is *not* safe to continue processing data. We *have* to return (with a warning.)
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> total_remaining_space = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;( std::distance(i,end) );
        <B><FONT COLOR="#A020F0">if</FONT></B>( total_remaining_space &lt; amount ){
            FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;We have interpreted an instruction to read memory of capacity beyond what we have loaded into memory during parsing. This _may_ or _may not_ be an error&quot;</FONT></B>);
            FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;  NOTE: The heuristic we use to 'guess' the proper size to load in can get snagged on elements with a large size. Try whitelisting the A value in the various whitelists&quot;</FONT></B>);
            FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;  NOTE: This element had A = &quot;</FONT></B> &lt;&lt; outgoing.A &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; and B = &quot;</FONT></B> &lt;&lt; outgoing.B &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;. We have attempted to read &quot;</FONT></B> &lt;&lt; amount &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; bytes when there was  &quot;</FONT></B> &lt;&lt; total_remaining_space &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; space remaining&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> out;
        }

        outgoing.data_size = amount;

        <I><FONT COLOR="#B22222">//If there is data to be read in, do so.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;amount; ++j){
            buff.push_back( *(i++) );
        }

        outgoing.data = buff;

        out.push_back(outgoing);
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<I><FONT COLOR="#B22222">//This routine walks over a chunk of de-lineated data and de-lineates all children data streams.
</FONT></I><I><FONT COLOR="#B22222">// It is called recursively until all elements have been delineated.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Delineate_Children</FONT></B>(std::vector&lt;piece&gt; &amp;in){
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;in.size(); ++i){
        <I><FONT COLOR="#B22222">//If there is data in the string buffer, and there is not already a child node, and the data *appears*
</FONT></I>        <I><FONT COLOR="#B22222">// to be able to be expanded, then we attempt to do so.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( Can_This_Elements_Data_Be_Delineated( in[i] ) ){
            in[i].child = Parse_Binary_File(  in[i].data.c_str(), in[i].data.c_str() + in[i].data.size() );

            <I><FONT COLOR="#B22222">//Now call this routine with the recently created data.
</FONT></I>            Delineate_Children( in[i].child );

        <I><FONT COLOR="#B22222">//Otherwise, if there is already a child, then check it.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( (in[i].child.size() != 0) ){
            Delineate_Children( in[i].child );

        <I><FONT COLOR="#B22222">//Otherwise, this element has no data to process, has no attached nodes, and is fully expanded.
</FONT></I>        <I><FONT COLOR="#B22222">//Simply move on to the next element.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}


<I><FONT COLOR="#B22222">//Dumps the entire vector, recursively dumping all children when they are encountered. Prefixes the data
</FONT></I><I><FONT COLOR="#B22222">// with spaces to denote the depth of the node.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Dump_Children</FONT></B>(std::ostream &amp; out, <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;piece&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string space){ <I><FONT COLOR="#B22222">//NOTE: space defaults to &quot;&quot;
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;in.size(); ++i){
        <I><FONT COLOR="#B22222">//Print out the identity of this piece. If there is no child node, print the data.
</FONT></I>        out &lt;&lt; space;
        out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;A = &quot;</FONT></B> &lt;&lt; in[i].A &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;B = &quot;</FONT></B> &lt;&lt; in[i].B &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;S = &quot;</FONT></B> &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">' '</FONT></B>) &lt;&lt; std::setw(9) &lt;&lt; in[i].data_size &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>(in[i].child.size() != 0){
            out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; [HAS_CHILD] &quot;</FONT></B> &lt;&lt; std::endl;
            Dump_Children(out, in[i].child, (space + <B><FONT COLOR="#BC8F8F">&quot;    &quot;</FONT></B>));
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(in[i].data.size() == 0){
            out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; [_NO_DATA_] &quot;</FONT></B> &lt;&lt; std::endl;
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; data = \&quot;&quot;</FONT></B> &lt;&lt; in[i].data  &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B> &lt;&lt; std::endl;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Dump_Children</FONT></B>(std::ostream &amp; out, <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;piece *&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string space){ <I><FONT COLOR="#B22222">//NOTE: space defaults to &quot;&quot;
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;in.size(); ++i) Dump_Children(out, { *(in[i]) } ); <I><FONT COLOR="#B22222">//Vector initializer to turn out of the element.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B>;
}


<I><FONT COLOR="#B22222">//Given a vector of nodes, we cycle through (recursively) and pick out the elements which match the key at a given depth.
</FONT></I><I><FONT COLOR="#B22222">// For instance, if we want to look for the (fictional) element   { 123, 456, 789 } then at depth 0 we look for all elements
</FONT></I><I><FONT COLOR="#B22222">// corresponding to 123, recurse and look for 456, and then recurse and look for 789. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Only the final element(s) are returned. They are NOT embedded at the depth we find them.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Wildcards (&quot;0&quot;) can be at any depth.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: we do not make &quot;in&quot; const because we do not want const pointers to the data - we want it to be mutable!
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Get_Elements</FONT></B>(std::vector&lt;piece *&gt; &amp;out, std::vector&lt;piece&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;uint32_t&gt; &amp;key, <B><FONT COLOR="#228B22">const</FONT></B> uint32_t depth ){ <I><FONT COLOR="#B22222">//NOTE: depth defaults to 0
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;in.size(); ++i){

        <I><FONT COLOR="#B22222">//If we have found a match,
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>((in[i].A.i == key[depth]) || (key[depth] == 0)){

            <I><FONT COLOR="#B22222">//If this is the final element in the key, then we simply collect the piece and move on.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>( (depth + 1) == key.size() ){
                out.push_back( &amp;(in[i]) );

            <I><FONT COLOR="#B22222">//Otherwise, we have to see if the current element has any children nodes. If it does, recurse, otherwise continue.
</FONT></I>            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( in[i].child.size() != 0 ){
                Get_Elements(out, in[i].child, key, depth+1);
            }

        <I><FONT COLOR="#B22222">//Otherwise, just carry on.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <I><FONT COLOR="#B22222">//Do nothing...
</FONT></I>        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}


<I><FONT COLOR="#B22222">//This function strips out data from nodes which have children and resets the &quot;data_size&quot; member to -1.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Prep_Children_For_Recompute_Children_Data_Size</FONT></B>( std::vector&lt;piece&gt; &amp;in ){
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;in.size(); ++i){
        <I><FONT COLOR="#B22222">//NOTE: Do NOT adjust the B parameter here - even if it contains the size info. This will be done when it is needed!
</FONT></I>
        <I><FONT COLOR="#B22222">//Reset the size of each node. This indicates that we need to recompute it.
</FONT></I>        in[i].data_size = -1;

        <I><FONT COLOR="#B22222">//If there are children nodes, we clear the data and recurse.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( in[i].child.size() != 0 ){
            in[i].data.clear();
            Prep_Children_For_Recompute_Children_Data_Size( in[i].child );

        <I><FONT COLOR="#B22222">//If there are not children nodes, we (probably, might?) have data attached. We do nothing.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <I><FONT COLOR="#B22222">//Do nothing...
</FONT></I>        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}


<I><FONT COLOR="#B22222">//This function is used for repacking purposes. It recurses through a vector to give the TOTAL size of all children (including the 
</FONT></I><I><FONT COLOR="#B22222">// A, B, and data parts of each!)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The unit of &quot;size&quot; is bytes.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This size includes the &quot;A&quot; and &quot;B&quot; parts of the children nodes.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The return value of this function will be the total length of the 
</FONT></I><B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">Recompute_Children_Data_Size</FONT></B>( std::vector&lt;piece&gt; &amp;in ){
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> upward = 0;

    <I><FONT COLOR="#B22222">//Cycle through the vector.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;in.size(); ++i){

        <I><FONT COLOR="#B22222">//Check if this node has children. If it does, we recurse and determine the size of all child elements.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( in[i].child.size() != 0 ){
            in[i].data_size = Recompute_Children_Data_Size( in[i].child );

        <I><FONT COLOR="#B22222">//If it does not, we update the local &quot;data_size&quot; element and add it to &quot;upward&quot; along with the additional 8 bytes for this nodes &quot;A&quot; and &quot;B&quot;.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            in[i].data_size = (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(in[i].data.size());
        }

        <I><FONT COLOR="#B22222">//Check if B includes the size of the element. If it does not, then we have to take into account the extra 4 bytes required to append the
</FONT></I>        <I><FONT COLOR="#B22222">// size immediately after B (when we eventually write the data...)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( Does_A_B_Not_Denote_A_Size( in[i].A, in[i].B ) ){

            <I><FONT COLOR="#B22222">//If the last two bytes of B denote the size, we have only 8 bytes of data (no extra size 4 bytes.)
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>( Do_Last_Two_Bytes_of_B_Denote_A_Size( in[i].A, in[i].B ) ){
                upward += in[i].data_size + (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(2*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint32_t));

            <I><FONT COLOR="#B22222">//Otherwise, if we require an extra four bytes then we have to add this to the size of this elements memory footprint. 
</FONT></I>            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( Do_Next_Four_Bytes_Denote_A_Size( in[i].A, in[i].B ) ){
                upward += in[i].data_size + (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(2*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint32_t)) + (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(1*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint32_t));

            <I><FONT COLOR="#B22222">//This is the case where we do not know enough about the tags to tell either way (safely.) Issue a warning and pick a method to try it.
</FONT></I>            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempting to determine the size of the memory layout of an element A = &quot;</FONT></B> &lt;&lt; in[i].A &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; and B = &quot;</FONT></B> &lt;&lt; in[i].B &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; which is unfamiliar (not on a whitelist.)&quot;</FONT></B>);
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;  Please determine how to read the element and add it to the appropriate whitelist function.&quot;</FONT></B>);
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;  Guessing how the item should be treated. Search the source for tag [ WWWW2 ] for more info.&quot;</FONT></B>);

                <I><FONT COLOR="#B22222">//GUESSING that the last two bytes of B denote the size! See ~10 lines above. The appropriate whitelist is Do_Last_Two_Bytes_of_B_Denote_A_Size(...).
</FONT></I>                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;  Guessing a default layout. If this works, please add it to the appropriate whitelist (and test it!)&quot;</FONT></B>);
                upward += in[i].data_size + (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(2*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint32_t));
            }

        <I><FONT COLOR="#B22222">//Otherwise, B denotes the size. We have a simple layout.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            upward += in[i].data_size + (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)(2*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint32_t));
        }

    }
    <B><FONT COLOR="#A020F0">return</FONT></B> upward;

}


<I><FONT COLOR="#B22222">//This function will take a vector of nodes and children and will repack each node. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: In order to fully pack an entire vector, just create a phony node and attach the vector to be its' child.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Repack_Nodes</FONT></B>( <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;piece&gt; &amp;in, std::basic_string&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt; &amp;out ){

    <I><FONT COLOR="#B22222">//Cycle through the vector.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;in.size(); ++i){

        <I><FONT COLOR="#B22222">//Dump the &quot;A&quot; part.
</FONT></I>        out.push_back( in[i].A.c[0] );
        out.push_back( in[i].A.c[1] );
        out.push_back( in[i].A.c[2] );
        out.push_back( in[i].A.c[3] );


        <I><FONT COLOR="#B22222">//Check if B includes the size of the element. If it does not, then we have to take into account the extra 4 bytes required to append the size.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( Does_A_B_Not_Denote_A_Size( in[i].A, in[i].B ) ){

            <I><FONT COLOR="#B22222">//If the last two bytes of B denote the size, then we need to copy part of B and write the size. This is the second-most common scenario, and
</FONT></I>            <I><FONT COLOR="#B22222">// appears to only happen near the header.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>( Do_Last_Two_Bytes_of_B_Denote_A_Size( in[i].A, in[i].B ) ){
                out.push_back( in[i].B.c[0] );
                out.push_back( in[i].B.c[1] );

                small temp;
                temp.i = static_cast&lt;uint16_t&gt;( in[i].data_size );
                out.push_back( temp.c[0] );
                out.push_back( temp.c[1] );


            <I><FONT COLOR="#B22222">//Otherwise, if we require an extra four bytes then we simply copy over the B and then write the size.
</FONT></I>            <I><FONT COLOR="#B22222">// This appears to be very rare, and only happens near the header.
</FONT></I>            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( Do_Next_Four_Bytes_Denote_A_Size( in[i].A, in[i].B ) ){
                out.push_back( in[i].B.c[0] );
                out.push_back( in[i].B.c[1] );
                out.push_back( in[i].B.c[2] );
                out.push_back( in[i].B.c[3] );

                large temp;
                temp.i = static_cast&lt;uint32_t&gt;(in[i].data_size);
                out.push_back( temp.c[0] );
                out.push_back( temp.c[1] );
                out.push_back( temp.c[2] );
                out.push_back( temp.c[3] );

            <I><FONT COLOR="#B22222">//This is the case where we do not know enough about the tags to tell either way (safely.) Issue a warning and pick a method to try it.
</FONT></I>            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempting to flatten an element A = &quot;</FONT></B> &lt;&lt; in[i].A &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; and B = &quot;</FONT></B> &lt;&lt; in[i].B &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; which is unfamiliar (not on a whitelist.)&quot;</FONT></B>);
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;  Please determine how to read the element and add it to the appropriate whitelist function.&quot;</FONT></B>);
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;  Guessing how the item should be treated. Search the source for tag [ WWWW3 ] for more info.&quot;</FONT></B>);

                <I><FONT COLOR="#B22222">//GUESSING that the last two bytes of B denote the size! See ~10 lines above. The appropriate whitelist is Do_Last_Two_Bytes_of_B_Denote_A_Size(...).
</FONT></I>                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;  Guessing a default behaviour. If this works, please add it to the appropriate whitelist.&quot;</FONT></B>);

                out.push_back( in[i].B.c[0] );
                out.push_back( in[i].B.c[1] );

                small temp;
                temp.i = static_cast&lt;uint16_t&gt;( in[i].data_size );
                out.push_back( temp.c[0] );
                out.push_back( temp.c[1] );

            }

        <I><FONT COLOR="#B22222">//Otherwise, B denotes (only) the size. This is the most common scenario (in the body of the file.)
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            large temp;
            temp.i = static_cast&lt;uint32_t&gt;(in[i].data_size);
            out.push_back( temp.c[0] );
            out.push_back( temp.c[1] );
            out.push_back( temp.c[2] );
            out.push_back( temp.c[3] );
        }


        <I><FONT COLOR="#B22222">//Now check if there are any children nodes and dump them.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( in[i].child.size() != 0 ){
            Repack_Nodes( in[i].child, out );
 
        <I><FONT COLOR="#B22222">//Otherwise, dump the payload string. NOTE: Some data elements are empty - this is OK.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            out += in[i].data;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

</PRE>
<HR>
<A NAME="file26">
<H1>YgorEnvironment.cc 26/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file25">prev</A>][<A HREF="#file27">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorEnvironment.cc - Routines for collecting info about the local (system) environment. 
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;utility&gt;</FONT></B>     //Needed for std::pair.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>      //Needed for getchar();

<I><FONT COLOR="#B22222">//#include &lt;malloc.h&gt;
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;climits&gt;
</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HAVE_UNISTD_H</FONT>
    <I><FONT COLOR="#B22222">//For Linux.
</FONT></I>    #include &lt;unistd.h&gt;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HAVE_SYS_SYSCTL_H</FONT>
    <I><FONT COLOR="#B22222">//For BSD and Darwin.
</FONT></I>    #include &lt;sys/sysctl.h&gt;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">__linux__</FONT>
    #include &lt;linux/fb.h&gt;  <I><FONT COLOR="#B22222">//Needed for Linux framebuffer ioctl and struct definitions.
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/stat.h&gt;</FONT></B>  //Needed for open(3).
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;fcntl.h&gt;</FONT></B>     //Needed for open(3).
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/ioctl.h&gt;</FONT></B> //Needed for ioctl() for determining terminal char, framebuffer dims.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;signal.h&gt;</FONT></B>    //Needed for system_bash().
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/wait.h&gt;</FONT></B>  //Needed for system_bash().
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/types.h&gt;</FONT></B> //Needed for system_bash().
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;errno.h&gt;</FONT></B>     //Needed for system_bash().

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>    //Needed for Execute_Command_In_Pipe.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B>  //Needed for Xtostring.

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorEnvironment.h&quot;</FONT></B>



<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------- /bin/bash system(3) ------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">system_bash</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *command){
    <I><FONT COLOR="#B22222">//This was originally copied from http://man7.org/tlpi/code/online/dist/procexec/system.c
</FONT></I>    <I><FONT COLOR="#B22222">// and was written by Michael Kerrisk in 2010. I have used the online version as a scaffolding to 
</FONT></I>    <I><FONT COLOR="#B22222">// create my own version.
</FONT></I>    sigset_t blockMask, origMask;
    <B><FONT COLOR="#228B22">struct</FONT></B> sigaction saIgnore, saOrigQuit, saOrigInt, saDefault;
    pid_t childPid;
    <B><FONT COLOR="#228B22">int</FONT></B> status, savedErrno;

    <B><FONT COLOR="#A020F0">if</FONT></B> (command == NULL)                <I><FONT COLOR="#B22222">/* Is a shell available? */</FONT></I>
        <B><FONT COLOR="#A020F0">return</FONT></B> system_bash(<B><FONT COLOR="#BC8F8F">&quot;:&quot;</FONT></B>) == 0;

    <I><FONT COLOR="#B22222">/* The parent process (the caller of system_bash()) blocks SIGCHLD
       and ignore SIGINT and SIGQUIT while the child is executing.
       We must change the signal settings prior to forking, to avoid
       possible race conditions. This means that we must undo the
       effects of the following in the child after fork(). */</FONT></I>

    sigemptyset(&amp;blockMask);            <I><FONT COLOR="#B22222">/* Block SIGCHLD */</FONT></I>
    sigaddset(&amp;blockMask, SIGCHLD);
    sigprocmask(SIG_BLOCK, &amp;blockMask, &amp;origMask);

    saIgnore.sa_handler = SIG_IGN;      <I><FONT COLOR="#B22222">/* Ignore SIGINT and SIGQUIT */</FONT></I>
    saIgnore.sa_flags = 0;
    sigemptyset(&amp;saIgnore.sa_mask);
    sigaction(SIGINT, &amp;saIgnore, &amp;saOrigInt);
    sigaction(SIGQUIT, &amp;saIgnore, &amp;saOrigQuit);

    <B><FONT COLOR="#A020F0">switch</FONT></B> (childPid = fork()) {
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">-1</FONT></B>: <I><FONT COLOR="#B22222">/* fork() failed */</FONT></I>
        status = -1;
        <B><FONT COLOR="#A020F0">break</FONT></B>;          <I><FONT COLOR="#B22222">/* Carry on to reset signal attributes */</FONT></I>

    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0</FONT></B>: <I><FONT COLOR="#B22222">/* Child: exec command */</FONT></I>

        <I><FONT COLOR="#B22222">/* We ignore possible error returns because the only specified error
           is for a failed exec(), and because errors in these calls can't
           affect the caller of system_bash() (which is a separate process) */</FONT></I>

        saDefault.sa_handler = SIG_DFL;
        saDefault.sa_flags = 0;
        sigemptyset(&amp;saDefault.sa_mask);

        <B><FONT COLOR="#A020F0">if</FONT></B> (saOrigInt.sa_handler != SIG_IGN)
            sigaction(SIGINT, &amp;saDefault, NULL);
        <B><FONT COLOR="#A020F0">if</FONT></B> (saOrigQuit.sa_handler != SIG_IGN)
            sigaction(SIGQUIT, &amp;saDefault, NULL);

        sigprocmask(SIG_SETMASK, &amp;origMask, NULL);

        execl(<B><FONT COLOR="#BC8F8F">&quot;/bin/bash&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;bash&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;-c&quot;</FONT></B>, command, (<B><FONT COLOR="#228B22">char</FONT></B> *) NULL);
        _exit(127);                     <I><FONT COLOR="#B22222">/* We could not exec the shell */</FONT></I>

    <B><FONT COLOR="#5F9EA0">default</FONT></B>: <I><FONT COLOR="#B22222">/* Parent: wait for our child to terminate */</FONT></I>

        <I><FONT COLOR="#B22222">/* We must use waitpid() for this task; using wait() could inadvertently
           collect the status of one of the caller's other children */</FONT></I>

        <B><FONT COLOR="#A020F0">while</FONT></B> (waitpid(childPid, &amp;status, 0) == -1) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (errno != EINTR) {       <I><FONT COLOR="#B22222">/* Error other than EINTR */</FONT></I>
                status = -1;
                <B><FONT COLOR="#A020F0">break</FONT></B>;                  <I><FONT COLOR="#B22222">/* So exit loop */</FONT></I>
            }
        }
        <B><FONT COLOR="#A020F0">break</FONT></B>;
    }

    <I><FONT COLOR="#B22222">/* Unblock SIGCHLD, restore dispositions of SIGINT and SIGQUIT */</FONT></I>

    savedErrno = errno;                 <I><FONT COLOR="#B22222">/* The following may change 'errno' */</FONT></I>

    sigprocmask(SIG_SETMASK, &amp;origMask, NULL);
    sigaction(SIGINT, &amp;saOrigInt, NULL);
    sigaction(SIGQUIT, &amp;saOrigQuit, NULL);

    errno = savedErrno;

    <B><FONT COLOR="#A020F0">return</FONT></B> status;
}

<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------- Simple Input ---------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Wait_For_Enter_Press</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#228B22">int</FONT></B> c;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Please press [enter] to continue&quot;</FONT></B> &lt;&lt; std::endl;
    fflush( stdout );
    <B><FONT COLOR="#A020F0">do</FONT></B>{
        c = getchar();
        <B><FONT COLOR="#A020F0">if</FONT></B>((c != <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>) &amp;&amp; (c != EOF)) std::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Waiting for user to press [enter] to continue&quot;</FONT></B> &lt;&lt; std::endl;
        fflush( stdout );
    }<B><FONT COLOR="#A020F0">while</FONT></B>((c != <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>) &amp;&amp; (c != EOF));
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}


<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------- Simple Email Sending -----------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Send_Simple_SMTP_Email</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;TO, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;subject, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;msg){
    FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;This function is deprecated due to irreconcilable architectural issues. Consider a more generic messaging system...&quot;</FONT></B>)

<I><FONT COLOR="#B22222">//    std::stringstream content;
</FONT></I><I><FONT COLOR="#B22222">//    content &lt;&lt; &quot;From: simplesender@lavabit.com&quot; &lt;&lt; std::endl;
</FONT></I><I><FONT COLOR="#B22222">//    content &lt;&lt; &quot;To: &quot; &lt;&lt; TO &lt;&lt; std::endl;
</FONT></I><I><FONT COLOR="#B22222">//    content &lt;&lt; &quot;Subject: &quot; &lt;&lt; subject &lt;&lt; std::endl;
</FONT></I><I><FONT COLOR="#B22222">//    content &lt;&lt; std::endl;
</FONT></I><I><FONT COLOR="#B22222">//    content &lt;&lt; msg;
</FONT></I><I><FONT COLOR="#B22222">//    const std::string filtered = PurgeCharsFromString(content.str(), &quot;'&quot;);
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//    std::string command, output;
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//    //First, we try curl.
</FONT></I><I><FONT COLOR="#B22222">//    //echo &quot;Hopefully it works&quot; | curl --user simplesender:3PKj3sMhe4te6Tv --ssl-reqd --mail-from &quot;simplesender@lavabit.com&quot; --mail-rcpt &quot;hdeanclark@gmail.com&quot; --url smtps://lavabit.com:465 --libcurl /tmp/curly
</FONT></I><I><FONT COLOR="#B22222">//    command += &quot;echo &quot;_s + Quote_Static_for_Bash(filtered) + &quot; | &quot;;
</FONT></I><I><FONT COLOR="#B22222">//    command += &quot;curl -s -S --user simplesender:3PKj3sMhe4te6Tv &quot;;
</FONT></I><I><FONT COLOR="#B22222">//    command += &quot; --ssl-reqd --insecure &quot;;
</FONT></I><I><FONT COLOR="#B22222">//    command += &quot; --mail-from 'simplesender@lavabit.com' --mail-rcpt &quot;;
</FONT></I><I><FONT COLOR="#B22222">//    command += Quote_Static_for_Bash(TO) + &quot; --url 'smtps://lavabit.com:465' 2&gt;&amp;1 &quot;;
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//    output = Execute_Command_In_Pipe(command);
</FONT></I><I><FONT COLOR="#B22222">//    if(output.empty()) return true;
</FONT></I><I><FONT COLOR="#B22222">//    command.clear();
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//    //If that doesn't work, try mailx.
</FONT></I><I><FONT COLOR="#B22222">//    //echo &quot;Mailx is pretty sweet&quot; | mailx -S from='simplesender@lavabit.com' -S smtp='smtps://lavabit.com:465' -S smtp-auth='login' -S smtp-auth-user='simplesender@lavabit.com' -S smtp-auth-password='3PKj3sMhe4te6Tv' -s 'Ygor Subject' 'hdeanclark@gmail.com'
</FONT></I><I><FONT COLOR="#B22222">//    command += &quot;echo &quot;_s + Quote_Static_for_Bash(filtered) + &quot; | &quot;;
</FONT></I><I><FONT COLOR="#B22222">//    command += &quot;mailx -S from='simplesender@lavabit.com' -S smtp='smtps://lavabit.com:465' -S smtp-auth='login' -S smtp-auth-user='simplesender@lavabit.com' -S smtp-auth-password='3PKj3sMhe4te6Tv' &quot;;
</FONT></I><I><FONT COLOR="#B22222">//    command += &quot; -s &quot;_s + Quote_Static_for_Bash(subject) + &quot; &quot;;
</FONT></I><I><FONT COLOR="#B22222">//    command += &quot; &quot;_s + Quote_Static_for_Bash(TO) + &quot; 2&gt;&amp;1 &quot;;
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//    output = Execute_Command_In_Pipe(command);
</FONT></I><I><FONT COLOR="#B22222">//    if(output.empty()) return true;
</FONT></I><I><FONT COLOR="#B22222">//    command.clear();
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//    //Didn't work!
</FONT></I><I><FONT COLOR="#B22222">//    return false;
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Deprecated!
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}


<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------- Framebuffer ---------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I>std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; Get_Framebuffer_Pixel_Dimensions(<B><FONT COLOR="#228B22">int</FONT></B> fbN, <B><FONT COLOR="#228B22">bool</FONT></B> Virtual <I><FONT COLOR="#B22222">/* = false*/</FONT></I>){
    <I><FONT COLOR="#B22222">//NOTE: 'Virtual' refers to the entire buffer, which may include both visible buffers in
</FONT></I>    <I><FONT COLOR="#B22222">// a double-buffer arrangement. The default is the visible buffer, which corresponds to
</FONT></I>    <I><FONT COLOR="#B22222">// what is visible on the screen.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//   ||============================================= virtual ==================|| }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||              }                                                         || }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||              } yoffset                                                 || }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||              }                                                         || }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||          |------------------- visible --------|  }                     || }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||          |                                    |  }                     || }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||          |                                    |  }                     || } yres_virtual
</FONT></I>    <I><FONT COLOR="#B22222">//   ||__________|                                    |  } yres                || }
</FONT></I>    <I><FONT COLOR="#B22222">//   || xoffset  |                                    |  }                     || }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||          |                                    |  }                     || }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||          |------------------------------------|  }                     || }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||          ______________________________________                        || }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||                         xres                                           || }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||                                                                        || }
</FONT></I>    <I><FONT COLOR="#B22222">//   ||========================================================================|| }
</FONT></I>    <I><FONT COLOR="#B22222">//    __________________________________________________________________________
</FONT></I>    <I><FONT COLOR="#B22222">//                                         xres_virtual
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">/*
THIS IS the original way I was doing it. It assumes we only care about /dev/fb0 and uses regex.
Might be OK to fall back on the virtual_size file, because it is super convenient.

    std::string dimens = Execute_Command_In_Pipe(&quot;cat /sys/class/graphics/fb0/virtual_size&quot;);
    if(dimens.size() == 0){
        dimens = Execute_Command_In_Pipe(&quot;cat /sys/devices/virtual/graphics/fbcon/subsystem/fb0/virtual_size&quot;);
    }
    if(dimens.size() == 0){
        FUNCWARN(&quot;Unable to determine the dimensions of the framebuffer&quot;);
        return std::pair&lt;long int, long int&gt;(-1,-1);
    }
    const std::string Ws = GetFirstRegex( dimens, R&quot;***(^([0-9]{3,})[,])***&quot; );
    const std::string Hs = GetFirstRegex( dimens, R&quot;***([,]([0-9]{3,}))***&quot;  );
    const long int W = Is_String_An_X&lt;long int&gt;(Ws) ? stringtoX&lt;long int&gt;(Ws) : -1;
    const long int H = Is_String_An_X&lt;long int&gt;(Hs) ? stringtoX&lt;long int&gt;(Hs) : -1;
    return std::pair&lt;long int, long int&gt;( W, H );
*/</FONT></I>
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; out(-1, -1);

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">__linux__</FONT>
    <I><FONT COLOR="#B22222">//This is specific to Linux. It requires /usr/include/linux/fb.h struct/macro defs.
</FONT></I>    <I><FONT COLOR="#B22222">// If needed on another system, consider porting. In particular, Mingw might have a
</FONT></I>    <I><FONT COLOR="#B22222">// suitable replacement... Not sure about the BSDs.
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> fb_fd;

    <I><FONT COLOR="#B22222">//Construct the appropriate framebuffer filename. Try open it.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> std::string Filename_FB(<B><FONT COLOR="#BC8F8F">&quot;/dev/fb&quot;</FONT></B>_s + Xtostring(fbN));
    <B><FONT COLOR="#A020F0">if</FONT></B>((fb_fd = open(Filename_FB.c_str(), O_RDONLY)) &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> out;

    <I><FONT COLOR="#B22222">//Populate a struct using ioctl. See /usr/include/linux/fb.h for constants.
</FONT></I>    <I><FONT COLOR="#B22222">// We only care about the 'variable' framebuffer info, not the fixed info.
</FONT></I>    <B><FONT COLOR="#228B22">struct</FONT></B> fb_var_screeninfo vs;
    <B><FONT COLOR="#A020F0">if</FONT></B>(ioctl(fb_fd, FBIOGET_VSCREENINFO, &amp;vs) != -1){
        <I><FONT COLOR="#B22222">//Note: we use the visible framebuffer dimensions, in contrast to the virtual.
</FONT></I>        <I><FONT COLOR="#B22222">// The difference is that the visible will fit in the screen
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> W = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(Virtual ? vs.xres_virtual : vs.xres);
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> H = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(Virtual ? vs.yres_virtual : vs.yres);
        out = std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(W,H);
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Framebuffer file appears to exist, but ioctl on it failed&quot;</FONT></B>);
    }
    close(fb_fd);
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
    FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;This routine is not presently available on non-Linux systems. Returning negative dimensions&quot;</FONT></B>); 
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------- Terminal Dimensions ----------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I>std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; Get_Terminal_Char_Dimensions(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//Note: *Always* handle the case of getting -1's. It is VALID for this function to always return them!
</FONT></I>    <I><FONT COLOR="#B22222">//Note: If porting this function and having problems, it is valid to always just return -1's!
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//See http://stackoverflow.com/questions/1022957/getting-terminal-width-in-c for the basis of this
</FONT></I>    <I><FONT COLOR="#B22222">// function, and a few alternatives if this doesn't work.
</FONT></I>    <B><FONT COLOR="#228B22">struct</FONT></B> winsize w;
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> W(-1), H(-1);
    <B><FONT COLOR="#A020F0">if</FONT></B>(ioctl(STDOUT_FILENO, TIOCGWINSZ, &amp;w) != -1){
        W = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(w.ws_col);
        H = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(w.ws_row);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(W,H); <I><FONT COLOR="#B22222">//Width and Height in terms of # of chars.
</FONT></I>}

<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------- X-related ----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Is_X_Running_And_In_Focus</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">return</FONT></B> ( (Execute_Command_In_Pipe(<B><FONT COLOR="#BC8F8F">&quot;echo -n \&quot;$DISPLAY\&quot;&quot;</FONT></B>)).size() != 0 );
}


<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------- Memory-related --------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Amount_Of_Total_Memory_MB</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//NOTE: This should return the maximum RAM size, in MB.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: This does NOT consider swap space.
</FONT></I>
    <I><FONT COLOR="#B22222">//For Linux.
</FONT></I>    #<B><FONT COLOR="#A020F0">if</FONT></B> defined _SC_PHYS_PAGES &amp;&amp; defined _SC_PAGESIZE
        <I><FONT COLOR="#B22222">//std::cout &lt;&lt; &quot;The number of pages in total is: &quot; &lt;&lt; sysconf(_SC_PHYS_PAGES) &lt;&lt; std::endl;
</FONT></I>        <I><FONT COLOR="#B22222">//std::cout &lt;&lt; &quot;The size of each page is:         &quot; &lt;&lt; sysconf(_SC_PAGESIZE) &lt;&lt; std::endl;
</FONT></I>        <B><FONT COLOR="#228B22">double</FONT></B> tot = static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(sysconf(_SC_PHYS_PAGES))/(1024.0*1024.0);
        tot *= static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(sysconf(_SC_PAGESIZE));
        <I><FONT COLOR="#B22222">//std::cout &lt;&lt; &quot;    (which means total: &quot; &lt;&lt; tot &lt;&lt; &quot; MB&quot; &lt;&lt; std::endl;
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(tot &gt;= 0.0) <B><FONT COLOR="#A020F0">return</FONT></B> tot;
    #endif

    <I><FONT COLOR="#B22222">//For BSDs (including darwin).
</FONT></I>    #<B><FONT COLOR="#A020F0">if</FONT></B> HAVE_SYSCTL &amp;&amp; defined HW_USERMEM
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> physmem;
        size_t len = <B><FONT COLOR="#A020F0">sizeof</FONT></B> physmem;
        <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> mib[2] = { CTL_HW, HW_PHYSMEM };

        <B><FONT COLOR="#A020F0">if</FONT></B>( (sysctl(mib, ARRAY_SIZE(mib), &amp;physmem, &amp;len, NULL, 0) == 0) &amp;&amp; (len == <B><FONT COLOR="#A020F0">sizeof</FONT></B>(physmem))){
            <B><FONT COLOR="#A020F0">return</FONT></B> static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(physmem)/(1024.0*1024.0);
        }
    #endif

    <I><FONT COLOR="#B22222">//Information unavailable.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> -1.0;
}


<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Amount_Of_Totally_Free_Memory_MB</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//NOTE: This is NOT the total amount of memory one could allocate (heap) before exhausting memory.
</FONT></I>    <I><FONT COLOR="#B22222">// Rather - this is the total amount of memory a process could allocate (heap) without forcing the
</FONT></I>    <I><FONT COLOR="#B22222">// kernel to free cached memory chunks. This is a &quot;conservative, easy estimate&quot; of available heap.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: This does NOT consider swap space.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: Inspired by http://www.opensource.apple.com/source/gcc_os/gcc_os-1671/libiberty/physmem.c
</FONT></I>
    <I><FONT COLOR="#B22222">//For Linux.
</FONT></I>    #<B><FONT COLOR="#A020F0">if</FONT></B> defined _SC_AVPHYS_PAGES &amp;&amp; defined _SC_PAGESIZE
        <I><FONT COLOR="#B22222">//std::cout &lt;&lt; &quot;The number of pages available is: &quot; &lt;&lt; sysconf(_SC_AVPHYS_PAGES) &lt;&lt; std::endl;
</FONT></I>        <I><FONT COLOR="#B22222">//std::cout &lt;&lt; &quot;The size of each page is:         &quot; &lt;&lt; sysconf(_SC_PAGESIZE) &lt;&lt; std::endl;
</FONT></I>        <B><FONT COLOR="#228B22">double</FONT></B> tot = static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(sysconf(_SC_AVPHYS_PAGES))/(1024.0*1024.0);
        tot *= static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(sysconf(_SC_PAGESIZE));
        <I><FONT COLOR="#B22222">//std::cout &lt;&lt; &quot;    (which means total available: &quot; &lt;&lt; tot &lt;&lt; &quot; MB&quot; &lt;&lt; std::endl;
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(tot &gt;= 0.0) <B><FONT COLOR="#A020F0">return</FONT></B> tot;
    #endif

    <I><FONT COLOR="#B22222">//For BSDs (including darwin).
</FONT></I>    #<B><FONT COLOR="#A020F0">if</FONT></B> HAVE_SYSCTL &amp;&amp; defined HW_USERMEM
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> usermem;
        size_t len = <B><FONT COLOR="#A020F0">sizeof</FONT></B> usermem;
        <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> mib[2] = { CTL_HW, HW_USERMEM };

        <B><FONT COLOR="#A020F0">if</FONT></B>( (sysctl(mib, ARRAY_SIZE(mib), &amp;usermem, &amp;len, NULL, 0) == 0) &amp;&amp; (len == <B><FONT COLOR="#A020F0">sizeof</FONT></B>(usermem))){
            <B><FONT COLOR="#A020F0">return</FONT></B> static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(usermem)/(1024.0*1024.0);
        }
    #endif

    <I><FONT COLOR="#B22222">//Information unavailable. Check for system-specific work around.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> -1.0;
}

</PRE>
<HR>
<A NAME="file27">
<H1>YgorFilesDirs.cc 27/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file26">prev</A>][<A HREF="#file28">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorFilesDirs.cc - Routines for interacting with files and directories. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iomanip&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdint&gt;</FONT></B>     //For intmax_t
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ctime&gt;</FONT></B>       //Needed for gen_time_random(), time_t.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;fstream&gt;</FONT></B>     //Needed for fstream (for file checking.)
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;climits&gt;</FONT></B>     //Needed for realpath(...) and Fully_Expand_Filename(...)
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;dirent.h&gt;</FONT></B>    //Needed for working with directories in C/UNIX.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;unistd.h&gt;</FONT></B>    //Needed for access(...)

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;memory&gt;</FONT></B>      //Needed for unique_ptrs.

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/stat.h&gt;</FONT></B>  //Needed for mknod (used for FIFOs, etc..), stat(...)
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/types.h&gt;</FONT></B> //Needed for mkdir() (I think for permission macros).

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;External/MD5/md5.h&quot;</FONT></B> //Needed for MD5_of_File(...)

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>    //Needed for FUNCINFO,FUNCWARN,FUNCERR macros.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B>  //Needed for Xtostring routine.
<I><FONT COLOR="#B22222">//#include &quot;YgorTime.h&quot;    //Needed for Last_Access_Time(), Last_Modification_Time().
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorFilesDirs.h&quot;</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGORFILESDIRS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    #define YGORFILESDIRS_INCLUDE_ALL_SPECIALIZATIONS
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------- Files Only ----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Does_File_Exist_And_Can_Be_Read</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename){
    <I><FONT COLOR="#B22222">//Alternative: if(access(filename.c_str(), F_OK) == -1) return false;
</FONT></I>    <I><FONT COLOR="#B22222">//             else return true;     (but this depends on unistd.h)
</FONT></I>
    <I><FONT COLOR="#B22222">//First check if it a directory (because below will return 'true' if the filename is a directory!)
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(Does_Dir_Exist_And_Can_Be_Read(filename)){
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::fstream FI(filename.c_str(), std::ifstream::in);
    FI.close();
    <B><FONT COLOR="#A020F0">if</FONT></B>( FI.fail() ){
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">//Returns the first filename which exists and is available to be read, or an empty string.
</FONT></I>std::string Get_First_Filename_Which_Exists_And_Can_Be_Read(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::string&gt; &amp;filenames){
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> l_it = filenames.begin(); l_it != filenames.end(); ++l_it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(Does_File_Exist_And_Can_Be_Read(*l_it)) <B><FONT COLOR="#A020F0">return</FONT></B> *l_it;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::string(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
}

<I><FONT COLOR="#B22222">//Returns the size of the file in bytes without having to open/seek/close it. 
</FONT></I><I><FONT COLOR="#B22222">//off_t Size_of_File(const std::string &amp;filename){
</FONT></I>intmax_t <B><FONT COLOR="#0000FF">Size_of_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename){
    <I><FONT COLOR="#B22222">//Note: This may fail on files &gt; 2GB even if the machine is &gt;32 bit due to stat() using off_t.
</FONT></I>    <I><FONT COLOR="#B22222">// You can check this by ensuring the off_t typedef is not stuck at 32 bit, though I suspect
</FONT></I>    <I><FONT COLOR="#B22222">// it is unlikely this would happen...
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Note: Try replacing this with stat64() so that we get off64_t instead!
</FONT></I>    <B><FONT COLOR="#228B22">struct</FONT></B> stat buf;
    <B><FONT COLOR="#A020F0">if</FONT></B>( ::stat(filename.c_str(), &amp;buf) != 0 ) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> size = static_cast&lt;intmax_t&gt;(buf.st_size);
    <B><FONT COLOR="#A020F0">return</FONT></B> size;
}

<I><FONT COLOR="#B22222">//Returns last time of access, or (std::time_t)(-1) if an error occurs. 
</FONT></I><I><FONT COLOR="#B22222">// Should work for both files and directories.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//For directories, access/modification of files under directory *should* 
</FONT></I><I><FONT COLOR="#B22222">// cascade up to alter the access/modification time of the parent directory. 
</FONT></I><I><FONT COLOR="#B22222">// This only goes ONE level up. The absence of this alteration does not imply 
</FONT></I><I><FONT COLOR="#B22222">// nothing changed (just that it wasn't recorded).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: From stat(2) man page:
</FONT></I><I><FONT COLOR="#B22222">//   Not all of the Linux file systems implement all of the time fields.  Some file system types allow mounting in such a way
</FONT></I><I><FONT COLOR="#B22222">//   that file and/or directory accesses do not cause an update of the st_atime field.  (See noatime, nodiratime,  and  relatime
</FONT></I><I><FONT COLOR="#B22222">//   in  mount(8),  and  related  information  in  mount(2).)  In addition, st_atime is not updated if a file is opened with the
</FONT></I><I><FONT COLOR="#B22222">//   O_NOATIME; see open(2).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   The field st_atime is changed by file accesses, for example, by execve(2), mknod(2), pipe(2), utime(2) and read(2) (of more
</FONT></I><I><FONT COLOR="#B22222">//   than zero bytes).  Other routines, like mmap(2), may or may not update st_atime.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   The  field st_mtime is changed by file modifications, for example, by mknod(2), truncate(2), utime(2) and write(2) (of more
</FONT></I><I><FONT COLOR="#B22222">//   than zero bytes).  Moreover, st_mtime of a directory is changed by the creation or deletion of  files  in  that  directory.
</FONT></I><I><FONT COLOR="#B22222">//   The st_mtime field is not changed for changes in owner, group, hard link count, or mode.
</FONT></I>std::time_t Last_Access_Time(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;pathorfilename){
    <B><FONT COLOR="#228B22">struct</FONT></B> stat buf;
    <B><FONT COLOR="#A020F0">if</FONT></B>( ::stat(pathorfilename.c_str(), &amp;buf) != 0 ) <B><FONT COLOR="#A020F0">return</FONT></B> (std::time_t)(-1);
    <B><FONT COLOR="#A020F0">return</FONT></B> buf.st_atime;
}

<I><FONT COLOR="#B22222">//Returns last time of modification, or (std::time_t)(-1) if an error occurs.
</FONT></I><I><FONT COLOR="#B22222">// Should work for both files and directories. See comment about time issues
</FONT></I><I><FONT COLOR="#B22222">// above Last_Access_Time().
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//For directories, access/modification of files under directory *should* 
</FONT></I><I><FONT COLOR="#B22222">// cascade up to alter the access/modification time of the parent directory. 
</FONT></I><I><FONT COLOR="#B22222">// This only goes ONE level up. The absence of this alteration does not imply 
</FONT></I><I><FONT COLOR="#B22222">// nothing changed (just that it wasn't recorded).
</FONT></I>std::time_t Last_Modification_Time(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;pathorfilename){
    <B><FONT COLOR="#228B22">struct</FONT></B> stat buf;
    <B><FONT COLOR="#A020F0">if</FONT></B>( ::stat(pathorfilename.c_str(), &amp;buf) != 0 ) <B><FONT COLOR="#A020F0">return</FONT></B> (std::time_t)(-1);
    <B><FONT COLOR="#A020F0">return</FONT></B> buf.st_mtime;
}


<I><FONT COLOR="#B22222">//Returns a string containing an md5, or an empty string on failure.
</FONT></I>std::string MD5_of_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename){
    <I><FONT COLOR="#B22222">//NOTE: This could be made more sane by computing small chunks of the file,
</FONT></I>    <I><FONT COLOR="#B22222">// instead of doing it all at once. See RFC 1321 (MD5) for a reference
</FONT></I>    <I><FONT COLOR="#B22222">// implementation which includes a routine for doing this. I think it 
</FONT></I>    <I><FONT COLOR="#B22222">// could be re-implemented quite easily here.
</FONT></I>    <B><FONT COLOR="#5F9EA0">MD5</FONT></B>::Context working;
    <B><FONT COLOR="#5F9EA0">MD5</FONT></B>::Init(&amp;working);

    intmax_t thesize(0);
    <B><FONT COLOR="#228B22">auto</FONT></B> inmem = Load_Binary_File&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;(filename, &amp;thesize);
    <B><FONT COLOR="#A020F0">if</FONT></B>(thesize == 0) <B><FONT COLOR="#A020F0">return</FONT></B> std::string(); <I><FONT COLOR="#B22222">//Error.
</FONT></I>
    <B><FONT COLOR="#5F9EA0">MD5</FONT></B>::Update(&amp;working, reinterpret_cast&lt;<B><FONT COLOR="#228B22">void</FONT></B> *&gt;(inmem.get()), thesize);

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *result = <B><FONT COLOR="#A020F0">new</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>[16+1];
    result[16] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

    <B><FONT COLOR="#5F9EA0">MD5</FONT></B>::Final(result, &amp;working);

    <I><FONT COLOR="#B22222">//Print is as 2-digit hex.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;
    ss &lt;&lt; std::hex &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 16; ++i) ss &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B>&gt;(result[i]);

    <B><FONT COLOR="#A020F0">delete</FONT></B>[] result;
    <B><FONT COLOR="#A020F0">return</FONT></B> ss.str();
}

<I><FONT COLOR="#B22222">//Gets from byte N to byte N+L (inclusive) from a file. Should only use for large files, because it is opened/closed each time.
</FONT></I><I><FONT COLOR="#B22222">//template &lt;class T&gt; std::unique_ptr&lt;T[]&gt; Get_Piece_of_Binary_File(const std::string &amp;filename_in, std::ios::pos_type N, std::ios::pos_type L){
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::unique_ptr&lt;T[]&gt; Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::ifstream in(filename_in.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!in.is_open()) <B><FONT COLOR="#A020F0">return</FONT></B> nullptr;

    intmax_t l_size = static_cast&lt;intmax_t&gt;(in.tellg());  <I><FONT COLOR="#B22222">//Grab the size of the binary file in bytes.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(l_size &lt; (N+L)) <B><FONT COLOR="#A020F0">return</FONT></B> nullptr;

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;T[]&gt; mem;
    mem.reset( <B><FONT COLOR="#A020F0">new</FONT></B> T [L/<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)] );

    in.seekg(0,std::ios::beg);
    in.seekg(N);
    in.read(reinterpret_cast&lt;<B><FONT COLOR="#228B22">char</FONT></B>*&gt;(mem.get()), static_cast&lt;std::streamsize&gt;(L));
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(mem); 
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORFILESDIRS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">/*
template std::unique_ptr&lt;unsigned char[]&gt; Get_Piece_of_Binary_File(const std::string &amp;filename_in, intmax_t N, intmax_t L);
template std::unique_ptr&lt;char[]&gt;          Get_Piece_of_Binary_File(const std::string &amp;filename_in, intmax_t N, intmax_t L);
template std::unique_ptr&lt;float[]&gt;         Get_Piece_of_Binary_File(const std::string &amp;filename_in, intmax_t N, intmax_t L);
template std::unique_ptr&lt;double[]&gt;        Get_Piece_of_Binary_File(const std::string &amp;filename_in, intmax_t N, intmax_t L);
*/</FONT></I>

<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt;       Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint16_t[]&gt;      Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint32_t[]&gt;      Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint64_t[]&gt;      Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;int8_t[]&gt;        Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;int16_t[]&gt;       Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;int32_t[]&gt;       Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;int64_t[]&gt;       Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;<B><FONT COLOR="#228B22">char</FONT></B>[]&gt;          Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;<B><FONT COLOR="#228B22">float</FONT></B>[]&gt;         Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;<B><FONT COLOR="#228B22">double</FONT></B>[]&gt;        Get_Piece_of_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t N, intmax_t L);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Does_Fifo_Exist</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename){
    <I><FONT COLOR="#B22222">//NOTE: I *think* this is essentially identical to Does_File_Exist_And_Can_Be_Read(...), but it might
</FONT></I>    <I><FONT COLOR="#B22222">// be safer to separate these functions until I know for certainty (specifically, will ..._File_... block?)
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(access(filename.c_str(), F_OK) == -1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

std::string Get_Unique_Filename(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;prefix, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> len, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;suffix <I><FONT COLOR="#B22222">/* = &quot;&quot; */</FONT></I>){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out; <I><FONT COLOR="#B22222">//, temp;
</FONT></I>    <B><FONT COLOR="#A020F0">do</FONT></B>{
        <B><FONT COLOR="#228B22">const</FONT></B> std::string random_chars = Generate_Random_String_of_Length(len);
<I><FONT COLOR="#B22222">//        gen_random(&amp;temp, len);
</FONT></I>        out = prefix + random_chars + suffix;
    }<B><FONT COLOR="#A020F0">while</FONT></B>( Does_File_Exist_And_Can_Be_Read(out) );
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//std::string Get_Unique_Sequential_Filename(const std::string &amp;prefix){
</FONT></I>std::string Get_Unique_Sequential_Filename(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;prefix, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_of_digit_pads <I><FONT COLOR="#B22222">/* = */</FONT></I>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;suffix <I><FONT COLOR="#B22222">/* = &quot;&quot; */</FONT></I>){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out, temp;
    <I><FONT COLOR="#B22222">//This function appends numbers to the back of a filename until a unique one is found (or we exceed max.)
</FONT></I>    <I><FONT COLOR="#B22222">// The first output in a sequence will NOT have a number at all. In the future, the appended characters may
</FONT></I>    <I><FONT COLOR="#B22222">// be alphanumeric.
</FONT></I>    
    <I><FONT COLOR="#B22222">//If we don't pad we can have a numberless case. This is handled here.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( !Does_File_Exist_And_Can_Be_Read(prefix + std::string(n_of_digit_pads,<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) + suffix) ){
        <B><FONT COLOR="#A020F0">return</FONT></B> (prefix + std::string(n_of_digit_pads,<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) + suffix);
    }

    <I><FONT COLOR="#B22222">//General case.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 1E7; i++){
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string thenumb = Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(i);
        <B><FONT COLOR="#A020F0">if</FONT></B>(static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(thenumb.size()) &lt; n_of_digit_pads){
            thenumb = std::string(n_of_digit_pads - static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(thenumb.size()), <B><FONT COLOR="#BC8F8F">'0'</FONT></B>) + thenumb;
        }

        out = prefix + thenumb + suffix;
        <B><FONT COLOR="#A020F0">if</FONT></B>(!Does_File_Exist_And_Can_Be_Read(out)) <B><FONT COLOR="#A020F0">return</FONT></B> out;
    }
    FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to find a sequential filename&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//Expand a filename/partial path/full path/symbolic link/./.. into a full path. Empty string is returned on fail.
</FONT></I>std::string Fully_Expand_Filename(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    <B><FONT COLOR="#228B22">char</FONT></B> *expanded = reinterpret_cast&lt;<B><FONT COLOR="#228B22">char</FONT></B> *&gt;(realpath(filename.c_str(), nullptr));
    <B><FONT COLOR="#A020F0">if</FONT></B>(expanded == nullptr) <B><FONT COLOR="#A020F0">return</FONT></B> out;
    out.insert(out.size(), expanded); 
    free(reinterpret_cast&lt;<B><FONT COLOR="#228B22">void</FONT></B> *&gt;(expanded));
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//Determines if a path is below another path. Useful for specifying whitelists of files/directories.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Note: Returns 'true' on success, 'false' on everything else (including all errors).
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">File_Is_Recursively_Within_Directory</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;pathname_in){
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> A = Fully_Expand_Filename(filename_in);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> B = Fully_Expand_Filename(pathname_in);
    <B><FONT COLOR="#A020F0">if</FONT></B>(A.empty() || B.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> false;  <I><FONT COLOR="#B22222">//An error in the input or resolving the file/pathname.
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>(A.size() &lt; B.size()) <B><FONT COLOR="#A020F0">return</FONT></B> false; 
    <I><FONT COLOR="#B22222">//Primitively examine the directory filename. Compare letter for letter with the filename until the directory name 
</FONT></I>    <I><FONT COLOR="#B22222">// terminates.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i = 0; i != B.size(); ++i){
        <B><FONT COLOR="#A020F0">if</FONT></B>(B[i] != A[i]) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true; <I><FONT COLOR="#B22222">//We have to believe the file is recursively contained within the directory now.
</FONT></I>}

<I><FONT COLOR="#B22222">//Loads a binary file into memory, closes the file, and passes the data back.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The 'size' parameter is filled with the size of data in the array. The units are in T's. In other words,
</FONT></I><I><FONT COLOR="#B22222">// the number of *bytes* of data is size*sizeof(T).
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::unique_ptr&lt;T[]&gt; Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size){
    <B><FONT COLOR="#A020F0">if</FONT></B>(size == nullptr) <B><FONT COLOR="#A020F0">return</FONT></B> nullptr;
    (*size) = 0;  <I><FONT COLOR="#B22222">//Just in case we run into an error and have to exit prematurely..
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::unique_ptr&lt;T[]&gt; mem;

    <I><FONT COLOR="#B22222">//Load the file into memory.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::ifstream in(filename_in.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!in.is_open()){
         FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to load file. Does it exist? Do you have permissions to open it?&quot;</FONT></B>);
         <B><FONT COLOR="#A020F0">return</FONT></B> nullptr;
    }

    <I><FONT COLOR="#B22222">//std::ifstream::pos_type l_size = in.tellg();  //Grab the size of the binary file in bytes.
</FONT></I>    intmax_t l_size = static_cast&lt;intmax_t&gt;(in.tellg());  <I><FONT COLOR="#B22222">//Grab the size of the binary file in bytes.
</FONT></I>    <I><FONT COLOR="#B22222">//const auto l_size = in.tellg();  //Grab the size of the binary file in bytes.
</FONT></I>
    <I><FONT COLOR="#B22222">//Check if the file is OK!
</FONT></I>
    <I><FONT COLOR="#B22222">// ... 
</FONT></I>   

    <I><FONT COLOR="#B22222">//Check if the data (appears) to be able to be represented by an array of T's. If not, we have to 
</FONT></I>    <I><FONT COLOR="#B22222">// abort or risk filling the buffer incorrectly.
</FONT></I>    {
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> A = l_size/<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T);  <I><FONT COLOR="#B22222">//Safer to test this way than with modulus!
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B>( static_cast&lt;intmax_t&gt;(A * <B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)) != static_cast&lt;intmax_t&gt;(l_size) ){
          FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;This data does not appear to be able to be represented as the requested data type.&quot;</FONT></B>);
          FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot; The file is of size &quot;</FONT></B> &lt;&lt; l_size &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; bytes, which is not divisible by the size of the template type (size = &quot;</FONT></B> &lt;&lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B>(T) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; bytes.)&quot;</FONT></B>);
          <B><FONT COLOR="#A020F0">return</FONT></B> nullptr;
      }
    }

    mem.reset( <B><FONT COLOR="#A020F0">new</FONT></B> T [l_size/<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)] );      <I><FONT COLOR="#B22222">//Allocate space for the entire block to be pulled into memory.
</FONT></I>    in.seekg(0, std::ios::beg);                 <I><FONT COLOR="#B22222">//Seek back to the beginning.
</FONT></I>    in.read((<B><FONT COLOR="#228B22">char</FONT></B> *)(mem.get()), static_cast&lt;std::streamsize&gt;(l_size));  <I><FONT COLOR="#B22222">//Read the entire file in (in one go.)
</FONT></I>    in.close();

    (*size) = static_cast&lt;intmax_t&gt;(l_size/<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T));
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(mem);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORFILESDIRS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">/*
template std::unique_ptr&lt;unsigned char[]&gt; Load_Binary_File(const std::string &amp;filename_in, intmax_t *size);
template std::unique_ptr&lt;char[]&gt;          Load_Binary_File(const std::string &amp;filename_in, intmax_t *size);
template std::unique_ptr&lt;float[]&gt;         Load_Binary_File(const std::string &amp;filename_in, intmax_t *size);
template std::unique_ptr&lt;double[]&gt;        Load_Binary_File(const std::string &amp;filename_in, intmax_t *size);
*/</FONT></I>
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt;  Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint16_t[]&gt; Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint32_t[]&gt; Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint64_t[]&gt; Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;int8_t[]&gt;   Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;int16_t[]&gt;  Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;int32_t[]&gt;  Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;int64_t[]&gt;  Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;<B><FONT COLOR="#228B22">char</FONT></B>[]&gt;     Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;<B><FONT COLOR="#228B22">float</FONT></B>[]&gt;    Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);
<B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;<B><FONT COLOR="#228B22">double</FONT></B>[]&gt;   Load_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, intmax_t *size);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Write a block of memory to file. &quot;size&quot; is the NUMBER OF T to read. If sizeof(T) != 8, then this is != bytes!
</FONT></I><I><FONT COLOR="#B22222">//Returns true on success.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> Write_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;T[]&gt; in, intmax_t size){
    <B><FONT COLOR="#A020F0">if</FONT></B>(size &lt;= 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::ofstream FO(filename_out.c_str(), std::ios::out | std::ios::binary);
    FO.write((<B><FONT COLOR="#228B22">char</FONT></B> *)(in.get()), static_cast&lt;std::streamsize&gt;(size*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)));
    <I><FONT COLOR="#B22222">//Check for errors, or will it except?
</FONT></I>    FO.close();
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORFILESDIRS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">/*
template bool Write_Binary_File(const std::string &amp;filename_out, std::unique_ptr&lt;unsigned char[]&gt; in, intmax_t size);
template bool Write_Binary_File(const std::string &amp;filename_out, std::unique_ptr&lt;char[]&gt; in, intmax_t size);
template bool Write_Binary_File(const std::string &amp;filename_out, std::unique_ptr&lt;float[]&gt; in, intmax_t size);
template bool Write_Binary_File(const std::string &amp;filename_out, std::unique_ptr&lt;double[]&gt; in, intmax_t size);
*/</FONT></I>
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;uint8_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;uint16_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;uint32_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;uint64_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;int8_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;int16_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;int32_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;int64_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;<B><FONT COLOR="#228B22">char</FONT></B>[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;<B><FONT COLOR="#228B22">float</FONT></B>[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Write_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;<B><FONT COLOR="#228B22">double</FONT></B>[]&gt; in, intmax_t size);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Append a block of memory to file. &quot;size&quot; is the NUMBER OF T to read. If sizeof(T) != 8, then this is != bytes!
</FONT></I><I><FONT COLOR="#B22222">//Returns true on success.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> Append_Binary_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;T[]&gt; in, intmax_t size){
    <B><FONT COLOR="#A020F0">if</FONT></B>(size &lt;= 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::ofstream FO(filename_out.c_str(), std::ios::out | std::ios::binary | std::ios::app);
    FO.write((<B><FONT COLOR="#228B22">char</FONT></B> *)(in.get()), static_cast&lt;std::streamsize&gt;(size*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)));
    <I><FONT COLOR="#B22222">//Check for errors, or will it except?
</FONT></I>    FO.close();
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORFILESDIRS_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">/*
template bool Append_Binary_File(const std::string &amp;filename_out, std::unique_ptr&lt;unsigned char[]&gt; in, intmax_t size);
template bool Append_Binary_File(const std::string &amp;filename_out, std::unique_ptr&lt;char[]&gt; in, intmax_t size);
template bool Append_Binary_File(const std::string &amp;filename_out, std::unique_ptr&lt;float[]&gt; in, intmax_t size);
template bool Append_Binary_File(const std::string &amp;filename_out, std::unique_ptr&lt;double[]&gt; in, intmax_t size);
*/</FONT></I>
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Append_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;uint8_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Append_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;uint16_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Append_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;uint32_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Append_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;uint64_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Append_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;int8_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Append_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;int16_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Append_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;int32_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Append_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;int64_t[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Append_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;<B><FONT COLOR="#228B22">char</FONT></B>[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Append_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;<B><FONT COLOR="#228B22">float</FONT></B>[]&gt; in, intmax_t size);
<B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Append_Binary_File</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_out, std::unique_ptr&lt;<B><FONT COLOR="#228B22">double</FONT></B>[]&gt; in, intmax_t size);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Load a file, line by line, into a string delimited by '\n'. Will not work with binary files.
</FONT></I>std::string LoadFileToString(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string lines;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::fstream thefile(filename_in.c_str(), std::ios::in);

    <I><FONT COLOR="#B22222">//If the file is not good, we simply return an empty string.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!thefile.good()){
        <B><FONT COLOR="#A020F0">return</FONT></B> lines;
    }

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string filecontents;
    <B><FONT COLOR="#A020F0">while</FONT></B>(!thefile.eof()){
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::getline(thefile, lines);
        <B><FONT COLOR="#A020F0">if</FONT></B>(!thefile.eof()) filecontents += lines + <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
    }

    thefile.close();
    <B><FONT COLOR="#A020F0">return</FONT></B> filecontents;
}

<I><FONT COLOR="#B22222">//Load a binary file and copy the memory into a std::string. Involves a copy, so use only for small things.
</FONT></I>std::string LoadBinaryFileToString(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string thedata;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> filesize = Size_of_File(filename_in);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> mem_ptr = Get_Piece_of_Binary_File&lt;<B><FONT COLOR="#228B22">char</FONT></B>&gt;(filename_in, 0, filesize); <I><FONT COLOR="#B22222">//likely a unique_ptr.
</FONT></I>    thedata.clear();
    thedata.insert(0,mem_ptr.get(),static_cast&lt;std::string::size_type&gt;(filesize));
<I><FONT COLOR="#B22222">//    thedata.insert(thedata.size(), mem_ptr.get(), filesize); //Probably overkill. Inserts it at the end. Should always be at the beginning in this case.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> thedata;
}

<I><FONT COLOR="#B22222">//Load a file into a list with no delimiter.
</FONT></I>std::list&lt;std::string&gt; LoadFileToList(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string lines;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; filecontents;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::fstream thefile(filename_in.c_str(), std::ios::in);

    <I><FONT COLOR="#B22222">//If the file is not good, we simply return an empty string.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!thefile.good()){
        <B><FONT COLOR="#A020F0">return</FONT></B> filecontents;
    }

    <B><FONT COLOR="#A020F0">while</FONT></B>(!thefile.eof()){
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::getline(thefile, lines);
        <B><FONT COLOR="#A020F0">if</FONT></B>(!thefile.eof()) filecontents.push_back( lines );
    }

    thefile.close();
    <B><FONT COLOR="#A020F0">return</FONT></B> filecontents;
}

<I><FONT COLOR="#B22222">//Write a string to a file. No extra formatting is performed. Returns true on success.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">WriteStringToFile</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, <B><FONT COLOR="#228B22">bool</FONT></B> overwrite){
    <B><FONT COLOR="#A020F0">if</FONT></B>(!overwrite &amp;&amp; Does_File_Exist_And_Can_Be_Read(filename_in)) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::fstream thefile(filename_in.c_str(), std::ios::out);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!thefile.good()){
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    thefile &lt;&lt; in;
    thefile.close();
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">//Write a binary string to a file. Returns true on success.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This will NOT silently overwrite existing files unless they are generated quickly...
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">WriteBinaryStringToFile</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in, <B><FONT COLOR="#228B22">bool</FONT></B> overwrite){
    <B><FONT COLOR="#A020F0">if</FONT></B>(!overwrite &amp;&amp; Does_File_Exist_And_Can_Be_Read(filename_in)) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::fstream thefile(filename_in.c_str(), std::ios::out | std::ios::binary);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!thefile.good()){
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    thefile &lt;&lt; in;
    thefile.close();
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">//Append a string to a file, creating the file if necessary. Returns true on success.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">AppendStringToFile</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::fstream thefile(filename_in.c_str(), std::ios::out | std::ios::app);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!thefile.good()){
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    thefile &lt;&lt; in;
    thefile.close();
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">//Creates a FIFO at the specified path. User must then read/write to use it.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This function assumes the file does not exist. It will not be successful if it does.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This function returns 'true' upon success.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">CreateFIFOFile</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename_in){
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> result = mknod( filename_in.c_str(), S_IRUSR | S_IWUSR | S_IFIFO, 0);
    <B><FONT COLOR="#A020F0">if</FONT></B>(result &lt; 0){
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------- Directories ---------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I>

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Does_Dir_Exist_And_Can_Be_Read</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; out;
    <B><FONT COLOR="#228B22">struct</FONT></B> dirent **eps;
    <B><FONT COLOR="#228B22">auto</FONT></B> one = [](<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> dirent *unused) -&gt; <B><FONT COLOR="#228B22">int</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> 1; };
    <B><FONT COLOR="#228B22">int</FONT></B> n = scandir(dir.c_str(), &amp;eps, one, alphasort);

    <B><FONT COLOR="#A020F0">return</FONT></B> (n &gt;= 0);
}
   

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Create_Dir_and_Necessary_Parents</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir){
    <I><FONT COLOR="#B22222">//Supposed to behave like `mkdir -p $dir`.
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>(dir.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <I><FONT COLOR="#B22222">//If the parent directory does not exist, create it first.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> parent = Get_Parent_Directory(dir);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!parent.empty() &amp;&amp; !Does_Dir_Exist_And_Can_Be_Read(parent)){
        <B><FONT COLOR="#A020F0">if</FONT></B>(!Create_Dir_and_Necessary_Parents(parent)){
            <I><FONT COLOR="#B22222">//At this point, parent does not exist or is not accessible, and cannot 
</FONT></I>            <I><FONT COLOR="#B22222">// be created. There is nothing else we can try.
</FONT></I>            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
    }

    <I><FONT COLOR="#B22222">//Permissions: read, write, search permissions for owner and group, and 
</FONT></I>    <I><FONT COLOR="#B22222">// read, search permissions for others.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> res = mkdir(dir.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
    <B><FONT COLOR="#A020F0">if</FONT></B>(res != 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}     

std::list&lt;std::string&gt; Get_List_of_File_and_Dir_Names_in_Dir(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; out;
    <B><FONT COLOR="#228B22">struct</FONT></B> dirent **eps;
    <I><FONT COLOR="#B22222">//Lambda for picking out directories/filenames. We want to collect everything, so simply return 1.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">// To discriminate certain attributes, see 
</FONT></I>    <I><FONT COLOR="#B22222">//   http://www.gnu.org/software/libc/manual/html_node/Directory-Entries.html#Directory-Entries 
</FONT></I>    <I><FONT COLOR="#B22222">// (where this routine originally came from!)
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> one = [](<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> dirent *unused) -&gt; <B><FONT COLOR="#228B22">int</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> 1; };
    <B><FONT COLOR="#228B22">int</FONT></B> n = scandir(dir.c_str(), &amp;eps, one, alphasort);
    <B><FONT COLOR="#A020F0">if</FONT></B>(n &gt;= 0){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> cnt = 0; cnt &lt; n; ++cnt){
            <B><FONT COLOR="#228B22">const</FONT></B> std::string the_name( eps[cnt]-&gt;d_name );
            <I><FONT COLOR="#B22222">//We choose to ignore the '.' and '..' because it is usually a given 
</FONT></I>            <I><FONT COLOR="#B22222">// that they exist and will typically not be of use to return. 
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>((the_name != <B><FONT COLOR="#BC8F8F">&quot;.&quot;</FONT></B>) &amp;&amp; (the_name != <B><FONT COLOR="#BC8F8F">&quot;..&quot;</FONT></B>)) out.push_back(the_name);
        }
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to open directory&quot;</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::list&lt;std::string&gt; Get_List_of_Full_Path_File_and_Dir_Names_in_Dir(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; names;
    <B><FONT COLOR="#A020F0">if</FONT></B>(dir.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> names;
    names = Get_List_of_File_and_Dir_Names_in_Dir(dir);
    
    <I><FONT COLOR="#B22222">//Append the passed in directory to the beginning of the filename.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string slasheddir(dir);
    <B><FONT COLOR="#A020F0">if</FONT></B>(*(dir.rbegin()) != <B><FONT COLOR="#BC8F8F">'/'</FONT></B>) slasheddir += <B><FONT COLOR="#BC8F8F">&quot;/&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = names.begin(); it != names.end(); ++it) *it = slasheddir + *it;
    <B><FONT COLOR="#A020F0">return</FONT></B> names;
}

std::list&lt;std::string&gt; Get_List_of_File_Names_in_Dir(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; out;
    <B><FONT COLOR="#228B22">struct</FONT></B> dirent **eps;
    <I><FONT COLOR="#B22222">//Lambda for picking out directories/filenames. Returns 1 only on regular files.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">// To discriminate certain attributes, see 
</FONT></I>    <I><FONT COLOR="#B22222">//   http://www.gnu.org/software/libc/manual/html_node/Directory-Entries.html#Directory-Entries 
</FONT></I>    <I><FONT COLOR="#B22222">// (where this routine originally came from!)
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> one = [](<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> dirent *s) -&gt; <B><FONT COLOR="#228B22">int</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B>(s-&gt;d_type == DT_REG) <B><FONT COLOR="#A020F0">return</FONT></B> 1; 
        <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    };
    <B><FONT COLOR="#228B22">int</FONT></B> n = scandir(dir.c_str(), &amp;eps, one, alphasort);
    <B><FONT COLOR="#A020F0">if</FONT></B>(n &gt;= 0){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> cnt = 0; cnt &lt; n; ++cnt){
            <B><FONT COLOR="#228B22">const</FONT></B> std::string the_name(eps[cnt]-&gt;d_name);
            <I><FONT COLOR="#B22222">//We choose to ignore the '.' and '..' because it is usually a given 
</FONT></I>            <I><FONT COLOR="#B22222">// that they exist and will typically not be of use to return. 
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>((the_name != <B><FONT COLOR="#BC8F8F">&quot;.&quot;</FONT></B>) &amp;&amp; (the_name != <B><FONT COLOR="#BC8F8F">&quot;..&quot;</FONT></B>)) out.push_back(the_name);
        }
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to open directory&quot;</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::list&lt;std::string&gt; Get_List_of_Full_Path_File_Names_in_Dir(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;dir){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; names;
    <B><FONT COLOR="#A020F0">if</FONT></B>(dir.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> names;
    names = Get_List_of_File_Names_in_Dir(dir);

    <I><FONT COLOR="#B22222">//Append the passed in directory to the beginning of the filename.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string slasheddir(dir);
    <B><FONT COLOR="#A020F0">if</FONT></B>(*(dir.rbegin()) != <B><FONT COLOR="#BC8F8F">'/'</FONT></B>) slasheddir += <B><FONT COLOR="#BC8F8F">&quot;/&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = names.begin(); it != names.end(); ++it) *it = slasheddir + *it;
    <B><FONT COLOR="#A020F0">return</FONT></B> names;
}

</PRE>
<HR>
<A NAME="file28">
<H1>YgorImages.cc 28/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file27">prev</A>][<A HREF="#file29">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorImages.cc - Routines to help manage buffers of 2D data.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;memory&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string.h&gt;</FONT></B>   //For memcpy.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>      //For std::round(...)

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMath.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorPlot.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorImages.h&quot;</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    #define YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
<I><FONT COLOR="#B22222">//class planar_image;
</FONT></I>
<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------- planar_image ----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Constructor/Destructors.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">class</FONT></B> R&gt; planar_image&lt;T,R&gt;::planar_image(){
    rows = columns = channels = -1;
    pxl_dx = pxl_dy = pxl_dz = (R)(0);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::planar_image(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">class</FONT></B> R&gt; planar_image&lt;T,R&gt;::planar_image(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;T,R&gt; &amp;in){
    (*<B><FONT COLOR="#A020F0">this</FONT></B>) = in;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::planar_image(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">class</FONT></B> R&gt; planar_image&lt;T,R&gt;::~planar_image(){ }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::~planar_image(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Allocating space and initializing the purely-2D-image members.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">void</FONT></B> planar_image&lt;T,R&gt;::init_buffer(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> rows, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> cols, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnls){
    <B><FONT COLOR="#A020F0">if</FONT></B>((rows &lt;= 0) || (cols &lt;= 0) || (chnls &lt;= 0)){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Requested to initialize an image with impossible dimensions&quot;</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data.reset( <B><FONT COLOR="#A020F0">new</FONT></B> T [rows*cols*chnls] );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows     = rows;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns  = cols;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;channels = chnls;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::init_buffer(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> rows, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> cols, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnls);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Initializing the R^3 members. These are less important because they won't cause a segfault.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">void</FONT></B> planar_image&lt;T,R&gt;::init_spatial(R pxldx, R pxldy, R pxldz, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;anchr, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;offst){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dx = pxldx;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dy = pxldy;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dz = pxldz;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;anchor = anchr;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;offset = offst;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::init_spatial(<B><FONT COLOR="#228B22">double</FONT></B> pxldx, <B><FONT COLOR="#228B22">double</FONT></B> pxldy, <B><FONT COLOR="#228B22">double</FONT></B> pxldz, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;anchr, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;offst);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">void</FONT></B> planar_image&lt;T,R&gt;::init_orientation(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;rowunit, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;colunit){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit = rowunit.unit();
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;col_unit = colunit.unit();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::init_orientation(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rowunit, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;colunit);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; planar_image&lt;T,R&gt; &amp; planar_image&lt;T,R&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;T,R&gt; &amp;rhs){
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B> == &amp;rhs) <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
    <I><FONT COLOR="#B22222">//Copies everything except the array's pointer. It allocates a new buffer for this purpose and copies the data.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;init_buffer(rhs.rows, rhs.columns, rhs.channels);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;init_spatial(rhs.pxl_dx, rhs.pxl_dy, rhs.pxl_dz, rhs.anchor, rhs.offset);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;init_orientation(rhs.row_unit, rhs.col_unit);

    <B><FONT COLOR="#A020F0">if</FONT></B>((rhs.data != nullptr) &amp;&amp; (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data != nullptr)){
        memcpy((<B><FONT COLOR="#228B22">void</FONT></B>*)(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data.get()), (<B><FONT COLOR="#228B22">void</FONT></B>*)(rhs.data.get()), <B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)*rhs.rows*rhs.columns*rhs.channels);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;T,R&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;T,R&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B> == &amp;rhs) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data == nullptr) &amp;&amp; (rhs.data != nullptr)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data != nullptr) &amp;&amp; (rhs.data == nullptr)) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows != rhs.rows) || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns != rhs.columns) || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;channels != rhs.channels)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dx != rhs.pxl_dx) || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dy != rhs.pxl_dy) || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dz != rhs.pxl_dz))   <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;anchor != rhs.anchor) || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;offset != rhs.offset)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit != rhs.row_unit) || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;col_unit != rhs.col_unit)) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data == nullptr) &amp;&amp; (rhs.data == nullptr)) <B><FONT COLOR="#A020F0">return</FONT></B> true;

    <I><FONT COLOR="#B22222">//If we get here, we need to compare each pixel.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; rhs.rows*rhs.columns*rhs.channels; ++i){
        <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data[i] != rhs.data[i]) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true; <I><FONT COLOR="#B22222">//Equal!
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;T,R&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;T,R&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> !(*<B><FONT COLOR="#A020F0">this</FONT></B> == rhs);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;T,R&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;T,R&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B> == &amp;rhs) <B><FONT COLOR="#A020F0">return</FONT></B> false;
 
    <I><FONT COLOR="#B22222">//First, compare the size (in sizeof(R)*bytes). The overall memory usage is probably a good comparison.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows*<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns*<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;channels &lt; rhs.rows*rhs.columns*rhs.channels) <B><FONT COLOR="#A020F0">return</FONT></B> true;

    <I><FONT COLOR="#B22222">//Handle the case of empty images.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data == nullptr) &amp;&amp; (rhs.data != nullptr)) <B><FONT COLOR="#A020F0">return</FONT></B> true;  <I><FONT COLOR="#B22222">//Arbitrary. Stick with convention, though.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data != nullptr) &amp;&amp; (rhs.data == nullptr)) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//Arbitrary. Stick with convention, though.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data == nullptr) || (rhs.data == nullptr)) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//Considered equal.
</FONT></I>
    <I><FONT COLOR="#B22222">//Next, compare the components of the zeroth pixel. This is also a shaky concept!
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> l = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position(0,0);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> r = rhs.position(0,0);
    <B><FONT COLOR="#A020F0">return</FONT></B> (l &lt; r);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Zero-based indexing (the default).
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> planar_image&lt;T,R&gt;::index(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;channels*( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns * row + col );
} 
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::index(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> c) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> planar_image&lt;T,R&gt;::index(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;channels*( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns * row + col ) + chnl;
} 
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::index(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Returns -1 on failure or out-of-bounds.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> planar_image&lt;T,R&gt;::index(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;point, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; P(point - <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;anchor - <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;offset);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Nr = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit.Dot(P)/<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dx;  <I><FONT COLOR="#B22222">// ~row.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Nc = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;col_unit.Dot(P)/<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dy;  <I><FONT COLOR="#B22222">// ~col.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Uz = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit.Cross(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;col_unit).unit(); <I><FONT COLOR="#B22222">//Unit along orthogonal direction.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Nz = Uz.Dot(P)/( static_cast&lt;R&gt;(2.0)*<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dz );

    <I><FONT COLOR="#B22222">//Check if it is too far out of the plane of the 2D image. Be inclusive in case the image thickness is 0.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!isininc((R)(-1.0),Nz,(R)(1.0))) <B><FONT COLOR="#A020F0">return</FONT></B> -1;

    <I><FONT COLOR="#B22222">//Now, Nr and Nc should (ideally) be integers. They will be very close in value to ints, too, except
</FONT></I>    <I><FONT COLOR="#B22222">// for floating point errors which may have blurred them slightly above or below the actual value.
</FONT></I>    <I><FONT COLOR="#B22222">// Because we do not expect the blur to be significant, we will just round them to the nearest int.
</FONT></I>    <I><FONT COLOR="#B22222">// If the blur is more than this, we have larger issues to deal with! 
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> row = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;( std::round(Nr) ); 
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> col = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;( std::round(Nc) );

    <B><FONT COLOR="#A020F0">if</FONT></B>(!isininc(0,row,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows-1) || !isininc(0,col,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns-1) || !isininc(0,chnl,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;channels)){
        <B><FONT COLOR="#A020F0">return</FONT></B> -1;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;index(row,col,chnl);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::index(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;point, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Channel-value getters.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">class</FONT></B> R&gt; T planar_image&lt;T,R&gt;::value(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(!isininc(0,row,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows-1) || !isininc(0,col,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns-1) || !isininc(0,chnl,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;channels)){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Attempted to access part of image which does not exist&quot;</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data[<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;index(row,col,chnl)];
} 
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::value(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Returns the value of the voxel which contains the point, or zero.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This function is very slow and not always very safe! Use it sparingly!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">class</FONT></B> R&gt; T planar_image&lt;T,R&gt;::value(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;point, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> indx = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;index(point,chnl); 
    <B><FONT COLOR="#A020F0">if</FONT></B>(indx == -1) <B><FONT COLOR="#A020F0">return</FONT></B> static_cast&lt;T&gt;(0);
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data[indx];
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::value(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;point, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Channel-value references. This can be used to set the values.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; T&amp; planar_image&lt;T,R&gt;::reference(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl){
    <B><FONT COLOR="#A020F0">if</FONT></B>(!isininc(0,row,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows-1) || !isininc(0,col,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns-1) || !isininc(0,chnl,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;channels)){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Attempted to access part of image which does not exist&quot;</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data[<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;index(row,col,chnl)];
} 
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::reference(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> chnl);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Get an R^3 position of the *center* of the pixel/voxel.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; vec3&lt;R&gt; planar_image&lt;T,R&gt;::position(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(!isininc(0,row,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows-1) || !isininc(0,col,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns-1)){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Attempted to access part of image which does not exist&quot;</FONT></B>);
    }
    vec3&lt;R&gt; out(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;anchor);
    out += <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;offset;
    out += <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit*(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dx*static_cast&lt;R&gt;(row));
    out += <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;col_unit*(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dy*static_cast&lt;R&gt;(col));
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::position(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> col) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Determine if a given point in R^3 is encompassed by this image (of 'thickness' pxl_dz).
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;T,R&gt;::encompasses_point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//This routine is suitable only for the rectangular slab images in this class.
</FONT></I>    <I><FONT COLOR="#B22222">// For a generic 3D bounding box routine, see the YgorMath.cc SANDBOX section.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Anyways: here we project the components of a given vector (minus the center of the image) 
</FONT></I>    <I><FONT COLOR="#B22222">// onto the natural coordinate system given by the row and column unit vecs. If the components
</FONT></I>    <I><FONT COLOR="#B22222">// have too large a projection, we know they must be outside the box.
</FONT></I>    
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> r0 = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position(           0,              0);
<I><FONT COLOR="#B22222">//    const auto r2 = this-&gt;position(this-&gt;rows-1,              0);
</FONT></I><I><FONT COLOR="#B22222">//    const auto r3 = this-&gt;position(this-&gt;rows-1,this-&gt;columns-1);   
</FONT></I><I><FONT COLOR="#B22222">//    const auto r4 = this-&gt;position(           0,this-&gt;columns-1);
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dt = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dz;

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> center      = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;center();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> rowdist     = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit.Dot(in - center);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> maxdistrow  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit.Dot(r0 - center);<I><FONT COLOR="#B22222">//Extra half-pixel width accounted for below.
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> coldist     = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;col_unit.Dot(in - center);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> maxdistcol  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;col_unit.Dot(r0 - center);<I><FONT COLOR="#B22222">//Extra half-pixel width accounted for below.
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> perpdist    = (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;col_unit.Cross(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit)).Dot(in - center);

    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORABS(perpdist) &gt;= (dt*0.5)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORABS(rowdist)  &gt;= (YGORABS(maxdistrow)+<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dx*0.5)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORABS(coldist)  &gt;= (YGORABS(maxdistcol)+<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dy*0.5)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::encompasses_point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;T,R&gt;::sandwiches_point_within_top_bottom_planes(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> center   = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;center();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dt = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dz;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> N = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;col_unit.Cross(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit).unit();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> perpdist = N.Dot(in - center);
    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORABS(perpdist) &gt;= (dt*0.5)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
    
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::sandwiches_point_within_top_bottom_planes(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Returns the R^3 center of the image. Nothing fancy.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; vec3&lt;R&gt; planar_image&lt;T,R&gt;::center(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> r0 = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position(           0,              0);
<I><FONT COLOR="#B22222">//    const auto r1 = this-&gt;position(this-&gt;rows-1,              0);
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> r2 = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows-1,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns-1);
<I><FONT COLOR="#B22222">//    const auto r3 = this-&gt;position(           0,this-&gt;columns-1);
</FONT></I><I><FONT COLOR="#B22222">//    return (r0+r1+r2+r3)/4.0;
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> (r0+r2)/2.0;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::center(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Returns an ordered list of the corners of the 2D image. Does NOT use thickness!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; std::list&lt;vec3&lt;R&gt;&gt; planar_image&lt;T,R&gt;::corners2D(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;vec3&lt;R&gt;&gt; out;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Rrow(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit*<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dx*(R)(0.5)); <I><FONT COLOR="#B22222">//Vectors along the row/col vecs. Used for 
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Rcol(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit*<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dx*(R)(0.5)); <I><FONT COLOR="#B22222">// translating the center to the corner.
</FONT></I>
    <I><FONT COLOR="#B22222">// Guaranteed point ordering:
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">// point(0,0)    point(#rows-1,0)
</FONT></I>    <I><FONT COLOR="#B22222">//     \             /
</FONT></I>    <I><FONT COLOR="#B22222">//       1---------2          positive
</FONT></I>    <I><FONT COLOR="#B22222">//       |         |    _____\ row_unit
</FONT></I>    <I><FONT COLOR="#B22222">//       |         |   |     /
</FONT></I>    <I><FONT COLOR="#B22222">//       |         |   | 
</FONT></I>    <I><FONT COLOR="#B22222">//       |         |   |   positive
</FONT></I>    <I><FONT COLOR="#B22222">//       4---------3  \|/  col_unit
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Do *NOT* change the order of these points!
</FONT></I>    out.push_back(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position(           0,              0) - Rrow - Rcol);
    out.push_back(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows-1,              0) + Rrow - Rcol);
    out.push_back(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows-1,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns-1) + Rrow + Rcol);
    out.push_back(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position(           0,<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns-1) - Rrow + Rcol);
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::corners2D(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Returns true if the 3D volume of this image encompasses the 2D image of the given planar image.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;T,R&gt;::encloses_2D_planar_image(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;T,R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//This routine is slightly tricky because the encompass routines do not (and should not) include points
</FONT></I>    <I><FONT COLOR="#B22222">// exactly on the boundary as being &quot;encompassed.&quot;
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Therefore, we do a bit of a 'fuzzy' check here.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> inc = in.corners2D();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> thisc = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;corners2D();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> scale = 0.5*YGORMIN(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dx + <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dy, in.pxl_dx + in.pxl_dy);

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = inc.begin(); p_it != inc.end(); ++p_it){
        <I><FONT COLOR="#B22222">//If the point is truly inside, no problem. If not, investigate further.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;encompasses_point(*p_it)){
            <I><FONT COLOR="#B22222">//Slightly adjust the corner point and test it.
</FONT></I>            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> unit  = (*p_it - <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;center()).unit();
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Rtest = *p_it - unit*scale*(R)(0.01); <I><FONT COLOR="#B22222">//100x smaller than the smallest voxel width.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;encompasses_point(Rtest)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::encloses_2D_planar_image(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Compare the geometrical (non-pixel/voxel) aspects of the image to another.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Returns false if the images do *not* have similar geometrical properties. There might be some 
</FONT></I><I><FONT COLOR="#B22222">// ambiguity in what is meant by &quot;similar&quot;, but it is necessary since we are dealing with floating-point
</FONT></I><I><FONT COLOR="#B22222">// values.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;T,R&gt;::Compare_Geom(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;T,R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>( (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows     != in.rows)
     || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns  != in.columns)
     || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;channels != in.channels)
     || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dx   != in.pxl_dx)
     || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dy   != in.pxl_dy)
     || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;pxl_dz   != in.pxl_dz)
     || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;anchor   != in.anchor)
     || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;offset   != in.offset)
     || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;row_unit != in.row_unit)
     || (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;col_unit != in.col_unit)    ){
<I><FONT COLOR="#B22222">/*
         //Spit out some useful diagnostic info...
         FUNCINFO(&quot;Geometry of images does not match. Here are the specifics:&quot;);
         FUNCINFO(&quot;rows     LHS: &quot; &lt;&lt; this-&gt;rows &lt;&lt; &quot;, RHS: &quot; &lt;&lt; in.rows);
         FUNCINFO(&quot;columns  LHS: &quot; &lt;&lt; this-&gt;columns &lt;&lt; &quot;, RHS: &quot; &lt;&lt; in.columns);
         FUNCINFO(&quot;channels LHS: &quot; &lt;&lt; this-&gt;channels &lt;&lt; &quot;, RHS: &quot; &lt;&lt; in.channels);
         FUNCINFO(&quot;pxl_dx   LHS: &quot; &lt;&lt; this-&gt;pxl_dx &lt;&lt; &quot;, RHS: &quot; &lt;&lt; in.pxl_dx);
         FUNCINFO(&quot;pxl_dy   LHS: &quot; &lt;&lt; this-&gt;pxl_dy &lt;&lt; &quot;, RHS: &quot; &lt;&lt; in.pxl_dy);
         FUNCINFO(&quot;pxl_dz   LHS: &quot; &lt;&lt; this-&gt;pxl_dz &lt;&lt; &quot;, RHS: &quot; &lt;&lt; in.pxl_dz);
         FUNCINFO(&quot;anchor   LHS: &quot; &lt;&lt; this-&gt;anchor &lt;&lt; &quot;, RHS: &quot; &lt;&lt; in.anchor);
         FUNCINFO(&quot;offset   LHS: &quot; &lt;&lt; this-&gt;offset &lt;&lt; &quot;, RHS: &quot; &lt;&lt; in.offset);
         FUNCINFO(&quot;row_unit LHS: &quot; &lt;&lt; this-&gt;row_unit &lt;&lt; &quot;, RHS: &quot; &lt;&lt; in.row_unit);
         FUNCINFO(&quot;col_unit LHS: &quot; &lt;&lt; this-&gt;col_unit &lt;&lt; &quot;, RHS: &quot; &lt;&lt; in.col_unit);         
*/</FONT></I>
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Compare_Geom(<B><FONT COLOR="#228B22">const</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Plot an outline of the image. Useful for alignment testing.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">void</FONT></B> planar_image&lt;T,R&gt;::Plot_Outline(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    Plotter3 a_plot;
    a_plot.Set_Global_Title(<B><FONT COLOR="#BC8F8F">&quot;Image Outline&quot;</FONT></B>);<I><FONT COLOR="#B22222">//: Object with address &quot; + Xtostring&lt;long int&gt;((size_t)((void *)(this))));
</FONT></I>    vec3&lt;R&gt; r;
    r = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position(            0,               0);    a_plot.Insert(r.x,r.y,r.z);
    r = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows-1,               0);    a_plot.Insert(r.x,r.y,r.z);
    r = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;rows-1, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns-1);    a_plot.Insert(r.x,r.y,r.z);
    r = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position(            0, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;columns-1);    a_plot.Insert(r.x,r.y,r.z);
    r = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;position(            0,               0);    a_plot.Insert(r.x,r.y,r.z); <I><FONT COLOR="#B22222">//Close the contour.
</FONT></I>    a_plot.Next_Line_Same_Style();
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Plot_Outline(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------- image_collection: a collection of logically-related planar_images  -----------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; planar_image_collection&lt;T,R&gt;::planar_image_collection() {}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::planar_image_collection();
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; planar_image_collection&lt;T,R&gt;::planar_image_collection(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;T,R&gt; &amp;in) : images(in.images) {}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::planar_image_collection(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; planar_image_collection&lt;T,R&gt;::planar_image_collection(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;planar_image&lt;T,R&gt;&gt; &amp;in) : images(in) {}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::planar_image_collection(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Member functions.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; planar_image_collection&lt;T,R&gt; &amp; planar_image_collection&lt;T,R&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;T,R&gt; &amp;rhs){
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B> == &amp;rhs) <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images = rhs.images;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">bool</FONT></B> planar_image_collection&lt;T,R&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;T,R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//First, check the obvious things.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.size() != in.images.size()) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <I><FONT COLOR="#B22222">//Now walk through the data and compare piecewise.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> itA = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.begin(), itB = in.images.begin(); (itA != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.end()) &amp;&amp; (itB != in.images.end()); ++itA, ++itB){
        <B><FONT COLOR="#A020F0">if</FONT></B>((*itA) != (*itB)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">bool</FONT></B> planar_image_collection&lt;T,R&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;T,R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> !(*<B><FONT COLOR="#A020F0">this</FONT></B> == in);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">bool</FONT></B> planar_image_collection&lt;T,R&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;T,R&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Compares the number of images, and then compares ONLY the first image. 
</FONT></I>    <I><FONT COLOR="#B22222">//                                                           NOTE TO SELF: Would it be at all advantageous to sort the 
</FONT></I>    <I><FONT COLOR="#B22222">//                                                           images prior to comparing the first two? Will it ever matter??
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.size() != rhs.images.size()) <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.size() &lt; rhs.images.size());
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> itA = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.begin(), itB = rhs.images.begin();
    <B><FONT COLOR="#A020F0">return</FONT></B> ((*itA) &lt; (*itB));
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Returns a list of pointers to images which encompass a given point. Be careful not to invalidate the data!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; std::list&lt;typename std::list&lt;planar_image&lt;T,R&gt;&gt;::const_iterator&gt; planar_image_collection&lt;T,R&gt;::get_images_which_encompass_point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;typename std::list&lt;planar_image&lt;T,R&gt;&gt;::const_iterator&gt; out;

    <I><FONT COLOR="#B22222">//Cycle through all of the images. Not ideal - we should sort the images in some predictable way instead. (If needed!)
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> i_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.begin(); i_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.end(); ++i_it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(i_it-&gt;encompasses_point(in)) out.push_back(i_it);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;typename std::list&lt;planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator&gt; planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::get_images_which_encompass_point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Returns a list of pointers to images which are sandwiched between the infinite planes lying along the top and bottom of the planar image (of finite thickness). 
</FONT></I><I><FONT COLOR="#B22222">// Be careful not to invalidate the data!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; std::list&lt;typename std::list&lt;planar_image&lt;T,R&gt;&gt;::const_iterator&gt; planar_image_collection&lt;T,R&gt;::get_images_which_sandwich_point_within_top_bottom_planes(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;typename std::list&lt;planar_image&lt;T,R&gt;&gt;::const_iterator&gt; out;

    <I><FONT COLOR="#B22222">//Cycle through all of the images. Not ideal - we should sort the images in some predictable way instead. (If needed!)
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> i_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.begin(); i_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.end(); ++i_it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(i_it-&gt;sandwiches_point_within_top_bottom_planes(in)) out.push_back(i_it);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;typename std::list&lt;planar_image&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;::const_iterator&gt; planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::get_images_which_sandwich_point_within_top_bottom_planes(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Returns the R^3 center of the image. Nothing fancy.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; vec3&lt;R&gt; planar_image_collection&lt;T,R&gt;::center(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.empty()) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to compute center-point. This collection contains no images&quot;</FONT></B>);
    vec3&lt;R&gt; out;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> i_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.begin(); i_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.end(); ++i_it){
        out += i_it-&gt;center();
    }
    out /= static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.size());
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::center(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Compare the geometrical (non-pixel/voxel) aspects of the images to one another.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Returns a false if the image collections appear geometrically different. This is basically an operator==
</FONT></I><I><FONT COLOR="#B22222">// but does *not* examine the pixel/voxel values.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">bool</FONT></B> planar_image_collection&lt;T,R&gt;::Compare_Geom(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;T,R&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.size() != in.images.size()){
<B><FONT COLOR="#0000FF">FUNCINFO</FONT></B>(<B><FONT COLOR="#BC8F8F">&quot;image count: this: &quot;</FONT></B> &lt;&lt; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.size() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; and rhs: &quot;</FONT></B> &lt;&lt; in.images.size());
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#228B22">auto</FONT></B> img1_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.begin();
    <B><FONT COLOR="#228B22">auto</FONT></B> img2_it = in.images.begin();
    <B><FONT COLOR="#A020F0">for</FONT></B>(  ; (img1_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.end()) &amp;&amp; (img2_it != in.images.end()); ++img1_it, ++img2_it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(!img1_it-&gt;Compare_Geom(*img2_it)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Compare_Geom(<B><FONT COLOR="#228B22">const</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>



<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">void</FONT></B> planar_image_collection&lt;T,R&gt;::Plot_Outlines(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title) <B><FONT COLOR="#228B22">const</FONT></B> {
    Plotter3 a_plot;
    a_plot.Set_Global_Title(title);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.begin(); it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;images.end(); ++it){
        vec3&lt;R&gt; r;
        r = it-&gt;position(          0,             0);    a_plot.Insert(r.x,r.y,r.z);
        r = it-&gt;position( it-&gt;rows-1,             0);    a_plot.Insert(r.x,r.y,r.z);
        r = it-&gt;position( it-&gt;rows-1, it-&gt;columns-1);    a_plot.Insert(r.x,r.y,r.z);
        r = it-&gt;position(          0, it-&gt;columns-1);    a_plot.Insert(r.x,r.y,r.z);
        r = it-&gt;position(          0,             0);    a_plot.Insert(r.x,r.y,r.z); <I><FONT COLOR="#B22222">//Close the contour.
</FONT></I>        a_plot.Next_Line_Same_Style();
    }
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Plot_Outlines(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T,<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">void</FONT></B> planar_image_collection&lt;T,R&gt;::Plot_Outlines(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Plot_Outlines(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>); <I><FONT COLOR="#B22222">//No title.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGOR_IMAGES_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> planar_image_collection&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Plot_Outlines(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------- postscriptinator: a thin class for generating Postscript images -------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This class generates Postscript files from simple data. It was developed to convert the workflow 
</FONT></I><I><FONT COLOR="#B22222">// R^3 -&gt; OpenGL Bitmap -&gt; R^3 (using potrace or similar) into just R^3.
</FONT></I>
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> R&gt; 
postscriptinator&lt;R&gt;::postscriptinator(){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;xmin = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;ymin = (R)( 1E99);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;xmax = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;ymax = (R)(-1E99);

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;PageW = 21.0; <I><FONT COLOR="#B22222">//[cm]
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;PageW = 24.0; <I><FONT COLOR="#B22222">//[cm]
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Enable_Auto_Sizing = true;

    <I><FONT COLOR="#B22222">//Set the page dimensions and coordinates.
</FONT></I>    <I><FONT COLOR="#B22222">// Bottom left corner: (0,0). Top right: (21,24). Units are [cm]. Page size is 8.5&quot;x11&quot;.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Header += <B><FONT COLOR="#BC8F8F">&quot;%!PS\n&quot;</FONT></B>;

    <I><FONT COLOR="#B22222">//Some definitions which are used to ~compress the resulting file.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Definitions += <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Definitions += <B><FONT COLOR="#BC8F8F">&quot;/m {newpath moveto} bind def\n&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Definitions += <B><FONT COLOR="#BC8F8F">&quot;/l {lineto} bind def\n&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Definitions += <B><FONT COLOR="#BC8F8F">&quot;/cp {closepath} bind def\n&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Definitions += <B><FONT COLOR="#BC8F8F">&quot;/s {stroke} bind def\n&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Definitions += <B><FONT COLOR="#BC8F8F">&quot;/sg {setgray} bind def\n&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Definitions += <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;

    <I><FONT COLOR="#B22222">//Closing things.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Footer += <B><FONT COLOR="#BC8F8F">&quot;showpage\n&quot;</FONT></B>;
}


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> R&gt; <B><FONT COLOR="#228B22">void</FONT></B> postscriptinator&lt;R&gt;::Import_Contour(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;R&gt; &amp;C, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;R&gt; &amp;Proj2){
    <I><FONT COLOR="#B22222">//Performs two passes. First is to adjust the min/max values.
</FONT></I>

<B><FONT COLOR="#0000FF">FUNCERR</FONT></B>(<B><FONT COLOR="#BC8F8F">&quot;This routine has not yet been written!&quot;</FONT></B>);

}


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> R&gt; std::string postscriptinator&lt;R&gt;::Generate_Page_Geom(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    <I><FONT COLOR="#B22222">//Compute the page dimension/density information.
</FONT></I>    <I><FONT COLOR="#B22222">//Default is: 72 dpi (ie. 28.3465 dots/cm).
</FONT></I>    out += <B><FONT COLOR="#BC8F8F">&quot;matrix currentmatrix /originmat exch def\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;/umatrix {originmat matrix concatmatrix setmatrix} def\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;[28.3465 0 0 28.3465 10.5 100.0] umatrix\n&quot;</FONT></B>;

    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> R&gt; std::string postscriptinator&lt;R&gt;::Assemble(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    out += <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Header;
    out += <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Definitions;
    out += <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Generate_Page_Geom();    
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Stack.begin(); it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Stack.end(); ++it){
        out += *it;
    }
    out += <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Footer;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}




</PRE>
<HR>
<A NAME="file29">
<H1>YgorMath.cc 29/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file28">prev</A>][<A HREF="#file30">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorMath.cc.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>       //Needed for fabs, signbit, sqrt, etc...
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;fstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>   //Needed for std::reverse.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;map&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;unordered_map&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iterator&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;functional&gt;</FONT></B>  //Needed for passing kernel functions to integration schemes.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>      //Needed for stringification routines.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;tuple&gt;</FONT></B>       //Needed for Spearman's Rank Correlation Coeff, other statistical routines.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;limits&gt;</FONT></B>      //Needed for std::numeric_limits::max().
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

<I><FONT COLOR="#B22222">//#include &lt;iomanip&gt;   //REMOVE ME - used for testing!
</FONT></I>
<I><FONT COLOR="#B22222">//#include &lt;gsl/gsl_math.h&gt;
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;gsl/gsl_sf_gamma.h&gt;
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMath.h&quot;</FONT></B>
<I><FONT COLOR="#B22222">//#include &quot;YgorStats.h&quot;
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>    //For the FUNC* and PERCENT_ERR macro functions.

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorFilesDirs.h&quot;</FONT></B>  //Used in samples_1D&lt;T&gt;::Write_To_File(...).

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorPlot.h&quot;</FONT></B>    //A wrapper used for producing plots of contours.
<B><FONT COLOR="#228B22">class</FONT></B> Plotter;

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    #define YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Forward declaration. Needed due to mixing of classes (find point where line and plane intersect, etc..)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">class</FONT></B> vec3;
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">class</FONT></B> vec2;
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">class</FONT></B> line;
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">class</FONT></B> line_segment;
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">class</FONT></B> plane;
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">class</FONT></B> contour_of_points;


<I><FONT COLOR="#B22222">/*
double Stats::P_From_StudT_1Tail(double tval, double dof){
    const double y = std::sqrt(tval*tval + dof);
    const double x = 0.5*(y - tval)/y;
    const double a = dof/2.0;
    const double b = dof/2.0;

    //Regularized beta ratio function (I_x(a,b) = B_x(a,b)/B(a,b)).
    const double reg_beta_incom = gsl_sf_beta_inc(a,b,x); 
    return reg_beta_incom;
}

double Stats::P_From_StudT_2Tail(double tval, double dof){
    if(tval &gt;= 0.0) return 2.0*Stats::P_From_StudT_1Tail(tval,dof);
    return 2.0*Stats::P_From_StudT_1Tail(-tval,dof);
}

double Stats::P_From_StudT_Diff_Means_From_Uneq_Vars(double M1, double S1, double N1, double M2, double S2, double N2){
    //Given two means (M1 and M2) with associated (possibly non-equal) variances, compute the significance
    // that the means are different. In other words, given the means, what is the probability that they 
    // are drawn from the same population? Are the means significantly different?
    //
    //Input:
    //  - M1 and M2 - the means of either distribution. I don't believe this routine is applicable to 
    //      other quantities. See numerical recipes for a nice discussion.
    //  - S1 and S2 - the sigma (ie. one std.dev. or `variance') of either distribution.
    //  - N1 and N2 - the number of points in either distribution. *NOT* the DOF!
    //
    //This routine is often used to determine if some quantity has changed significantly. Examples could be
    // a quantity changing at two points in time, or comparison of non-linear fitting parameters obtained
    // with two different techniques (ie. least-sum of squares vs. least-median of squares).
    //
    //Logically, it is similar to the area of overlap of the two distributions. Obviously, if the 
    // distributions have wildly different means or variances, this routine may not appropriate. 
    //
    //NOTE: This tests significance in the difference of means. Do not conflate significance of means
    //      with significance in difference of the distributions themselves! 
    if((N1 &lt; 2.0) || (N2 &lt; 2.0)) FUNCERR(&quot;Not enough points available for computation&quot;);

    const double t_num = M1 - M2;
    const double t_den = std::sqrt((S1/N1)+(S2/N2));
    if(!std::isnormal(t_den)) FUNCERR(&quot;Encountered difficulty computing Student's t-value. Cannot continue&quot;);
 
    const double dof_num = std::pow((S1/N1)+(S2/N2),2.0);
    const double dof_den = ((S1*S1)/(N1*N1*(N1-1.0))) + ((S2*S2)/(N2*N2*(N2-1.0)));
    if(!std::isnormal(dof_den)) FUNCERR(&quot;Encountered difficulty computing dof. Cannot continue&quot;);

    return Stats::P_From_StudT_2Tail(t_num/t_den, dof_num/dof_den);
}



double Stats::Q_From_ChiSq_Fit(double chi_square, double dof){
    //See Numerical Recipes, C, Section 6.2 (pp 221) or section on nonlinear fitting.
    //
    //NOTE: This function should use the chi-square which includes uncertainties.
    //NOTE: This function should not use the reduced chi-square!
    //
    // A ~decent fit has Q &gt; 0.001 (although a little low).
    // If Q is too near 1.0, the errors are probably overestimated.
    // If Q is a little lower then 0.001, errors are probably underestimated.
    // If Q is very low (&lt;1E-6) the model is a terrible fit.
    return gsl_sf_gamma_inc_Q(dof/2.0, chi_square/2.0);
}


double Stats::Unbiased_Var_Est(std::list&lt;double&gt; in){
    //This is an unbiased estimate of a population's variance, as computed from a
    // finite sample size. If you have the *entire* population (ie. every entity)
    // then this will produce a slightly incorrect value. See 
    // http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance for more
    // info.
    if(in.empty()) FUNCERR(&quot;Cannot compute variance of empty set. Unable to continue&quot;);
    if(in.size() == 1) FUNCERR(&quot;Cannot estimate variance from single point. Unable to continue&quot;);
    if(in.size() &lt;= 5) FUNCWARN(&quot;Very few points were used to estimate variance. Be weary of result&quot;);

    in.sort(); //Sort it now and avoid having to do so again (twice) from scratch.
    double n = static_cast&lt;double&gt;(in.size());
    return (Ygor_Sum_Squares(in) - pow(Ygor_Sum(in),2.0)/n)/(n-1);
}

*/</FONT></I>

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Ygor_Sum</FONT></B>(std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; in){
    in.sort(); <I><FONT COLOR="#B22222">// &lt;-- trying to reduce gross errors from occuring during summation.
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> res = 0.0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.begin(); it != in.end(); ++it) res += *it;
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Ygor_Sum_Squares</FONT></B>(std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; in){
    in.sort(); <I><FONT COLOR="#B22222">// &lt;-- trying to reduce gross errors from occuring during summation.
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> res = 0.0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.begin(); it != in.end(); ++it) res += (*it)*(*it);
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Ygor_Median</FONT></B>(std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; in){
    <B><FONT COLOR="#A020F0">if</FONT></B>(in.empty()) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Cannot compute median of empty set. Unable to continue&quot;</FONT></B>);
    in.sort();
    size_t N = in.size();
    size_t M = N/2;
    <B><FONT COLOR="#228B22">auto</FONT></B> it = std::next(in.begin(),M-1);
    <B><FONT COLOR="#A020F0">if</FONT></B>(2*M == N){ <I><FONT COLOR="#B22222">//N % 2 == 0){
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> L = *it;
        ++it;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> R = *it;
        <B><FONT COLOR="#A020F0">return</FONT></B> (L+R)/2.0;
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((2*M+1) != N){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Programming error...late night...tired...writing...thesis...ugh....fixme&quot;</FONT></B>);
    }
    ++it;
    <B><FONT COLOR="#A020F0">return</FONT></B> *it;
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Ygor_Mean</FONT></B>(std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; in){
    <I><FONT COLOR="#B22222">//Speed? Efficiency? Careful attention to potential signal degredation? Go nuts!
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(in.empty()) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Cannot compute mean of empty set. Unable to continue&quot;</FONT></B>);

    <B><FONT COLOR="#A020F0">return</FONT></B> Ygor_Sum(in) / static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(in.size());
}


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------- vec3: A three-dimensional vector -------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Constructors.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt;::vec3(){   x=(T)(0);   y=(T)(0);   z=(T)(0);  }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt;::vec3(void);
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt;::vec3(void);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::vec3(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::vec3(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt;::vec3(T a, T b, T c) : x(a), y(b), z(c) { }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt;::vec3(int, int, int);
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt;::vec3(long int, long int, long int);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::vec3(<B><FONT COLOR="#228B22">float</FONT></B>, <B><FONT COLOR="#228B22">float</FONT></B>, <B><FONT COLOR="#228B22">float</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::vec3(<B><FONT COLOR="#228B22">double</FONT></B>, <B><FONT COLOR="#228B22">double</FONT></B>, <B><FONT COLOR="#228B22">double</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt;::vec3( <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;in ) : x(in.x), y(in.y), z(in.z) { }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt;::vec3( const vec3&lt;int&gt; &amp; );
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt;::vec3( const vec3&lt;long int&gt; &amp; );
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::vec3( <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; );
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::vec3( <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; );
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<I><FONT COLOR="#B22222">//More general: (but is it needed?)
</FONT></I><I><FONT COLOR="#B22222">//template&lt;class Ch,class Tr,class T&gt;     std::basic_ostream&lt;Ch,Tr&gt; &amp; operator&lt;&lt;( std::basic_ostream&lt;Ch,Tr&gt; &amp;&amp;out, const vec3&lt;T&gt; &amp;L ){
</FONT></I><I><FONT COLOR="#B22222">//    out &lt;&lt; &quot;(&quot; &lt;&lt; L.x &lt;&lt; &quot;, &quot; &lt;&lt; L.y &lt;&lt; &quot;, &quot; &lt;&lt; L.z &lt;&lt; &quot;)&quot;;
</FONT></I><I><FONT COLOR="#B22222">//    return out;
</FONT></I><I><FONT COLOR="#B22222">//}
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;( std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;L ){
    <I><FONT COLOR="#B22222">//Note: This friend is templated (Y) within the templated class (T). We only
</FONT></I>    <I><FONT COLOR="#B22222">// care about friend template when T==Y.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//There is significant whitespace here!
</FONT></I>    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> &lt;&lt; L.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B> &lt;&lt; L.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B> &lt;&lt; L.z &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, const vec3&lt;int&gt; &amp;L );
</FONT></I><I><FONT COLOR="#B22222">//    template std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, const vec3&lt;long int&gt; &amp;L );
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;L );
    <B><FONT COLOR="#228B22">template</FONT></B> std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;L );
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec3&lt;T&gt; vec3&lt;T&gt;::Cross(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> T thex = (*<B><FONT COLOR="#A020F0">this</FONT></B>).y * in.z - (*<B><FONT COLOR="#A020F0">this</FONT></B>).z * in.y;
    <B><FONT COLOR="#228B22">const</FONT></B> T they = (*<B><FONT COLOR="#A020F0">this</FONT></B>).z * in.x - (*<B><FONT COLOR="#A020F0">this</FONT></B>).x * in.z;
    <B><FONT COLOR="#228B22">const</FONT></B> T thez = (*<B><FONT COLOR="#A020F0">this</FONT></B>).x * in.y - (*<B><FONT COLOR="#A020F0">this</FONT></B>).y * in.x;
    <B><FONT COLOR="#A020F0">return</FONT></B> vec3&lt;T&gt;( thex, they, thez );
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;  vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Cross(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> ;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Cross(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> ;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
   
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec3&lt;T&gt; vec3&lt;T&gt;::Mask(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> T thex = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;x * in.x;
    <B><FONT COLOR="#228B22">const</FONT></B> T they = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;y * in.y;
    <B><FONT COLOR="#228B22">const</FONT></B> T thez = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;z * in.z;
    <B><FONT COLOR="#A020F0">return</FONT></B> vec3&lt;T&gt;( thex, they, thez );
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;  vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Mask(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> ;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Mask(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> ;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B> 
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; T vec3&lt;T&gt;::Dot(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (*<B><FONT COLOR="#A020F0">this</FONT></B>).x * in.x + (*<B><FONT COLOR="#A020F0">this</FONT></B>).y * in.y + (*<B><FONT COLOR="#A020F0">this</FONT></B>).z * in.z;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Dot(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Dot(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec3&lt;T&gt; vec3&lt;T&gt;::unit(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> T tot = sqrt(x*x + y*y + z*z);
    <B><FONT COLOR="#A020F0">return</FONT></B> vec3&lt;T&gt;(x/tot, y/tot, z/tot);
} 
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::unit(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::unit(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; T vec3&lt;T&gt;::length(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> T tot = sqrt(x*x + y*y + z*z);
    <B><FONT COLOR="#A020F0">return</FONT></B> tot;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::length(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::length(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  T vec3&lt;T&gt;::distance(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> T dist = sqrt((x-rhs.x)*(x-rhs.x) + (y-rhs.y)*(y-rhs.y) + (z-rhs.z)*(z-rhs.z));
    <B><FONT COLOR="#A020F0">return</FONT></B> dist;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::distance(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::distance(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
<I><FONT COLOR="#B22222">/*
template &lt;class T&gt;  T vec3&lt;T&gt;::distance(vec3 rhs){
    const T dist = sqrt((x-rhs.x)*(x-rhs.x) + (y-rhs.y)*(y-rhs.y) + (z-rhs.z)*(z-rhs.z));
    return dist;
}
    
template float vec3&lt;float&gt;::distance(vec3&lt;float&gt; rhs);
template double vec3&lt;double&gt;::distance(vec3&lt;double&gt; rhs);
*/</FONT></I>
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  T vec3&lt;T&gt;::sq_dist(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> ((x-rhs.x)*(x-rhs.x) + (y-rhs.y)*(y-rhs.y) + (z-rhs.z)*(z-rhs.z));
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::sq_dist(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::sq_dist(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    std::istream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&gt;&gt;(std::istream &amp;in, vec3&lt;T&gt; &amp;L){
    <I><FONT COLOR="#B22222">//Note: This friend is templated (Y) within the templated class (T). We only
</FONT></I>    <I><FONT COLOR="#B22222">// care about friend template when T==Y.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//... &lt;&lt; &quot;(&quot;  &lt;&lt; L.x &lt;&lt; &quot;, &quot; &lt;&lt; L.y &lt;&lt; &quot;, &quot; &lt;&lt;  L.z  &lt;&lt;  &quot;)&quot;;
</FONT></I>    <I><FONT COLOR="#B22222">//We have at least TWO options here. We can use a method which is compatible
</FONT></I>    <I><FONT COLOR="#B22222">// with the ( , , ) notation, or we can ask for straight-up numbers. 
</FONT></I>    <I><FONT COLOR="#B22222">//We will discriminate here based on what 'in' is.
</FONT></I><I><FONT COLOR="#B22222">//    if(&amp;in != &amp;std::cin){                                            //Neat trick, but makes it hard to build on...
</FONT></I>        <B><FONT COLOR="#228B22">char</FONT></B> grbg;
        <I><FONT COLOR="#B22222">//... &lt;&lt; &quot;(&quot;  &lt;&lt; L.x &lt;&lt; &quot;, &quot; &lt;&lt; L.y &lt;&lt; &quot;, &quot; &lt;&lt;  L.z  &lt;&lt;  &quot;)&quot;;
</FONT></I>        in    &gt;&gt; grbg &gt;&gt; L.x &gt;&gt; grbg &gt;&gt; L.y &gt;&gt; grbg &gt;&gt;  L.z  &gt;&gt; grbg;
<I><FONT COLOR="#B22222">//    }else  in &gt;&gt; L.x &gt;&gt; L.y &gt;&gt; L.z;
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> in;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template std::istream &amp; operator&gt;&gt;(std::istream &amp;out, vec3&lt;int&gt; &amp;L );
</FONT></I><I><FONT COLOR="#B22222">//    template std::istream &amp; operator&gt;&gt;(std::istream &amp;out, vec3&lt;long int&gt; &amp;L );
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> std::istream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;&gt;(std::istream &amp;out, vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;L );
    <B><FONT COLOR="#228B22">template</FONT></B> std::istream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;&gt;(std::istream &amp;out, vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;L );
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
     
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt; &amp; vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;rhs) {
    <I><FONT COLOR="#B22222">//Check if it is itself.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B> == &amp;rhs) <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>; 
    (*<B><FONT COLOR="#A020F0">this</FONT></B>).x = rhs.x;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).y = rhs.y;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).z = rhs.z;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt; &amp; vec3&lt;int&gt;::operator=(const vec3&lt;int&gt; &amp;rhs);
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt; &amp; vec3&lt;long int&gt;::operator=(const vec3&lt;long int&gt; &amp;rhs);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt; vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> vec3&lt;T&gt;( (*<B><FONT COLOR="#A020F0">this</FONT></B>).x + rhs.x, (*<B><FONT COLOR="#A020F0">this</FONT></B>).y + rhs.y, (*<B><FONT COLOR="#A020F0">this</FONT></B>).z + rhs.z);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt; vec3&lt;int&gt;::operator+(const vec3&lt;int&gt; &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt; vec3&lt;long int&gt;::operator+(const vec3&lt;long int&gt; &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt; &amp; vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;rhs) {
    (*<B><FONT COLOR="#A020F0">this</FONT></B>).x += rhs.x;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).y += rhs.y;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).z += rhs.z;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt; &amp; vec3&lt;int&gt;::operator+=(const vec3&lt;int&gt; &amp;rhs);
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt; &amp; vec3&lt;long int&gt;::operator+=(const vec3&lt;long int&gt; &amp;rhs);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec3&lt;T&gt; vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> vec3&lt;T&gt;( (*<B><FONT COLOR="#A020F0">this</FONT></B>).x - rhs.x, (*<B><FONT COLOR="#A020F0">this</FONT></B>).y - rhs.y, (*<B><FONT COLOR="#A020F0">this</FONT></B>).z - rhs.z);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt; vec3&lt;int&gt;::operator-(const vec3&lt;int&gt; &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt; vec3&lt;long int&gt;::operator-(const vec3&lt;long int&gt; &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt; &amp; vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;rhs) {
    (*<B><FONT COLOR="#A020F0">this</FONT></B>).x -= rhs.x;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).y -= rhs.y;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).z -= rhs.z;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt; &amp; vec3&lt;int&gt;::operator-=(const vec3&lt;int&gt; &amp;rhs);
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt; &amp; vec3&lt;long int&gt;::operator-=(const vec3&lt;long int&gt; &amp;rhs);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
<I><FONT COLOR="#B22222">//------------------------------ overloaded native-types -----------------------------
</FONT></I>
<I><FONT COLOR="#B22222">/*
template &lt;class T&gt;    vec3&lt;T&gt; vec3&lt;T&gt;::operator*(const T rhs) {
    return vec3&lt;T&gt;(x*rhs,y*rhs,z*rhs);
}
template &lt;class T&gt;    vec3&lt;T&gt; &amp; vec3&lt;T&gt;::operator*=(const T rhs) {
    (*this).x *= rhs;    (*this).y *= rhs;    (*this).z *= rhs;
     return *this;
}
template vec3&lt;int&gt; &amp; vec3&lt;int&gt;::operator*=(const int rhs);
template vec3&lt;float&gt; &amp; vec3&lt;float&gt;::operator*=(const float rhs);
template vec3&lt;double&gt; &amp; vec3&lt;double&gt;::operator*=(const double rhs);



template &lt;class T&gt;    vec3&lt;T&gt; vec3&lt;T&gt;::operator/(const T rhs) {
    return vec3&lt;T&gt;(x/rhs,y/rhs,z/rhs);
}
template &lt;class T&gt;    vec3&lt;T&gt; &amp; vec3&lt;T&gt;::operator/=(const T rhs) {
    (*this).x /= rhs;    (*this).y /= rhs;    (*this).z /= rhs;
     return *this;
}
template vec3&lt;int&gt; &amp; vec3&lt;int&gt;::operator/=(const int rhs);
template vec3&lt;float&gt; &amp; vec3&lt;float&gt;::operator/=(const float rhs);
template vec3&lt;double&gt; &amp; vec3&lt;double&gt;::operator/=(const double rhs);
*/</FONT></I>

<I><FONT COLOR="#B22222">//--------
</FONT></I>
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt; vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> vec3&lt;T&gt;(x*rhs,y*rhs,z*rhs);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt; vec3&lt;int&gt;::operator*(const int &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt; vec3&lt;long int&gt;::operator*(const long int &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt; &amp; vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*=(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;rhs) {
    (*<B><FONT COLOR="#A020F0">this</FONT></B>).x *= rhs;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).y *= rhs;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).z *= rhs;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt; &amp; vec3&lt;int&gt;::operator*=(const int &amp;rhs);
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt; &amp; vec3&lt;long int&gt;::operator*=(const long int &amp;rhs);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*=(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*=(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt; vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> vec3&lt;T&gt;(x/rhs,y/rhs,z/rhs);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt; vec3&lt;int&gt;::operator/(const int &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt; vec3&lt;long int&gt;::operator/(const long int &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt; &amp; vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/=(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;rhs) {
    (*<B><FONT COLOR="#A020F0">this</FONT></B>).x /= rhs;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).y /= rhs;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).z /= rhs;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec3&lt;int&gt; &amp; vec3&lt;int&gt;::operator/=(const int &amp;rhs);
</FONT></I><I><FONT COLOR="#B22222">//    template vec3&lt;long int&gt; &amp; vec3&lt;long int&gt;::operator/=(const long int &amp;rhs);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/=(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/=(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    <B><FONT COLOR="#228B22">bool</FONT></B> vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//There are, of course, varying degrees of equality for floating-point values.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Typically the safest approach is an exact bit-wise equality using ==. This is
</FONT></I>    <I><FONT COLOR="#B22222">// the least flexible but most reliable. 
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> ( (x == rhs.x) &amp;&amp; (y == rhs.y) &amp;&amp; (z == rhs.z) );


    <I><FONT COLOR="#B22222">//Define a maximum relative difference threshold. If above this, the numbers
</FONT></I>    <I><FONT COLOR="#B22222">// are different. If below, they are 'equal' (to the threshold).
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: This will be unsuitable for some situations. If you've come here to
</FONT></I>    <I><FONT COLOR="#B22222">// change this value: DON'T! Instead, define an auxiliary class or routine to
</FONT></I>    <I><FONT COLOR="#B22222">// handle your special case!
</FONT></I>    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> T MAX_REL_DIFF(1E-6);

    <I><FONT COLOR="#B22222">//Perfect, bit-wise match. Sometimes even copying will render this useless.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>((x == rhs.x) &amp;&amp; (y == rhs.y) &amp;&amp; (z == rhs.z)) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    
    <I><FONT COLOR="#B22222">//Relative difference match. Should handle zeros and low-near-zeros (I think). 
</FONT></I>    <I><FONT COLOR="#B22222">// Macro RELATIVE_DIFF is currently defined in YgorMisc.h (Feb. 2013).
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>((RELATIVE_DIFF(x, rhs.x) &lt; MAX_REL_DIFF) 
       &amp;&amp; (RELATIVE_DIFF(y, rhs.y) &lt; MAX_REL_DIFF)  
       &amp;&amp; (RELATIVE_DIFF(z, rhs.z) &lt; MAX_REL_DIFF)) <B><FONT COLOR="#A020F0">return</FONT></B> true;

    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template bool vec3&lt;int&gt;::operator==(const vec3&lt;int&gt; &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template bool vec3&lt;long int&gt;::operator==(const vec3&lt;long int&gt; &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
   
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    <B><FONT COLOR="#228B22">bool</FONT></B> vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> !( *<B><FONT COLOR="#A020F0">this</FONT></B> == rhs );
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template bool vec3&lt;int&gt;::operator!=(const vec3&lt;int&gt; &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template bool vec3&lt;long int&gt;::operator!=(const vec3&lt;long int&gt; &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
 
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    <B><FONT COLOR="#228B22">bool</FONT></B> vec3&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//This is the default, fairly-logical solution. If equality is NOT bit-wise
</FONT></I>    <I><FONT COLOR="#B22222">// equality, this should be changed to something which can account for the 
</FONT></I>    <I><FONT COLOR="#B22222">// range of equality. See operator== for more info.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;length() &lt; rhs.length();

    <I><FONT COLOR="#B22222">//Since we are using floating point numbers, we should check for equality before making a 
</FONT></I>    <I><FONT COLOR="#B22222">// consensus of less-than.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(*<B><FONT COLOR="#A020F0">this</FONT></B> == rhs) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;length() &lt; rhs.length();

    <I><FONT COLOR="#B22222">//NOTE: Although this is a fairly &quot;unsatisfying&quot; result, it appears to properly allow 
</FONT></I>    <I><FONT COLOR="#B22222">// vec3's to be placed in std::maps, whereas more intuitive methods (x&lt;rhs.x, etc..) do NOT. 
</FONT></I>    <I><FONT COLOR="#B22222">// If an actual operator&lt; is to be defined, please do NOT overwrite this one (so that we 
</FONT></I>    <I><FONT COLOR="#B22222">// can continue to put vec3's into std::map and not have garbled output and weird bugs!) 
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//return ( (y &lt; rhs.y) ); //  &lt;--- BAD! (See previous note above ^)
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template bool vec3&lt;int&gt;::operator&lt;(const vec3&lt;int&gt; &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template bool vec3&lt;long int&gt;::operator&lt;(const vec3&lt;long int&gt; &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This is a function for rotation unit vectors in some plane. It requires angles to describe the plane of rotation, angle of rotation. 
</FONT></I><I><FONT COLOR="#B22222">// It alo requires a unit vector with which to rotate the plane about.
</FONT></I>vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; rotate_unit_vector_in_plane(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;theta, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;R){
    <I><FONT COLOR="#B22222">// A    --- The unit vector which defines the central axis of the plane. We rotate about this vector to make a plane.
</FONT></I>    <I><FONT COLOR="#B22222">// theta -- The angle of rotation for a unit vector within the plane.
</FONT></I>    <I><FONT COLOR="#B22222">// R    --- An angle from [0:2*pi] which specifies the second axis of the plane (along with A.)
</FONT></I>
    <I><FONT COLOR="#B22222">//###########################################################################################
</FONT></I>    <I><FONT COLOR="#B22222">//## This method is NOT ideal. It is expensive AND brittle. Fix it with a better solution. ##    ---&gt; it came from &quot;Project - Transport&quot;
</FONT></I>    <I><FONT COLOR="#B22222">//###########################################################################################
</FONT></I>
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::<B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; a1 = (fabs(A.x) &gt; 1E-11) ? ( (fabs(A.x) &lt; (1.0-1E-10)) ? A.x :  A.x - 1E-10 ) : 1E-11 + A.x;    <I><FONT COLOR="#B22222">// ~~ A.x
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::<B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; a2 = (fabs(A.y) &gt; 1E-11) ? ( (fabs(A.y) &lt; (1.0-1E-10)) ? A.y :  A.y - 1E-10 ) : 1E-11 + A.y;    <I><FONT COLOR="#B22222">// ~~ A.y
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::<B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; a3 = (fabs(A.z) &gt; 1E-11) ? ( (fabs(A.z) &lt; (1.0-1E-10)) ? A.z :  A.z - 1E-10 ) : 1E-11 + A.z;    <I><FONT COLOR="#B22222">// ~~ A.z
</FONT></I>
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> std::<B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; i(0.0,1.0);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::<B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; p, t; <I><FONT COLOR="#B22222">//Angles.
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>(fabs(A.z) &lt; 0.75){ <I><FONT COLOR="#B22222">//Handles special cases. Doesn't do so safely, though!
</FONT></I>
    <I><FONT COLOR="#B22222">//Now, given the rotation angle and the unit vector coordinates of A, we generate a unit vector in the plane orthogonal to A.   
</FONT></I>    p  = (R &gt; 1E-11) ? R : 1E-11 + R;  <I><FONT COLOR="#B22222">// ~~ R
</FONT></I>
    <I><FONT COLOR="#B22222">//Two solutions for t when fixing p. Pick one (I think they correspond to the plus/minus orientation, which should be irrelevant here.)
</FONT></I>    t  = -i*log(-1.0*pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0)*pow(pow(a3,2.0)*pow(M_E,4.0*i*p)+pow(a2,2.0)*pow(M_E,4.0*i*p)+pow(a1,2.0)*pow(M_E,4.0*i*p)+2.0*pow(a3,2.0)*pow(M_E,2.0*i*p)-2.0*pow(a2,2.0)*pow(M_E,2.0*i*p)-2.0*pow(a1,2.0)*pow(M_E,2.0*i*p)+pow(a3,2.0)+pow(a2,2.0)+pow(a1,2.0),0.5)+a3*pow(M_E,2.0*i*p)*pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0)+a3*pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0));

    <I><FONT COLOR="#B22222">//t  = -i*log(pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0)*pow(pow(a3,2.0)*pow(M_E,4.0*i*p)+pow(a2,2.0)*pow(M_E,4.0*i*p)+pow(a1,2.0)*pow(M_E,4.0*i*p)+2.0*pow(a3,2.0)*pow(M_E,2.0*i*p)-2.0*pow(a2,2.0)*pow(M_E,2.0*i*p)-2.0*pow(a1,2.0)*pow(M_E,2.0*i*p)+pow(a3,2.0)+pow(a2,2.0)+pow(a1,2.0),0.5)+a3*pow(M_E,2.0*i*p)*pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0)+a3*pow(a2*pow(M_E,2.0*i*p)+i*a1*pow(M_E,2.0*i*p)-1.0*a2-1.0*i*a1,-1.0));
</FONT></I>

    }<B><FONT COLOR="#A020F0">else</FONT></B>{
    
        t = R;

        <I><FONT COLOR="#B22222">//We are going to use least-significant bit selection here. Ugh... Of COURSE this is not portable. Endianness breaks it, if not something else.
</FONT></I>        <B><FONT COLOR="#228B22">union</FONT></B> {
            <B><FONT COLOR="#228B22">double</FONT></B> the_number;
            <B><FONT COLOR="#228B22">char</FONT></B>   asChars[<B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B>)];
        };
        the_number = R;

        <I><FONT COLOR="#B22222">//This time we cannot simply ignore one of the solutions, lest we have a one-sided universe...
</FONT></I>     
        <I><FONT COLOR="#B22222">// http://stackoverflow.com/questions/4743115/how-do-i-use-bitwise-operators-on-a-double-on-c
</FONT></I> 
        <I><FONT COLOR="#B22222">//if(asChars[sizeof(double) - 1] &amp; 0x1){
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(asChars[0] &amp; 0x1){  <I><FONT COLOR="#B22222">//Least significant bit selection. Sorry, if you are reading this, for such a shit solution :(
</FONT></I>            p = -i*log(-1.0*pow(a2*pow(M_E,2.0*i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+i*a1*pow(M_E,2.0*i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+2.0*a3*pow(M_E,i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)-1.0*a2*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+i*a1*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0),0.5));
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            p = -0.5*i*log(a2*pow(M_E,2.0*i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+i*a1*pow(M_E,2.0*i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+2.0*a3*pow(M_E,i*t)*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)-1.0*a2*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0)+i*a1*pow(a2*pow(M_E,2.0*i*t)+i*a1*pow(M_E,2.0*i*t)-2.0*a3*pow(M_E,i*t)-1.0*a2+i*a1,-1.0));
        }
    }

    <B><FONT COLOR="#228B22">double</FONT></B> u1;
    <B><FONT COLOR="#228B22">double</FONT></B> u2;
    <B><FONT COLOR="#228B22">double</FONT></B> u3;

    u1 = ( cos(t)*sin(p) ).real();
    u2 = ( sin(t)*sin(p) ).real();
    u3 = ( cos(p) ).real();

    <I><FONT COLOR="#B22222">//Note that taking the real part messes up the normalization, leading to some fairly funky 'strands' in the rotated vector.
</FONT></I>    <I><FONT COLOR="#B22222">// If you sample theta but leave A and R static, you should see these strands if you remove the following renormalization.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> utot = sqrt( u1*u1 + u2*u2 + u3*u3 );
    u1 /= utot;
    u2 /= utot;
    u3 /= utot;

    <I><FONT COLOR="#B22222">//Now we rotate by the angle provided.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> out_x = cos(theta)*A.x + sin(theta)*u1;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> out_y = cos(theta)*A.y + sin(theta)*u2;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> out_z = cos(theta)*A.z + sin(theta)*u3;

    <I><FONT COLOR="#B22222">//Now we ship out the vector.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;( out_x, out_y, out_z );

}


<I><FONT COLOR="#B22222">//This function evolves a pair of position and velocity (x(t=0),v(t=0)) to a pair (x(t=T),v(t=T)) using the
</FONT></I><I><FONT COLOR="#B22222">// classical expression for a time- and position-dependent force F(x;t). It is highly unstable, so the number
</FONT></I><I><FONT COLOR="#B22222">// of iterations must be specified. If this is going to be used for anything important, make sure that the
</FONT></I><I><FONT COLOR="#B22222">// number of iterations is chosen sufficiently high so as to produce negligible errors.
</FONT></I>std::tuple&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; Evolve_x_v_over_T_via_F(<B><FONT COLOR="#228B22">const</FONT></B> std::tuple&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;x_and_v, 
                                                              <B><FONT COLOR="#5F9EA0">std</FONT></B>::function&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; x, <B><FONT COLOR="#228B22">double</FONT></B> T)&gt; F,  
                                                              <B><FONT COLOR="#228B22">double</FONT></B> T, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> steps){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::tuple&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;,vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; out(x_and_v), last(x_and_v);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> m = 1.0;

    <B><FONT COLOR="#A020F0">if</FONT></B>(steps &lt;= 0) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to evolve x and v - the number of steps specified is impossible&quot;</FONT></B>);
    <I><FONT COLOR="#B22222">//if(T &lt;= 0.0) ...   This is OK!
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!F) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Given function F is not valid. Unable to do anything&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> dt = T/static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(steps);

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;steps; ++i){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> curr_t = static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(i)*dt;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> F_at_last_x_curr_t = F( std::get&lt;0&gt;(last), curr_t );

        <I><FONT COLOR="#B22222">//Update V.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::get&lt;1&gt;(out) = F_at_last_x_curr_t*(dt/m) + std::get&lt;1&gt;(last);
 
        <I><FONT COLOR="#B22222">//Use current V to update X.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::get&lt;0&gt;(out) = std::get&lt;1&gt;(out)*dt + std::get&lt;0&gt;(last);

        <I><FONT COLOR="#B22222">//Store the old values.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::get&lt;0&gt;(last) = std::get&lt;0&gt;(out);
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::get&lt;1&gt;(last) = std::get&lt;1&gt;(out);
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------- vec2: A three-dimensional vector -------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Constructors.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec2&lt;T&gt;::vec2(){   x=(T)(0);   y=(T)(0); }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt;::vec2(void);
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt;::vec2(void);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::vec2(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::vec2(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec2&lt;T&gt;::vec2(T a, T b) : x(a), y(b) { }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt;::vec2(int, int);
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt;::vec2(long int, long int);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::vec2(<B><FONT COLOR="#228B22">float</FONT></B>, <B><FONT COLOR="#228B22">float</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::vec2(<B><FONT COLOR="#228B22">double</FONT></B>, <B><FONT COLOR="#228B22">double</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec2&lt;T&gt;::vec2( <B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;in ) : x(in.x), y(in.y) { }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt;::vec2( const vec2&lt;int&gt; &amp; );
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt;::vec2( const vec2&lt;long int&gt; &amp; );
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::vec2( <B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; );
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::vec2( <B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; );
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<I><FONT COLOR="#B22222">//More general: (but is it needed?)
</FONT></I><I><FONT COLOR="#B22222">//template&lt;class Ch,class Tr,class T&gt;     std::basic_ostream&lt;Ch,Tr&gt; &amp; operator&lt;&lt;( std::basic_ostream&lt;Ch,Tr&gt; &amp;&amp;out, const vec2&lt;T&gt; &amp;L ){
</FONT></I><I><FONT COLOR="#B22222">//    out &lt;&lt; &quot;(&quot; &lt;&lt; L.x &lt;&lt; &quot;, &quot; &lt;&lt; L.y &lt;&lt; &quot;, &quot; &lt;&lt; L.z &lt;&lt; &quot;)&quot;;
</FONT></I><I><FONT COLOR="#B22222">//    return out;
</FONT></I><I><FONT COLOR="#B22222">//}
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;( std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;L ) {
    <I><FONT COLOR="#B22222">//Note: This friend is templated (Y) within the templated class (T). We only
</FONT></I>    <I><FONT COLOR="#B22222">// care about friend template when T==Y.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//There is significant whitespace here!
</FONT></I>    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> &lt;&lt; L.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B> &lt;&lt; L.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, const vec2&lt;int&gt; &amp;L );
</FONT></I><I><FONT COLOR="#B22222">//    template std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, const vec2&lt;long int&gt; &amp;L );
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;L );
    <B><FONT COLOR="#228B22">template</FONT></B> std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;L );
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; T vec2&lt;T&gt;::Dot(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (*<B><FONT COLOR="#A020F0">this</FONT></B>).x * in.x + (*<B><FONT COLOR="#A020F0">this</FONT></B>).y * in.y;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Dot(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Dot(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
   
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec2&lt;T&gt; vec2&lt;T&gt;::Mask(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> T thex = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;x * in.x; 
    <B><FONT COLOR="#228B22">const</FONT></B> T they = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;y * in.y;
    <B><FONT COLOR="#A020F0">return</FONT></B> vec2&lt;T&gt;( thex, they );
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Mask(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> ;
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Mask(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> ;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
 
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec2&lt;T&gt; vec2&lt;T&gt;::unit(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> T tot = sqrt(x*x + y*y);
    <B><FONT COLOR="#A020F0">return</FONT></B> vec2&lt;T&gt;(x/tot, y/tot);
} 
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::unit(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::unit(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; T vec2&lt;T&gt;::length(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> T tot = sqrt(x*x + y*y);
    <B><FONT COLOR="#A020F0">return</FONT></B> tot;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::length(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::length(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  T vec2&lt;T&gt;::distance(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> T dist = sqrt((x-rhs.x)*(x-rhs.x) + (y-rhs.y)*(y-rhs.y));
    <B><FONT COLOR="#A020F0">return</FONT></B> dist;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::distance(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::distance(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
   
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  T vec2&lt;T&gt;::sq_dist(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> ((x-rhs.x)*(x-rhs.x) + (y-rhs.y)*(y-rhs.y));
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::sq_dist(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::sq_dist(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
 
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    std::istream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&gt;&gt;( std::istream &amp;in, vec2&lt;T&gt; &amp;L ) {
    <I><FONT COLOR="#B22222">//Note: This friend is templated (Y) within the templated class (T). We only
</FONT></I>    <I><FONT COLOR="#B22222">// care about friend template when T==Y.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//... &lt;&lt; &quot;(&quot;  &lt;&lt; L.x &lt;&lt; &quot;, &quot; &lt;&lt; L.y &lt;&lt; &quot;, &quot; &lt;&lt;  L.z  &lt;&lt;  &quot;)&quot;;
</FONT></I>    <I><FONT COLOR="#B22222">//We have at least TWO options here. We can use a method which is compatible
</FONT></I>    <I><FONT COLOR="#B22222">// with the ( , , ) notation, or we can ask for straight-up numbers. 
</FONT></I>    <I><FONT COLOR="#B22222">//We will discriminate here based on what 'in' is.
</FONT></I><I><FONT COLOR="#B22222">//    if(&amp;in != &amp;std::cin){                                   //Neat trick, but makes it hard to build on..
</FONT></I>        <B><FONT COLOR="#228B22">char</FONT></B> grbg;
        <I><FONT COLOR="#B22222">//... &lt;&lt; &quot;(&quot;  &lt;&lt; L.x &lt;&lt; &quot;, &quot; &lt;&lt; L.y &lt;&lt;  &quot;)&quot;;
</FONT></I>        in    &gt;&gt; grbg &gt;&gt; L.x &gt;&gt; grbg &gt;&gt; L.y &gt;&gt; grbg;
<I><FONT COLOR="#B22222">//    }else  in &gt;&gt; L.x &gt;&gt; L.y;
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> in;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template std::istream &amp; operator&gt;&gt;(std::istream &amp;out, vec2&lt;int&gt; &amp;L );
</FONT></I><I><FONT COLOR="#B22222">//    template std::istream &amp; operator&gt;&gt;(std::istream &amp;out, vec2&lt;long int&gt; &amp;L );
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> std::istream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;&gt;(std::istream &amp;out, vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;L );
    <B><FONT COLOR="#228B22">template</FONT></B> std::istream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;&gt;(std::istream &amp;out, vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;L );
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec2&lt;T&gt; &amp; vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;rhs) {
    <I><FONT COLOR="#B22222">//Check if it is itself.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (<B><FONT COLOR="#A020F0">this</FONT></B> == &amp;rhs) <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>; 
    (*<B><FONT COLOR="#A020F0">this</FONT></B>).x = rhs.x;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).y = rhs.y;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt; &amp; vec2&lt;int&gt;::operator=(const vec2&lt;int&gt; &amp;rhs);
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt; &amp; vec2&lt;long int&gt;::operator=(const vec2&lt;long int&gt; &amp;rhs);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec2&lt;T&gt; vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> vec2&lt;T&gt;( (*<B><FONT COLOR="#A020F0">this</FONT></B>).x + rhs.x, (*<B><FONT COLOR="#A020F0">this</FONT></B>).y + rhs.y );
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt; vec2&lt;int&gt;::operator+(const vec2&lt;int&gt; &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt; vec2&lt;long int&gt;::operator+(const vec2&lt;long int&gt; &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec2&lt;T&gt; &amp; vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;rhs) {
    (*<B><FONT COLOR="#A020F0">this</FONT></B>).x += rhs.x;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).y += rhs.y;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt; &amp; vec2&lt;int&gt;::operator+=(const vec2&lt;int&gt; &amp;rhs);
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt; &amp; vec2&lt;long int&gt;::operator+=(const vec2&lt;long int&gt; &amp;rhs);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>+=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec2&lt;T&gt; vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> vec2&lt;T&gt;( (*<B><FONT COLOR="#A020F0">this</FONT></B>).x - rhs.x, (*<B><FONT COLOR="#A020F0">this</FONT></B>).y - rhs.y);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt; vec2&lt;int&gt;::operator-(const vec2&lt;int&gt; &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt; vec2&lt;long int&gt;::operator-(const vec2&lt;long int&gt; &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec2&lt;T&gt; &amp; vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;rhs) {
    (*<B><FONT COLOR="#A020F0">this</FONT></B>).x -= rhs.x;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).y -= rhs.y;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt; &amp; vec2&lt;int&gt;::operator-=(const vec2&lt;int&gt; &amp;rhs);
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt; &amp; vec2&lt;long int&gt;::operator-=(const vec2&lt;long int&gt; &amp;rhs);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>-=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
<I><FONT COLOR="#B22222">//------------------------------ overloaded native-types -----------------------------
</FONT></I>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec2&lt;T&gt; vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> vec2&lt;T&gt;(x*rhs,y*rhs);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt; vec2&lt;int&gt;::operator*(const int &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt; vec2&lt;long int&gt;::operator*(const long int &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec2&lt;T&gt; &amp; vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*=(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;rhs) {
    (*<B><FONT COLOR="#A020F0">this</FONT></B>).x *= rhs;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).y *= rhs;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt; &amp; vec2&lt;int&gt;::operator*=(const int &amp;rhs);
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt; &amp; vec2&lt;long int&gt;::operator*=(const long int &amp;rhs);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*=(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>*=(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec2&lt;T&gt; vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> vec2&lt;T&gt;(x/rhs,y/rhs);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt; vec2&lt;int&gt;::operator/(const int &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt; vec2&lt;long int&gt;::operator/(const long int &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec2&lt;T&gt; &amp; vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/=(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;rhs) {
    (*<B><FONT COLOR="#A020F0">this</FONT></B>).x /= rhs;    (*<B><FONT COLOR="#A020F0">this</FONT></B>).y /= rhs;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template vec2&lt;int&gt; &amp; vec2&lt;int&gt;::operator/=(const int &amp;rhs);
</FONT></I><I><FONT COLOR="#B22222">//    template vec2&lt;long int&gt; &amp; vec2&lt;long int&gt;::operator/=(const long int &amp;rhs);
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/=(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>/=(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    
    
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    <B><FONT COLOR="#228B22">bool</FONT></B> vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> ( (x == rhs.x) &amp;&amp; (y == rhs.y) );
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template bool vec2&lt;int&gt;::operator==(const vec2&lt;int&gt; &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template bool vec2&lt;long int&gt;::operator==(const vec2&lt;long int&gt; &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
   
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    <B><FONT COLOR="#228B22">bool</FONT></B> vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> !( *<B><FONT COLOR="#A020F0">this</FONT></B> == rhs );
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template bool vec2&lt;int&gt;::operator!=(const vec2&lt;int&gt; &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template bool vec2&lt;long int&gt;::operator!=(const vec2&lt;long int&gt; &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
 
    
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    <B><FONT COLOR="#228B22">bool</FONT></B> vec2&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (*<B><FONT COLOR="#A020F0">this</FONT></B>).length() &lt; rhs.length();  <I><FONT COLOR="#B22222">// NOTE: Although this is a fairly &quot;unsatisfying&quot; result, it appears to properly allow vec2's to be placed in std::maps, whereas more intuitive methods (x&lt;rhs.x, etc..) do NOT. 
</FONT></I>                                             <I><FONT COLOR="#B22222">// If an actual operator&lt; is to be defined, please do NOT overwrite this one (so that we can continue to put vec2's into std::map and not have garbled output and weird bugs!) 
</FONT></I><I><FONT COLOR="#B22222">//    return ( (y &lt; rhs.y) ); //  &lt;--- BAD! (See previous note above ^)
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template bool vec2&lt;int&gt;::operator&lt;(const vec2&lt;int&gt; &amp;rhs) const;
</FONT></I><I><FONT COLOR="#B22222">//    template bool vec2&lt;long int&gt;::operator&lt;(const vec2&lt;long int&gt; &amp;rhs) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------- line: (infinitely-long) lines in 3D space ---------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Constructors.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    line&lt;T&gt;::line(){ }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> line&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::line(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> line&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::line(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    line&lt;T&gt;::line(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R_A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R_B) : R_0(R_A) {
    vec3&lt;T&gt; temp(R_B);
    temp -= R_A;
    U_0 = temp.unit();
} 
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> line&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::line(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;R_A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;R_B);
    <B><FONT COLOR="#228B22">template</FONT></B> line&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::line(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;R_A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;R_B);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Member functions.
</FONT></I>
<I><FONT COLOR="#B22222">/*
//This function takes a point and a unit vector along each line and computes the point at which they intersect. If they diverge, the function returns false. Otherwise,
// it returns true and places the point of intersection in &quot;output.&quot;
//
// If the function returns false, it does not imply that the lines diverge - it implies only that the solution computed with this method was unstable!
//
//This function accepts 3D vectors, but only uses the x and y parts. The z-component is entirely ignored.
template &lt;class T&gt;  bool line&lt;T&gt;::Intersects_With_Line_Once( const line&lt;T&gt; &amp;in, vec3&lt;T&gt; &amp;out) const {

    //------------
    // Speculation on how to extend this result to a fully-3D result:
    //   step 1 - find the plane which intersects with line 1 infinitely-many places and which only intersects in one place for line 2.
    //   step 2 - determine the point in this plane where line 2 intersects.
    //   step 3 - determine if line 1 and this point coincide.
    //                   If they coincide, then the lines coincide. If any difficulties arise or line 1 and the point do not coincide, then the lines do not coincide.
    //------------


    //If the pivot point R_0 of each line is identical, then we say an intersection occurs there.
    if( (*this).R_0 == in.R_0 ){
        if( !((*this).U_0 == in.U_0) ){
            out = in.R_0;
            return true;
        }
        //The lines overlap! We have an infinite number of solutions, so we pretend it is unsolveable.
        FUNCWARN(&quot;Attempting to determine intersection point of two identical lines. Pretending they do not intersect!&quot;);
        return false;
    }

    //If the two lines are not in the same z-plane, then the following routine is insufficient!
    if( ((*this).R_0.z == in.R_0.z) || ((*this).U_0.z != (T)(0)) || (in.U_0.z != (T)(0)) ){
        FUNCWARN(&quot;This function can not handle fully-3D lines. Lines which do not have a constant z-component are not handled. Continuing and indicating that we could not determine the point of intersection&quot;);
        return false;
    }

    //We parametrize each line like (R(t) = point + unit*t) and attempt to determine t for each line.
    // From Maxima:
    //   solve([u1x*t1 - u2x*t2 = Cx, u1y*t1 - u2y*t2 = Cy], [t1,t2]);
    //   ---&gt;  [[t1=(Cy*u2x-Cx*u2y)/(u1y*u2x-u1x*u2y) , t2=(Cy*u1x-Cx*u1y)/(u1y*u2x-u1x*u2y)]]
    const T denom = ((*this).U_0.y*in.U_0.x - (*this).U_0.x*in.U_0.y);
    if(fabs(denom) &lt; (T)(1E-99)){
        FUNCWARN(&quot;Unable to compute the intersection of two lines. Either the lines do not converge, or the tolerances are set too high. Continuing and indicating that we could not determine the point of intersection&quot;);
        return false;
    }

    const T Cx       = (in.R_0.x - (*this).R_0.x);
    const T Cy       = (in.R_0.y - (*this).R_0.y);
    const T numer_t1 = (Cy*in.U_0.x      - Cx*in.U_0.y     );
    const T numer_t2 = (Cy*(*this).U_0.x - Cx*(*this).U_0.y);
    const T t1       = numer_t1 / denom;
    const T t2       = numer_t2 / denom;

    //Now we could (should) check if the two t's lead to consistent results. This is not done at the moment because I will surely have nicely-orthogonal lines that will definately intersect nicely.
    //out = vec3&lt;double&gt;( (*this).R_0.x + (*this).U_0.x*t1, (*this).R_0.y + (*this).U_0.y*t1, (*this).R_0.z  );
    out.x = (*this).R_0.x + (*this).U_0.x*t1;
    out.y = (*this).R_0.y + (*this).U_0.y*t1;
    out.z = (*this).R_0.z;
    return true;
}
*/</FONT></I>

<I><FONT COLOR="#B22222">//This function computes the distance from any line to any point in 3D space.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  T line&lt;T&gt;::Distance_To_Point( <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R ) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//This is a fairly simple result. Check out http://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html for a slightly
</FONT></I>    <I><FONT COLOR="#B22222">// overtly-difficult description of the derivation.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; dR = R - (*<B><FONT COLOR="#A020F0">this</FONT></B>).R_0;
    <B><FONT COLOR="#A020F0">return</FONT></B>  ( dR.Cross( dR - (*<B><FONT COLOR="#A020F0">this</FONT></B>).U_0 ) ).length();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> line&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Distance_To_Point( <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;R ) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> line&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Distance_To_Point( <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;R ) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">/*
//This function accepts any line embedded in 3D space.
template &lt;class T&gt;  bool line&lt;T&gt;::Intersects_With_Line_Once( const line&lt;T&gt; &amp;in, vec3&lt;T&gt; &amp;out) const {
    //First, we construct a plane which houses the unit vectors of the two lines.
    // This will give us two planes: $\vec{N} \cdot ( \vec{R} - \vec{R}_{a,0} )$ and $\vec{N} \cdot ( \vec{R} - \vec{R}_{b,0} )$
    // where $\vec{N} = \vec{U}_{a} \otimes \vec{U}_{b}.$ Since the planes are parallel, we just compute the distance between planes. 
    const vec3&lt;T&gt; N( this-&gt;U_0.Cross( in.U_0 ) );
    //FUNCINFO(&quot;The cross product of the unit vectors &quot; &lt;&lt; (*this).U_0 &lt;&lt; &quot; and &quot; &lt;&lt; in.U_0  &lt;&lt; &quot; of the lines is &quot; &lt;&lt; N);

FUNCWARN(&quot;This functions requires a code review!&quot;);

    if(N.length() &lt; (T)(1E-9) ){
        //I might be wrong (very tired right now) but I think this means there are either infinite solutions or none. Either way, we cannot
        // compute them, so we just return a big, fat false.
        return false;
    }

    //The distance between planes can be computed as the distance from a single point on one plane to the other plane. (We know R_0 is on the plane.)
    const plane&lt;T&gt; plane_b( N, in.R_0 );
    const T separation = std::fabs( plane_b.Get_Signed_Distance_To_Point( (*this).R_0 ) ); 
    //FUNCINFO(&quot;The separation between planes is &quot; &lt;&lt; separation);

    // Explicitly, the signed distance is   dist = (u_a x u_b) dot (R_a - R_b), which removes the need to compute the plane...

    if( separation &lt; (T)(1E-9) ){
        //Determine the point of intersection here.
        // First, we set the two line equations equal to each other in order to determine the parametrization ta and tb where they intersect.
        // Then we dot each (vector) equation with alternatively U_0,a and U_0,b to give us two equations for two unknowns (instead of three
        // equations and two unknowns with a ghost parameter.) The extra piece of information was used during the calculation of plane 
        // separation: ie. we have not lost any info by dotting both sides of the identity to reduce the dimensionality.
        const vec3&lt;T&gt; dR( (*this).R_0 - in.R_0 ); //dR = R_0_a - R_0_b
        const T udotu = (*this).U_0.Dot( in.U_0 );
        const T denom = (T)(1.0) - udotu*udotu;
        if(denom &lt; (T)(1E-9)) return false; //Is this line required, given that we know ua x ub to be nearly zero ?

        //For a line, we only need to compute one of these. For a line segment, we'll need both so we can range-check.
        const T ta = -( ( (*this).U_0 - ( in.U_0 * (udotu) ) ).Dot( dR ) ) / denom;
        //const T tb =  ( ( in.U_0 - ( (*this).U_0 * (udotu) ) ).Dot( dR ) ) / denom; 

        out = (*this).R_0 + ( ( (*this).U_0 ) * ta );
        return true;
    }
    return false;
}
*/</FONT></I>

<I><FONT COLOR="#B22222">//This function accepts any line embedded in 3D space.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: If 'false' is returned, then the vec3 passed in will be undefined.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  <B><FONT COLOR="#228B22">bool</FONT></B> line&lt;T&gt;::Intersects_With_Line_Once( <B><FONT COLOR="#228B22">const</FONT></B> line&lt;T&gt; &amp;in, vec3&lt;T&gt; &amp;out) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//This function assumes the the lines are well-formed and that U's are normalized to unit length.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;U_0 == in.U_0){
        <I><FONT COLOR="#B22222">//This means there are either an infinite number of intersections or none. Neither of these applies.
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
   
    <I><FONT COLOR="#B22222">//Construct a token plane out of the two unit vectors. We will duplicate and shift the plane to encompass 
</FONT></I>    <I><FONT COLOR="#B22222">// each line's arbitrary point. This will give us two planes
</FONT></I>    <I><FONT COLOR="#B22222">//     $\vec{N} \cdot ( \vec{R} - \vec{R}_{a,0} )$   and   $\vec{N} \cdot ( \vec{R} - \vec{R}_{b,0} )$
</FONT></I>    <I><FONT COLOR="#B22222">// where $\vec{N} = \vec{U}_{a} \otimes \vec{U}_{b}.$ 
</FONT></I>    <I><FONT COLOR="#B22222">// Since the planes are parallel, we just compute the distance between planes. 
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; N(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;U_0.Cross(in.U_0)); <I><FONT COLOR="#B22222">//NOT of unit length!
</FONT></I>
<I><FONT COLOR="#B22222">/*
    if(N.length() &lt; (T)(1E-9) ){  //Too arbitrary - any better way??
        //I might be wrong (very tired right now) but I think this means there are either infinite solutions or none. Either way, we cannot
        // compute them, so we just return a big, fat false.
        return false;
    }
*/</FONT></I>

    <I><FONT COLOR="#B22222">//The distance between planes can be computed as the distance from a single point on one plane to the other plane.
</FONT></I>    <I><FONT COLOR="#B22222">// We know R_0 is within one of the planes, so we can actually avoid computing it.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> plane&lt;T&gt; plane_b(N.unit(), in.R_0);
    <B><FONT COLOR="#228B22">const</FONT></B> T separation = std::fabs(plane_b.Get_Signed_Distance_To_Point(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;R_0)); 

    <I><FONT COLOR="#B22222">//Check if the planes are separated by a reasonable distance or not. If the separation is too great, we
</FONT></I>    <I><FONT COLOR="#B22222">// believe the lines do not intersect. 
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//To judge if the lines intersect, we examine whether the separation is a normal floating point number.
</FONT></I>    <I><FONT COLOR="#B22222">// A normal is NOT a nan, zero, inf, or subnormal. This is quite arbitrary, but is a reasonable place
</FONT></I>    <I><FONT COLOR="#B22222">// to partition because it hugs machine precision (but not too closely). In other words, we are VERY
</FONT></I>    <I><FONT COLOR="#B22222">// selective about whether the lines intersect or not!
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(std::isnormal(separation)) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <I><FONT COLOR="#B22222">//Determine the point of intersection here.
</FONT></I>    <I><FONT COLOR="#B22222">// First, we set the two line equations equal to each other in order to determine the parametrization ta and tb where they intersect.
</FONT></I>    <I><FONT COLOR="#B22222">// Then we dot each (vector) equation with alternatively U_0,a and U_0,b to give us two equations for two unknowns (instead of three
</FONT></I>    <I><FONT COLOR="#B22222">// equations and two unknowns with a ghost parameter.) The extra piece of information was used during the calculation of plane 
</FONT></I>    <I><FONT COLOR="#B22222">// separation: ie. we have not lost any info by dotting both sides of the identity to reduce the dimensionality.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; dR(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;R_0 - in.R_0); <I><FONT COLOR="#B22222">//dR = R_0_a - R_0_b
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> T udotu = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;U_0.Dot(in.U_0);
    <B><FONT COLOR="#228B22">const</FONT></B> T denom = (T)(1.0) - udotu*udotu;

    <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isnormal(denom)) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <I><FONT COLOR="#B22222">//For a line, we only need to compute one of these. For a line segment, we'll need both so we can range-check.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> T ta = -((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;U_0 - (in.U_0 * udotu)).Dot(dR))/denom;
    <I><FONT COLOR="#B22222">//const T tb =  ( ( in.U_0 - ( (*this).U_0 * (udotu) ) ).Dot( dR ) ) / denom; 
</FONT></I>
    out = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;R_0 + (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;U_0 * ta);
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> line&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Intersects_With_Line_Once( <B><FONT COLOR="#228B22">const</FONT></B> line&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;in, vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;out) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> line&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Intersects_With_Line_Once( <B><FONT COLOR="#228B22">const</FONT></B> line&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;out) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  <B><FONT COLOR="#228B22">bool</FONT></B> line&lt;T&gt;::Closest_Point_To_Line(<B><FONT COLOR="#228B22">const</FONT></B> line&lt;T&gt; &amp;in, vec3&lt;T&gt; &amp;out) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Returns the point on (*this) which is closest to the given line. Can only fail if the lines
</FONT></I>    <I><FONT COLOR="#B22222">// are parallel (or due to fp uncertainties).
</FONT></I><I><FONT COLOR="#B22222">//    const auto LA = *this;
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> UA = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;U_0;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> RA = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;R_0;
<I><FONT COLOR="#B22222">//    const auto LB = in;
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> UB = in.U_0;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> RB = in.R_0;

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> UAB  = UA.Dot(UB);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dRAB = RA - RB;

    <B><FONT COLOR="#A020F0">if</FONT></B>(((T)(1) == UAB) || ((T)(1) == UAB*UAB)) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//Parallel lines - no possible single point.
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> tA_numer = (UB*UAB - UA).Dot(dRAB);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> tA_denom = ((T)(1) - UAB*UAB);
<I><FONT COLOR="#B22222">//    const auto tB_numer = (UB - UA*UAB).Dot(dRAB);
</FONT></I><I><FONT COLOR="#B22222">//    const auto tB_denom = tA_denom;
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isnormal(tA_denom)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isnormal((T)(1)/tA_denom)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
<I><FONT COLOR="#B22222">//    if(!std::isnormal(tB_denom)) return false;
</FONT></I><I><FONT COLOR="#B22222">//    if(!std::isnormal((T)(1)/tB_denom)) return false;
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> tA = tA_numer/tA_denom;
<I><FONT COLOR="#B22222">//    const auto tB = tB_numer/tB_denom;
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> PA = UA*tA + RA;
    out = PA;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;

    <I><FONT COLOR="#B22222">//If PB or the line PA-PB are required:
</FONT></I>    <I><FONT COLOR="#B22222">//const auto PB = UB*tB + RB;
</FONT></I>    <I><FONT COLOR="#B22222">//The line intersecting both.
</FONT></I>    <I><FONT COLOR="#B22222">//const auto UC = (PB - PA).Unit();
</FONT></I>    <I><FONT COLOR="#B22222">//const auto PC = PA;
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> line&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Closest_Point_To_Line( <B><FONT COLOR="#228B22">const</FONT></B> line&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;, vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> line&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Closest_Point_To_Line( <B><FONT COLOR="#228B22">const</FONT></B> line&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;, vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------ line_segment: (finite-length) lines in 3D space --------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Constructors.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    line_segment&lt;T&gt;::line_segment(){ }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> line_segment&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::line_segment(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> line_segment&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::line_segment(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    line_segment&lt;T&gt;::line_segment(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R_A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R_B) : t_0(0) {
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;R_0 = R_A;  
    vec3&lt;T&gt; temp(R_B - R_A);
    
    t_1 = temp.length();
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;U_0 = temp.unit();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> line_segment&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::line_segment(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;R_A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;R_B);
    <B><FONT COLOR="#228B22">template</FONT></B> line_segment&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::line_segment(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;R_A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;R_B);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Samples every &lt;spacing&gt;, beginning at offset. Returns sampled points and remaining space along segment.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Parameter 'remaining' is CLEARED prior to adjustment.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Parameter 'offset' can be negative, but no check is done to 
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    std::list&lt;vec3&lt;T&gt;&gt; line_segment&lt;T&gt;::Sample_With_Spacing(T spacing, T offset, T &amp; remaining) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;vec3&lt;T&gt;&gt; points;
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;t_1 &lt;= <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;t_0) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Our line segment is backward. We should reverse the normal and flip the sign on both t_0, t_1&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">const</FONT></B> T L = (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;t_1 - <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;t_0); <I><FONT COLOR="#B22222">//dR.length();
</FONT></I><I><FONT COLOR="#B22222">//    const T L = (this-&gt;R_0 + this-&gt;U_0*this-&gt;t_0).distance(this-&gt;R_0 + this-&gt;U_0*this-&gt;t_1);
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(offset &gt; L){ <I><FONT COLOR="#B22222">//No points can be sampled - the points are too close together.
</FONT></I>        remaining = (L - offset);
        <B><FONT COLOR="#A020F0">return</FONT></B> points;
    }

    <B><FONT COLOR="#A020F0">while</FONT></B>(offset &lt;= L){
        <B><FONT COLOR="#A020F0">if</FONT></B>(offset &gt;= 0.0){
            vec3&lt;T&gt; R(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;U_0);
            R *= (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;t_0 + offset);
            R += <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;R_0;
            points.push_back( R );
        }
        remaining = L - offset;
        offset += spacing;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> points;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;&gt; line_segment&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Sample_With_Spacing(<B><FONT COLOR="#228B22">float</FONT></B>  spacing, <B><FONT COLOR="#228B22">float</FONT></B>  offset, <B><FONT COLOR="#228B22">float</FONT></B>  &amp;remaining) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; line_segment&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Sample_With_Spacing(<B><FONT COLOR="#228B22">double</FONT></B> spacing, <B><FONT COLOR="#228B22">double</FONT></B> offset, <B><FONT COLOR="#228B22">double</FONT></B> &amp;remaining) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt; line_segment&lt;T&gt;::Get_R0(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//These are here in case I need/want to change the internal storage format later...
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;R_0;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; line_segment&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Get_R0(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; line_segment&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Get_R0(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    vec3&lt;T&gt; line_segment&lt;T&gt;::Get_R1(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;R_0 + <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;U_0 * (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;t_1 - <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;t_0);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; line_segment&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Get_R1(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; line_segment&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Get_R1(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>




<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------- plane: 2D planes in 3D space -----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Constructors.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    plane&lt;T&gt;::plane(){ }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> plane&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::plane(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> plane&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::plane(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    plane&lt;T&gt;::plane(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;N_0_in, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R_0_in) : N_0(N_0_in), R_0(R_0_in) { }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> plane&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::plane(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;N_0_in, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;R_0_in);
    <B><FONT COLOR="#228B22">template</FONT></B> plane&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::plane(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;N_0_in, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;R_0_in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Member functions.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    T plane&lt;T&gt;::Get_Signed_Distance_To_Point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//It is really as simple as $Dist_{signed} = \vec{N}_{0} \cdot ( \vec{R} - \vec{R}_{0} ) .$
</FONT></I>    <I><FONT COLOR="#B22222">// N should already be a unit. We divide out the length for S&amp;Gs.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;N_0.Dot( R - <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;R_0 ) / <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;N_0.length();
<I><FONT COLOR="#B22222">//    return (this-&gt;N_0.x*(R.x-this-&gt;R_0.x) + this-&gt;N_0.y*(R.y-this-&gt;R_0.y) + this-&gt;N_0.z*(R.z-this-&gt;R_0.z)) / this-&gt;N_0.length();  
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  plane&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Get_Signed_Distance_To_Point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;R) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> plane&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Get_Signed_Distance_To_Point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;R) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    <B><FONT COLOR="#228B22">bool</FONT></B> plane&lt;T&gt;::Is_Point_Above_Plane(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;R) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dist = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Get_Signed_Distance_To_Point(R);
    <I><FONT COLOR="#B22222">//Check if exactly on the plane and if on the proper side or not.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> (dist != (T)(0)) &amp;&amp; (std::signbit(dist) == 0);
<I><FONT COLOR="#B22222">//    return ( std::signbit( this-&gt;Get_Signed_Distance_To_Point( R ) ) == 0 );
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> plane&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Is_Point_Above_Plane(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;R) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> plane&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Is_Point_Above_Plane(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;R) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    <B><FONT COLOR="#228B22">bool</FONT></B> plane&lt;T&gt;::Intersects_With_Line_Once(<B><FONT COLOR="#228B22">const</FONT></B> line&lt;T&gt; &amp;L, vec3&lt;T&gt; &amp;out) <B><FONT COLOR="#228B22">const</FONT></B> {
   <I><FONT COLOR="#B22222">//This is a fairly simple, robust routine. Set the distance to a point along the line to zero and find the parameter t
</FONT></I>   <I><FONT COLOR="#B22222">// that corresponds. Edge cases are infinite and zero intersection points.
</FONT></I>   <B><FONT COLOR="#228B22">const</FONT></B> T denom = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;N_0.Dot( L.U_0 );

   <I><FONT COLOR="#B22222">//If the plane's normal and the line's direction are orthogonal, they either intersect nowhere or everywhere.
</FONT></I>   <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isfinite((T)(1)/denom)) <B><FONT COLOR="#A020F0">return</FONT></B> false; 
<I><FONT COLOR="#B22222">//   if(fabs(denom) &lt; 1E-9) return false; //Contains both the infinite and zero intersection cases.
</FONT></I>
   <B><FONT COLOR="#228B22">const</FONT></B> T numer = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;N_0.Dot( L.R_0 - <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;R_0 );
   out = L.R_0 - L.U_0*(numer/denom);
   <B><FONT COLOR="#A020F0">return</FONT></B> true;
}


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------ contour_of_points: a polygon of line segments in the form of a collection of points --------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Constructors.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    contour_of_points&lt;T&gt;::contour_of_points() : closed(false) { }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::contour_of_points(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::contour_of_points(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    contour_of_points&lt;T&gt;::contour_of_points(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt; vec3&lt;T&gt; &gt; &amp;in_points) : points(in_points), closed(false) { }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::contour_of_points(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt; &amp;in_points);
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::contour_of_points(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &gt; &amp;in_points);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Member functions.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; T contour_of_points&lt;T&gt;::Get_Signed_Area(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//If the polygon is not closed, we complain. This is the easiest way to do it...
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Computing the surface area of an unconnected contour is not well-defined. Make sure to mark your (implicitly) closed contours as closed.&quot;</FONT></B>);
    } 

    <I><FONT COLOR="#B22222">//If the polygon does not have enough points to form a 2D surface, return a zero. (This is legitimate.)
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt; 3) <B><FONT COLOR="#A020F0">return</FONT></B> (T)(0);
    T Area = (T)(0);

    <B><FONT COLOR="#228B22">auto</FONT></B> iter_1 = --(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end());
    <B><FONT COLOR="#228B22">const</FONT></B> T specific_height = iter_1-&gt;z; <I><FONT COLOR="#B22222">//Used to abandon the computation if the contour is fully 3D.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>( <B><FONT COLOR="#228B22">auto</FONT></B> iter_2 = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(); iter_2 != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end(); ++iter_2 ){
        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; r_a(*iter_1);
        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; r_b(*iter_2);
        <B><FONT COLOR="#A020F0">if</FONT></B>( std::fabs(PERCENT_ERR(r_a.z, specific_height)) &gt; 0.1 ){  <I><FONT COLOR="#B22222">//Our criteria for same height is a |percent error| &lt; 0.1%.
</FONT></I>            FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;This routine is unable to compute generic (signed) areas for fully 3D contours: found a contour with height &quot;</FONT></B> &lt;&lt; r_a.z &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; when the general contour height is &quot;</FONT></B> &lt;&lt; specific_height &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;. This routine assumes the area of interest lies in an XY plane. Fix me if you really need this!&quot;</FONT></B>);
            <I><FONT COLOR="#B22222">//NOTE: A more general 3D routine could probably be accomplished by using the cross product. I've avoided it because
</FONT></I>            <I><FONT COLOR="#B22222">// it requires one to locate a point somewhere on the contour which will allow a linear interpolation of area between
</FONT></I>            <I><FONT COLOR="#B22222">// all contour points. This is probably not possible except in special cases. For instance, a spherical shell has
</FONT></I>            <I><FONT COLOR="#B22222">// curvature which could not be accounted for with said technique. If you need to implement this, consider the overall
</FONT></I>            <I><FONT COLOR="#B22222">// utility of describing your surface with a contour around the surface boundary...
</FONT></I>            <I><FONT COLOR="#B22222">// 
</FONT></I>            <I><FONT COLOR="#B22222">//NOTE: It would be better to implement your particular solution to this problem as a totally separate routine. Maybe
</FONT></I>            <I><FONT COLOR="#B22222">// something like &quot;Get_Signed_Area_for_spherical_shell()&quot;.
</FONT></I>        }
        <B><FONT COLOR="#228B22">const</FONT></B> T n = r_b.y - r_a.y; <I><FONT COLOR="#B22222">//numerator.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> T d = r_b.x - r_a.x; <I><FONT COLOR="#B22222">//denominator.
</FONT></I>
        <I><FONT COLOR="#B22222">//Determine if we consider the points to be equal (and thus have no area between them).
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( ((n == (T)(0)) &amp;&amp; (d == (T)(0))) || (r_a == r_b) ){
            <I><FONT COLOR="#B22222">//This is not an error - there is no area between overlapping points.
</FONT></I>            FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Found two equal adjacent points in a contour. Check the input and/or consider decreasing the range of equality for vec3's. This is not an error&quot;</FONT></B>);

        <I><FONT COLOR="#B22222">//If we are required to use a specific parametrization then do so.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isfinite(d/n)){
            <B><FONT COLOR="#228B22">const</FONT></B> T m_1 = n/d;
            <B><FONT COLOR="#228B22">const</FONT></B> T b_1 = r_a.y - m_1*r_a.x;
            Area += -0.5*b_1*(r_b.x - r_a.x); <I><FONT COLOR="#B22222">//The negative comes from Green's method!
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isfinite(n/d)){
            <B><FONT COLOR="#228B22">const</FONT></B> T m_2 = d/n;
            <B><FONT COLOR="#228B22">const</FONT></B> T b_2 = r_a.x - m_2*r_a.y;
            Area +=  0.5*b_2*(r_b.y - r_a.y); <I><FONT COLOR="#B22222">//The negative is intentionally missing here!
</FONT></I>
        <I><FONT COLOR="#B22222">//Otherwise, try to determine which is more stable. Cursory feeling: slope closest to zero seems most stable. A proper analysis should be done, though.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(fabs(n/d) &lt; fabs(d/n)){
            <B><FONT COLOR="#228B22">const</FONT></B> T m_1 = n/d;
            <B><FONT COLOR="#228B22">const</FONT></B> T b_1 = r_a.y - m_1*r_a.x;
            Area += -0.5*b_1*(r_b.x - r_a.x); <I><FONT COLOR="#B22222">//The negative comes from Green's method!
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#228B22">const</FONT></B> T m_2 = d/n;
            <B><FONT COLOR="#228B22">const</FONT></B> T b_2 = r_a.x - m_2*r_a.y;
            Area +=  0.5*b_2*(r_b.y - r_a.y); <I><FONT COLOR="#B22222">//The negative is intentionally missing here!
</FONT></I>

<I><FONT COLOR="#B22222">//        }else{
</FONT></I><I><FONT COLOR="#B22222">//            FUNCERR(&quot;Unable to properly parametrize two contour points (x,y,z) = &quot; &lt;&lt; r_a &lt;&lt; &quot; and &quot; &lt;&lt; r_b &lt;&lt; &quot;. This is not a recoverable error&quot;);
</FONT></I>        }
        iter_1 = iter_2;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> Area; <I><FONT COLOR="#B22222">//NOTE: Do NOT take the absolute value. We want to keep the sign for adding/subtracting/etc.. contour areas!
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Get_Signed_Area(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Get_Signed_Area(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;T&gt;::Is_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//First, we compute the (signed) area. If the sign is positive, then the contour is counter-clockwise oriented.
</FONT></I>    <I><FONT COLOR="#B22222">// Otherwise, it is of zero area or is clockwise.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> T area = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Get_Signed_Area();
    <B><FONT COLOR="#A020F0">if</FONT></B>( area &lt; (T)(0.0) ) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Is_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Is_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;T&gt;::Reorient_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//This routine is safe to call on contours which are already counter-clockwise!
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: It is not reasonable for us to determine if the contour is ordered properly 
</FONT></I>    <I><FONT COLOR="#B22222">// (ie. the points are in a nice, non-overlapping order). The best we can do is 
</FONT></I>    <I><FONT COLOR="#B22222">// flip the vec3 chain forward or backward!
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Is_Counter_Clockwise() == true) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::reverse(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(), <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end());
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Reorient_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Reorient_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">/*
template &lt;class T&gt; std::list&lt;contour_of_points&lt;T&gt;&gt; contour_of_points&lt;T&gt;::Split_Along_Plane(const plane&lt;T&gt; &amp;theplane) const {
    //I cannot tell if this routine will be good for non-planar contours or not. Ygor feeling is 'no', but I wonder about
    // the overall ability to describe non-planar contours with a series of points. Maybe, if the curvature of the contour
    // is small near the plane, and it is understood that the points are linearlly interpolated between to form the contour,
    // then we will not actually observe any accidental loss in curvature from this routine.  I'll have to test it..
    std::list&lt;contour_of_points&lt;T&gt;&gt; output;


////////////// Needed?
//    //Search for adjacent, duplicate points. If any are found die immediately.
//    {
//      auto p1_it = --(this-&gt;points.end());
//      for(auto p2_it = this-&gt;points.begin(); (p2_it != this-&gt;points.end()) &amp;&amp; (p1_it != this-&gt;points.end()); ){
//          if((*p1_it == *p2_it) &amp;&amp; (p1_it != p2_it)){
//              FUNCERR(&quot;Found an adjacent duplicated point in input contour&quot;);
//          }else{
//              p1_it = p2_it;
//              ++p2_it;
//          }
//      }
//    }
/////////////////////

    if(this-&gt;points.size() &lt; 3){
        FUNCERR(&quot;Not enough contour points to properly split contour. Pretending this contour has been split.&quot;);
    }
    long int number_of_crossings = 0;

    auto copy_of_points = this-&gt;points; //This is super inefficient, but it lets us shift the data around later...
    auto offset = copy_of_points.end();
    for(auto iter_2 = copy_of_points.begin(), iter_1 = --(copy_of_points.end());  iter_2 != copy_of_points.end();  ++iter_2){
        //iter_1 is the first point in the contour, iter_2 is one step ahead.      
        //We check if the line segment that connects the two points crosses the plane.
        vec3&lt;T&gt; garbage;
        if( (theplane.Is_Point_Above_Plane(*iter_1) != theplane.Is_Point_Above_Plane(*iter_2)) 
              &amp;&amp; theplane.Intersects_With_Line_Once(line&lt;T&gt;(*iter_1,*iter_2),garbage) ){
            ++number_of_crossings;
            if(offset == copy_of_points.end()) offset = iter_1; //Look for the first point of the first pair which cross the plane.
        }
        iter_1 = iter_2;
    }

    if(number_of_crossings == 0){
        output.push_back(*this);
        return output;
    }
   
    std::rotate(copy_of_points.begin(), offset, copy_of_points.end()); //The first point of the first pair .. is now the first point.

    //Duplicate the first point. This will allow us to cycle through the list and more easily determine the intersection points.
    copy_of_points.push_back(copy_of_points.front());
    auto iter_of_second = ++(copy_of_points.begin());
    copy_of_points.push_back(*iter_of_second);

    //Step 5 - For each such pair, determine the point on the plane where they intersect.
    //
    //Step 6 - For each continuous stream of points, create a new contour. Insert the upstream plane-intersection point at the 
    // beginning and the downstream one at the end.
    std::vector&lt;std::vector&lt;vec3&lt;T&gt;&gt;&gt; linesegments;
    std::vector&lt;vec3&lt;T&gt;&gt; linesegment_shuttle; //Catches points thrown at it which are eventually thrown into the linesegments vector vector.
    std::vector&lt;vec3&lt;T&gt;&gt; endpoints;           //This is a simple list of the plane-intersection points.
    
    {
      auto iter_1 = copy_of_points.begin();  
      auto iter_2 = ++(copy_of_points.begin());
      for( ;  iter_2 != copy_of_points.end();  ++iter_2, ++iter_1){
          linesegment_shuttle.push_back(*iter_1);
          vec3&lt;T&gt; intersection;

          if((theplane.Is_Point_Above_Plane(*iter_1) != theplane.Is_Point_Above_Plane(*iter_2)) &amp;&amp; theplane.Intersects_With_Line_Once(line&lt;T&gt;(*iter_1,*iter_2), intersection)){
              linesegment_shuttle.push_back( intersection );
              if(linesegment_shuttle.size() &gt; 2){ //Each complete contour will have two endpoints and at least one other point! (Our entry into this routine gives us a short contour.)
                  linesegments.push_back(linesegment_shuttle);
                  endpoints.push_back( intersection );
              }else{
                  //We do not push the shuttle back - there are too few points because we are on the first iteration.
              }
              linesegment_shuttle.clear();
              //We append the &quot;frontpoint&quot; to the front of the next line segment, too.
              linesegment_shuttle.push_back( intersection );
          }
      }
    }

    if( number_of_crossings != static_cast&lt;long int&gt;(linesegments.size()) ){
        FUNCERR(&quot;We somehow produced &quot; &lt;&lt; number_of_crossings &lt;&lt; &quot; crossings and &quot; &lt;&lt; linesegments.size() &lt;&lt; &quot; line segments. This is an error. Check the (input) contour data for repeating points and then check the algorithm.&quot;);
    }
   
std::cout &lt;&lt; &quot;'linesegments' contains: &quot; &lt;&lt; std::endl;
for(auto sh_it = linesegments.begin(); sh_it != linesegments.end(); ++sh_it){
    for(auto shit = sh_it-&gt;begin(); shit != sh_it-&gt;end(); ++shit){
        std::cout &lt;&lt; *shit &lt;&lt; &quot;    &quot;;
    }
    std::cout &lt;&lt; std::endl;
}
std::cout &lt;&lt; std::endl;


    //Now, we determine which endpoint is furthest from the center point. This is done so we can consistently sequentially 'walk' over 
    // the endpoints, and the choice of the most distant is otherwise arbitrary. This assumes the contour is not in the plane
    // with the plane we are splitting on. This means the split will occur along the line defined by the crossing of the plane 
    // we are splitting on and the plane the contour lies on.
    const vec3&lt;T&gt; r_0 = this-&gt;Average_Point();
    auto lambda_distance_to_r_0 = [r_0](const vec3&lt;T&gt; &amp;a, const vec3&lt;T&gt; &amp;b) -&gt; bool { return r_0.distance(a) &lt; r_0.distance(b); };
    vec3&lt;T&gt; furthest_point = *(std::max_element(endpoints.begin(), endpoints.end(), lambda_distance_to_r_0));

    
    //Because each point is on a plane, we can determine which endpoints are connected across a contour by examining the order walking from the furthest point in the direction of the central point.
    //
    //In practice, this means we can simply sort endpoints (ie. the points which lie on the plane - or rather a line along the plane!) via their distance from the most distant point. After sorting,
    // the points will be ordered like A, B, C, D, E, F, ...  where the line segment A and B will cross a contour, the line segment B and C do NOT cross a segment, the line segment C and D will cross
    // a contour, D and E will not, etc.. Thus, we will be left with *pairs* of points which logically connect the contours along the plane. We can then walk through the endpointed-line segments 
    // and jump around whenever one of the pairs instructs us to. 
    //
    //Using the actual point coordinates is a decent way to match points, because no two points should be exactly identical. If there are some, they are both easy and inconsequential to remove prior to 
    // using this algorithm.
    auto lambda_distance_to_furthest_point = [furthest_point](const vec3&lt;T&gt; &amp;a, const vec3&lt;T&gt; &amp;b) -&gt; bool { return (furthest_point.distance(a) &lt; furthest_point.distance(b)); };
    std::sort(endpoints.begin(), endpoints.end(), lambda_distance_to_furthest_point); 
    std::map&lt;vec3&lt;T&gt;,vec3&lt;T&gt;&gt; paired_endpoints;
    for(long int ii = 0; (2*ii) &lt; static_cast&lt;long int&gt;(endpoints.size()); ++ii){
//Commented because this doesn't seem to work...
       paired_endpoints[ endpoints[2*ii+0] ] = endpoints[2*ii+1];
       paired_endpoints[ endpoints[2*ii+1] ] = endpoints[2*ii+0];  //Is this needed if we are always traversing the (original and linesegmented) contour data in the same direction? (apparently yes!)

//       const auto A = endpoints[2*ii+0];
//       const auto B = endpoints[2*ii+1];
//FUNCINFO(&quot;OKAY&quot;);
//       if(paired_endpoints.find(A) != paired_endpoints.end()){
//           FUNCERR(&quot;Attempted to push back a paired endpoint A which we already have&quot;);
//       }
//       paired_endpoints.insert(std::pair&lt;vec3&lt;T&gt;,vec3&lt;T&gt;&gt;(A,B));
//
//       if(paired_endpoints.find(B) != paired_endpoints.end()){
//           FUNCERR(&quot;Attempted to push back a paired endpoint B which we already have&quot;);
//       }
//       paired_endpoints.insert(std::pair&lt;vec3&lt;T&gt;,vec3&lt;T&gt;&gt;(B,A));


    }
   
//if(paired_endpoints.size() != endpoints.size()){
//    FUNCERR(&quot;We pushed back too few paired endpoints &quot; &lt;&lt; paired_endpoints.size() &lt;&lt; &quot; compared with total number of endpoints &quot; &lt;&lt; endpoints.size() &lt;&lt; &quot;. Are two close enough to be floating-point-equal?&quot;);
//}
 
    //Now we cycle through the line segments until they are all used. 
    std::vector&lt;bool&gt; is_this_linesegment_used;
    for(long int ii=0; ii &lt; static_cast&lt;long int&gt;(linesegments.size()); ++ii){
        is_this_linesegment_used.push_back(false);
    }

    std::vector&lt;std::vector&lt;vec3&lt;T&gt;&gt;&gt; newcontours;
    std::vector&lt;vec3&lt;T&gt;&gt; newcontour_shuttle;
    long int next_linesegment = -1;
    bool finished_shuttling = false;
    do{
    
//FUNCINFO(&quot;1 - Entering loop now. next_linesegment = &quot; &lt;&lt; next_linesegment &lt;&lt; &quot;, shuttle size = &quot; &lt;&lt; newcontour_shuttle.size() );
        {
          //Find the index of the next unused line segment if none is present.
          //
          //At no extra cost, check the exiting condition.
          // (If all segments are used AND the shuttle is empty, then we can exit the loop.)
          bool all_used = true;
          for(long int j = 0; j &lt; static_cast&lt;long int&gt;(linesegments.size()); ++j){
              if(is_this_linesegment_used[j] == false){
                  all_used = false;
                  if(next_linesegment == -1) next_linesegment = j;
                  break;
              }
          }
    
          bool shuttle_empty = newcontour_shuttle.empty();
          finished_shuttling = (all_used &amp;&amp; shuttle_empty);
          if(finished_shuttling) break; //Done.
        }
    
//FUNCINFO(&quot;2 - Just past first verification. next_linesegment = &quot; &lt;&lt; next_linesegment &lt;&lt; &quot;, shuttle size = &quot; &lt;&lt; newcontour_shuttle.size() &lt;&lt; &quot;, and is_this_linesegment_used[next_linesegment] = &quot; &lt;&lt; (is_this_linesegment_used[next_linesegment] ? 1 : 0) );
    
    
        //If we have a valid next_linesegment, and we have a non-empty shuttle, and next_linesegment points to a used segment, we have a complete contour in the shuttle.
        if( (next_linesegment != -1) &amp;&amp; (!newcontour_shuttle.empty()) &amp;&amp; (is_this_linesegment_used[next_linesegment] == true) ){
            newcontours.push_back(newcontour_shuttle);
            newcontour_shuttle.clear();
            next_linesegment = -1;
//                    continue;
//FUNCINFO(&quot;3A - Entered stream A - pushing completed shuttle onto the stack.&quot;);
    
        //If we have a valid next_linesegment, and it points to an unused segment, push in onto the shuttle, mark the segment as used, and set next_linesegment to the appropriate value.
        }else if((next_linesegment != -1) &amp;&amp; (is_this_linesegment_used[next_linesegment] == false) ){
            //Mark the line segment &quot;used.&quot;
            is_this_linesegment_used[next_linesegment] = true;
    
//FUNCINFO(&quot;3B - Just past first verification. next_linesegment = &quot; &lt;&lt; next_linesegment &lt;&lt; &quot;, shuttle size = &quot; &lt;&lt; newcontour_shuttle.size() &lt;&lt; &quot;, and is_this_linesegment_used[next_linesegment] = &quot; &lt;&lt; (is_this_linesegment_used[next_linesegment] ? 1 : 0) );
            //Append the line segment's points to the shuttle.
            newcontour_shuttle.insert(newcontour_shuttle.end(), linesegments[next_linesegment].begin(), linesegments[next_linesegment].end());
    
            //Find the &quot;frontpoint&quot; which corresponds to the endpoint of the current line segment.
            vec3&lt;T&gt; terminator = newcontour_shuttle[newcontour_shuttle.size() - 1]; 

            //Works fine on 64bit machine. Hardly ever works on 32bit (???)
            if(!(paired_endpoints.find(terminator) != paired_endpoints.end())){
                FUNCERR(&quot;Unable to find initiating endpoint &quot; &lt;&lt; terminator &lt;&lt; &quot;. This might be due to roundoff error&quot;);
            }
            vec3&lt;T&gt; theinitiator = paired_endpoints[ terminator ];



//            T minsqdist(1E30);
//            vec3&lt;T&gt; theinitiator;
//            for(auto m_it = paired_endpoints.begin(); m_it != paired_endpoints.end(); ++m_it){
//                const T thissqdist = m_it-&gt;first.sq_dist(terminator);
//                if(thissqdist &lt; minsqdist){
//                    minsqdist = thissqdist;
//                    theinitiator = m_it-&gt;second;
//                }
//            }
//
//if(minsqdist != 0.0){ 
//    FUNCINFO(&quot;Chose theinitiator to be &quot; &lt;&lt; theinitiator &lt;&lt; &quot; whilst looking for point &quot; &lt;&lt; terminator &lt;&lt; &quot; because the minsqdist was &quot; &lt;&lt; std::setprecision(100) &lt;&lt; minsqdist);
//}    


            bool could_find_it = false;
            for(long int j = 0; j &lt; static_cast&lt;long int&gt;(linesegments.size()); ++j){
//FUNCINFO(&quot;Trying vector &quot; &lt;&lt; linesegments[j][0]);
                if(linesegments[j][0] == theinitiator){
                    next_linesegment = j;
                    could_find_it = true;
                    break;
                }
            }
            if(could_find_it == false) FUNCERR(&quot;Was unable to find the next line segment in this contour. Is it there?&quot;);
//FUNCINFO(&quot;4B - Entered stream B - pushing line segment onto the shuttle.&quot;);
        }
    
    
        {
          //If all segments are used AND the shuttle is empty, then we can exit the loop.
          bool all_used = true;
          for(long int j = 0; j &lt; static_cast&lt;long int&gt;(linesegments.size()); ++j){
              if(is_this_linesegment_used[j] == false){
                  all_used = false;
                  break;
              }
          }
     
          bool shuttle_empty = newcontour_shuttle.empty();
          finished_shuttling = (all_used &amp;&amp; shuttle_empty);
          if(finished_shuttling) break; //Done.
        }
    }while(finished_shuttling == false);

//FUNCINFO(&quot;Exited contour-generation routine. Now dumping contours&quot;);
    
    //We check for the number of output contours versus the number of plan crossings.
    //  2 crossings -&gt; 2 contours.
    //  4 crossings -&gt; 3 contours.
    //  6 crossings -&gt; 4 contours.
    // so N crossings -&gt; (N/2) + 1 contours.

    if( (2*(static_cast&lt;long int&gt;(newcontours.size()) - 1)) != number_of_crossings ){
        FUNCERR(&quot;This contour originally had &quot; &lt;&lt; number_of_crossings &lt;&lt; &quot; plane crossings and has been exploded into &quot; &lt;&lt; newcontours.size() &lt;&lt; &quot; contours. This is not the amount we should have!&quot;);
    }else{
        //If all looks swell, we push the split contours onto the output.
        for(long int j=0; j &lt; static_cast&lt;long int&gt;(newcontours.size()); ++j){
            contour_of_points&lt;T&gt; new_contour;
            new_contour.closed = true;

            for(long int jj=0; jj &lt; static_cast&lt;long int&gt;(newcontours[j].size()); ++jj){
                new_contour.points.push_back( newcontours[j][jj] );
            }

            output.push_back(new_contour);
        }
    }


//    //Search for and remove any adjacent, duplicate points. Also look for impossibly small contours.
//    for(auto c_it = output.begin(); c_it != output.end(); ++c_it){
//        if(c_it-&gt;points.size() &lt; 3) FUNCERR(&quot;Produced a contour with too few points. This should not happen&quot;);
//
//        auto p1_it = --(c_it-&gt;points.end());
//        for(auto p2_it = c_it-&gt;points.begin(); (p2_it != c_it-&gt;points.end()) &amp;&amp; (p1_it != c_it-&gt;points.end()); ){
//            if((*p1_it == *p2_it) &amp;&amp; (p1_it != p2_it)){
//                //Walk the second iter along the chain.
//                p2_it = c_it-&gt;points.erase(p2_it);
//                FUNCWARN(&quot;Removed a neighbouring duplicate point. This may indicate errors in the splitting routine!&quot;);
//            }else{
//                p1_it = p2_it;
//                ++p2_it;
//            }
//        }
//
//        if(c_it-&gt;points.size() &lt; 3) FUNCERR(&quot;Produced a contour with too many duplicates. Removing the dupes produced a malformed contour&quot;);
//    }

    return output;
}
#ifdef YGORMATH_INCLUDE_ALL_SPECIALIZATIONS
template std::list&lt; contour_of_points&lt;double&gt;&gt; contour_of_points&lt;double&gt;::Split_Along_Plane( const plane&lt;double&gt; &amp;theplane ) const;
template std::list&lt; contour_of_points&lt;float&gt;&gt; contour_of_points&lt;float&gt;::Split_Along_Plane( const plane&lt;float&gt; &amp;theplane ) const;
#endif
*/</FONT></I>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::list&lt;contour_of_points&lt;T&gt;&gt; contour_of_points&lt;T&gt;::Split_Along_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;T&gt; &amp;theplane) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_of_points&lt;T&gt;&gt; output;

    <I><FONT COLOR="#B22222">//Re-written for the Nth time because behaviour was not identical between 32bit and 64bit machines. After some minor
</FONT></I>    <I><FONT COLOR="#B22222">// tweaking, the 64bit and 32bit versions matched, but produced erroneous, brittle behaviour. 
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//I believe the result was due to the use of equality on the vec3's. Although it was done logically (comparing only 
</FONT></I>    <I><FONT COLOR="#B22222">// copies), I think some processors discarded extra bits (up to 80 bits are used on Intel machines). Ygor hypothesis
</FONT></I>    <I><FONT COLOR="#B22222">// is that when we had lots of contours we would blow the cache, forcing the cpu to discard extra bits. When reloading
</FONT></I>    <I><FONT COLOR="#B22222">// the values, comparing copies was somehow no longer valid. Just a theory, but it matched behaviour fairly well.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//I cannot tell if this routine will be good for non-planar contours or not. Ygor feeling is 'no', but I wonder about
</FONT></I>    <I><FONT COLOR="#B22222">// the overall ability to describe non-planar contours with a series of points. Maybe, if the curvature of the contour
</FONT></I>    <I><FONT COLOR="#B22222">// is small near the plane, and it is understood that the points are linearlly interpolated between to form the contour,
</FONT></I>    <I><FONT COLOR="#B22222">// then we will not actually observe any accidental loss in curvature from this routine.  I'll have to test it..
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Norig = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size();
    <B><FONT COLOR="#A020F0">if</FONT></B>(Norig &lt; 3) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Contour contains too few points to split&quot;</FONT></B>);

    <I><FONT COLOR="#B22222">//Search for adjacent, duplicate points. If any are found die immediately.
</FONT></I>    {
      <B><FONT COLOR="#228B22">auto</FONT></B> p1_it = --(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end()), p2_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin();
      <B><FONT COLOR="#A020F0">while</FONT></B>( (p2_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end()) &amp;&amp; (p1_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end()) ){
          <B><FONT COLOR="#A020F0">if</FONT></B>((*p1_it == *p2_it) &amp;&amp; (p1_it != p2_it)){
<I><FONT COLOR="#B22222">//              FUNCERR(&quot;Found an adjacent duplicated point in input contour&quot;);
</FONT></I>              FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Found an adjacent duplicated point in input contour - attempting removal&quot;</FONT></B>);
              <I><FONT COLOR="#B22222">//Duplicate the data.
</FONT></I>              contour_of_points&lt;T&gt; dup(*<B><FONT COLOR="#A020F0">this</FONT></B>);

              <I><FONT COLOR="#B22222">//Remove one of the points.
</FONT></I>              <B><FONT COLOR="#228B22">auto</FONT></B> p3_it = dup.points.begin();
              <B><FONT COLOR="#5F9EA0">std</FONT></B>::advance(p3_it,  std::distance(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(), p2_it));
              dup.points.erase(p3_it);

              <I><FONT COLOR="#B22222">//Pass off the computation as our own...
</FONT></I>              <B><FONT COLOR="#A020F0">return</FONT></B> std::move(dup.Split_Along_Plane(theplane));

          }<B><FONT COLOR="#A020F0">else</FONT></B>{
              p1_it = p2_it;
              ++p2_it;
          }
      }
    }

    <I><FONT COLOR="#B22222">//Generate a center point for the entire contour. It shouldn't matter how precise it is,
</FONT></I>    <I><FONT COLOR="#B22222">// but is safest to use the centroid.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Rcentre = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Centroid();

    <I><FONT COLOR="#B22222">//Produce a dual of the contour points: a list of *pointers* to each element.
</FONT></I>    <I><FONT COLOR="#B22222">// Insert a bool element so we can differentiate intersection points (later).
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;decltype(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()), <B><FONT COLOR="#228B22">bool</FONT></B>&gt;&gt; point_pointers;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(); p_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end(); ++p_it){
        point_pointers.push_back( std::pair&lt;decltype(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()), <B><FONT COLOR="#228B22">bool</FONT></B>&gt;(p_it,false) );
    }

    <I><FONT COLOR="#B22222">//Scan the points. We do three things here:
</FONT></I>    <I><FONT COLOR="#B22222">// 1) determine the total number of plane crossings,
</FONT></I>    <I><FONT COLOR="#B22222">// 2) identify the (arbitrary) first intersection point, and
</FONT></I>    <I><FONT COLOR="#B22222">// 3) insert intersection points as needed. These are the only newly generated points!
</FONT></I>    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> number_of_crossings(0);
    <B><FONT COLOR="#228B22">auto</FONT></B> first_intersection = point_pointers.end();
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;vec3&lt;T&gt;&gt; intersections;
    {
      vec3&lt;T&gt; intersection;
      <B><FONT COLOR="#228B22">auto</FONT></B> p1_it = --(point_pointers.end()), p2_it = point_pointers.begin();
      <B><FONT COLOR="#A020F0">while</FONT></B>((p2_it != point_pointers.end()) &amp;&amp; (p1_it != point_pointers.end())){
          <I><FONT COLOR="#B22222">//This if statement could be replaced with a function Intersects_With_Line_Once***_Segment***(...).
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B>( theplane.Is_Point_Above_Plane(*(p1_it-&gt;first)) != theplane.Is_Point_Above_Plane(*(p2_it-&gt;first)) ){
              <B><FONT COLOR="#A020F0">if</FONT></B>(!theplane.Intersects_With_Line_Once(line&lt;T&gt;(*(p1_it-&gt;first),*(p2_it-&gt;first)),intersection)){
                  FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to determine where plane intersects line (we know they cross). This is probably a floating-point booboo&quot;</FONT></B>);
              }

              <I><FONT COLOR="#B22222">//Increment the counter.
</FONT></I>              ++number_of_crossings;

              <I><FONT COLOR="#B22222">//Insert the intersection point in between p1_it and p2_it.
</FONT></I>              <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> i_it = intersections.insert(intersections.end(),intersection);
              <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> p12_it = point_pointers.insert(p2_it,std::pair&lt;decltype(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()), <B><FONT COLOR="#228B22">bool</FONT></B>&gt;(i_it, true));

              <I><FONT COLOR="#B22222">//Mark the first intersection, if appropriate.
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B>(first_intersection == point_pointers.end()) first_intersection = p12_it;
          }
          p1_it = p2_it;
          ++p2_it;
      }
    }

    <I><FONT COLOR="#B22222">//Check for special cases an errors.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(number_of_crossings == 0){
        output.push_back(*<B><FONT COLOR="#A020F0">this</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> output;
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(number_of_crossings % 2 != 0){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Generated an odd number of plane crossings. This is impossible for a closed, non-overlapping contour&quot;</FONT></B>);
    }

    <I><FONT COLOR="#B22222">//Rotate the list so the first intersection is the first point.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::rotate(point_pointers.begin(), first_intersection, point_pointers.end());

    <I><FONT COLOR="#B22222">//Duplicate the first intersection so we can cycle through more easily.
</FONT></I>    point_pointers.push_back(point_pointers.front());

    <I><FONT COLOR="#B22222">//Sort the intersection points twice. First to find the most distant point from the centroid
</FONT></I>    <I><FONT COLOR="#B22222">// and then in increasing distance from that point. Afterward, the first will have distance 0.0.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> lambda_dist_from_Rcentre = [Rcentre](<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;B) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> Rcentre.distance(A) &lt; Rcentre.distance(B);
    }; 
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Redge = *std::max_element(intersections.begin(), intersections.end(), lambda_dist_from_Rcentre);
    <B><FONT COLOR="#228B22">auto</FONT></B> lambda_dist_from_Redge = [Redge](<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;B) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> Redge.distance(A) &lt; Redge.distance(B);
    };
    intersections.sort(lambda_dist_from_Redge);

    <I><FONT COLOR="#B22222">//The intersections are now ordered in such a way that for each N, intersection # 2*N and 2*N+1 are joined 
</FONT></I>    <I><FONT COLOR="#B22222">// by crossing contour and NOT empty space along the plane. Furthermore, all other intersections cannot be
</FONT></I>    <I><FONT COLOR="#B22222">// joined in such a way.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Explicitly group them into pairs. We treat the iterator's dereferenced object's address (cast to size_t) 
</FONT></I>    <I><FONT COLOR="#B22222">// as the map key. This means two iterators pointing to same point are considered equal.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: Ensure no ...end()'s get pushed into the map. They do not point to anything (I think) which will 
</FONT></I>    <I><FONT COLOR="#B22222">// cause undefined behaviour (or worse - maybe silent error or seg faults).
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::unordered_map&lt;decltype(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()), decltype(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()), std::function&lt;size_t (<B><FONT COLOR="#228B22">const</FONT></B> decltype(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()) &amp;x)&gt;&gt;
    intersection_pairs(24, [](<B><FONT COLOR="#228B22">const</FONT></B> decltype(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()) &amp;x){
            <B><FONT COLOR="#A020F0">return</FONT></B> (size_t)(&amp;(*x)); <I><FONT COLOR="#B22222">//Get address of object pointed to casted to size_t.
</FONT></I>        });

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> v2_it = intersections.begin(); v2_it != intersections.end(); ){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> v1_it = v2_it;
        ++v2_it;
        intersection_pairs[v1_it] = v2_it;
        intersection_pairs[v2_it] = v1_it;
        ++v2_it;
    }

    <I><FONT COLOR="#B22222">//Prepare a new contour buffer.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> nc_it = output.end();
    output.push_back(contour_of_points&lt;T&gt;());
    nc_it = --(output.end());
    nc_it-&gt;closed = true;
    
    <I><FONT COLOR="#B22222">//Go until we have inserted all non-intersection points into appropriate contours. 
</FONT></I>    <B><FONT COLOR="#A020F0">while</FONT></B>(true){ <I><FONT COLOR="#B22222">//point_pointers.size() != (Norig + intersections.size() + 1)){
</FONT></I>        <I><FONT COLOR="#B22222">//Start at the first available normal point.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> p_it_it = point_pointers.begin();
        <B><FONT COLOR="#A020F0">while</FONT></B>(p_it_it-&gt;second == true){ 
            ++p_it_it;
            <B><FONT COLOR="#A020F0">if</FONT></B>(!(p_it_it != point_pointers.end())) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Ran out of non-intersection points before completing contour&quot;</FONT></B>);
        }
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> beginning = --p_it_it; <I><FONT COLOR="#B22222">//First intersection point beginning line segment.
</FONT></I>        ++p_it_it;
        
        <B><FONT COLOR="#A020F0">while</FONT></B>(true){
            <I><FONT COLOR="#B22222">//------------------------ Error Catching ---------------------------
</FONT></I>            <I><FONT COLOR="#B22222">//Catch 1 - Run out of points.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(!(p_it_it != point_pointers.end())){
                FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Ran out of points during contour generation. This shouldn't happen&quot;</FONT></B>);
            
            <I><FONT COLOR="#B22222">//Catch 2 - We have looped around and didn't properly catch it.
</FONT></I>            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(p_it_it == beginning){
                FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;We have looped around and did not properly exit contour generation loop&quot;</FONT></B>);
            }
            <I><FONT COLOR="#B22222">//---------------------- Point Accumulation -------------------------
</FONT></I>            <I><FONT COLOR="#B22222">//Case 1 - This is a normal point.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(p_it_it-&gt;second == false){
                <I><FONT COLOR="#B22222">//Push it back by value, remove it from pointer list, and continue along this
</FONT></I>                <I><FONT COLOR="#B22222">// line segment sequentially.
</FONT></I>                nc_it-&gt;points.push_back( *(p_it_it-&gt;first) );
                p_it_it = point_pointers.erase(p_it_it);
                <B><FONT COLOR="#A020F0">continue</FONT></B>;

            <I><FONT COLOR="#B22222">//Case 2 - This is an intersection point.
</FONT></I>            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                <I><FONT COLOR="#B22222">//Push it back.
</FONT></I>                nc_it-&gt;points.push_back( *(p_it_it-&gt;first) );

                <I><FONT COLOR="#B22222">//Find out which intersection we should jump to. We have to work backward because
</FONT></I>                <I><FONT COLOR="#B22222">// we do not (atm) have a mapping from point iterators to map iterators (aka point
</FONT></I>                <I><FONT COLOR="#B22222">// iterator iterators).
</FONT></I>                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> jump_p_it = intersection_pairs[p_it_it-&gt;first];
                decltype(p_it_it) jump_it_it = point_pointers.begin();
                <B><FONT COLOR="#A020F0">while</FONT></B>(jump_it_it-&gt;first != jump_p_it){
                    ++jump_it_it;
                    <B><FONT COLOR="#A020F0">if</FONT></B>(!(jump_it_it != point_pointers.end())){
                        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to find intersection point to jump to. Has it been removed?&quot;</FONT></B>);
<I><FONT COLOR="#B22222">//Might also be a mistake in iteration, removing points, or anything...
</FONT></I>                    }
                }

                <I><FONT COLOR="#B22222">//If the jump intersection is the one we started on, add it and break out.
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B>(jump_it_it == beginning){
                    nc_it-&gt;points.push_back( *(beginning-&gt;first) );
                    <B><FONT COLOR="#A020F0">break</FONT></B>;

                <I><FONT COLOR="#B22222">//Otherwise, add the jump intersection and iterate past it (to avoid confusing the loop).
</FONT></I>                }<B><FONT COLOR="#A020F0">else</FONT></B>{
                    nc_it-&gt;points.push_back( *(jump_it_it-&gt;first) );
                    p_it_it = jump_it_it;
                    ++p_it_it;
                    <B><FONT COLOR="#A020F0">continue</FONT></B>;
                }
            }
        }

        <I><FONT COLOR="#B22222">//When we get here, we should have a complete contour sitting in the output's last slot.
</FONT></I>
        <I><FONT COLOR="#B22222">//If we have any non-intersection points remaining, we will loop again. Iterate the output
</FONT></I>        <I><FONT COLOR="#B22222">// contour's slot and continue;
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(point_pointers.size() != (<I><FONT COLOR="#B22222">/*Norig + */</FONT></I> intersections.size() + 1)){
            output.push_back(contour_of_points&lt;T&gt;());
            nc_it = --(output.end());
            nc_it-&gt;closed = true;
            <B><FONT COLOR="#A020F0">continue</FONT></B>;

        <I><FONT COLOR="#B22222">//If we make it here, we have used all points and filled the output with all necessary
</FONT></I>        <I><FONT COLOR="#B22222">// contours. Simply break out and continue.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#A020F0">break</FONT></B>;
        }
    }

    <I><FONT COLOR="#B22222">//------------------------------ Cursory verification ----------------------------------
</FONT></I>    <I><FONT COLOR="#B22222">//Search for adjacent, duplicate points. If any are found then warn, remove them, and try to recover.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = output.begin(); c_it != output.end(); ++c_it){
        <B><FONT COLOR="#228B22">auto</FONT></B> p1_it = --(c_it-&gt;points.end()), p2_it = c_it-&gt;points.begin();
        <B><FONT COLOR="#A020F0">while</FONT></B>( (p2_it != c_it-&gt;points.end()) &amp;&amp; (p1_it != c_it-&gt;points.end()) ){
            <B><FONT COLOR="#A020F0">if</FONT></B>((*p1_it == *p2_it) &amp;&amp; (p1_it != p2_it)){
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> posA = std::distance(c_it-&gt;points.begin(), p1_it);
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> posB = std::distance(c_it-&gt;points.begin(), p2_it);
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Found adjacent duplicated points in split contour (points #&quot;</FONT></B> &lt;&lt; posA &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; and &quot;</FONT></B> &lt;&lt; posB &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;. Removing one and continuing&quot;</FONT></B>);
                <I><FONT COLOR="#B22222">//Notes: 
</FONT></I>                <I><FONT COLOR="#B22222">// Keep an eye on when these pop up. I'm not sure where they originate from. I have seen them
</FONT></I>                <I><FONT COLOR="#B22222">// pop up due to mixing coronal/sagittal and per-volume/per-contour splitting after about 5
</FONT></I>                <I><FONT COLOR="#B22222">// splits. This gave #'s 1 and 2. Splitting again gave #'s 2 and 3.
</FONT></I>                <I><FONT COLOR="#B22222">//
</FONT></I>                <I><FONT COLOR="#B22222">// It is possible these are spit out from some other routine (line intersection is a point
</FONT></I>                <I><FONT COLOR="#B22222">// is exactly on a plane - we do not consider it a plane crossing if the point is exactly
</FONT></I>                <I><FONT COLOR="#B22222">// on the plane!)
</FONT></I>                <I><FONT COLOR="#B22222">//
</FONT></I>                <I><FONT COLOR="#B22222">// Overall, it seems like these occurences are rarely fatal. It is most likely OK to deal with
</FONT></I>                <I><FONT COLOR="#B22222">// them specially by-hand like this.
</FONT></I>
                <I><FONT COLOR="#B22222">//We should remove the first one so that we will notice if the next one is a duplicate too.
</FONT></I>                p1_it = c_it-&gt;points.erase(p1_it);
                <B><FONT COLOR="#A020F0">if</FONT></B>(c_it-&gt;points.size() &lt; 3) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;After removing duplicate point, contour contains &lt; 3 points. Unable to continue&quot;</FONT></B>);

            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                p1_it = p2_it;
                ++p2_it;
            }
        }
    }

  

    <I><FONT COLOR="#B22222">//Ensure the contours are oriented uniformly.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = output.begin(); c_it != output.end(); ++c_it){
        c_it-&gt;Reorient_Counter_Clockwise();
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(output);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<B><FONT COLOR="#228B22">template</FONT></B> std::list&lt; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Split_Along_Plane( <B><FONT COLOR="#228B22">const</FONT></B> plane&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;theplane ) <B><FONT COLOR="#228B22">const</FONT></B>;
<B><FONT COLOR="#228B22">template</FONT></B> std::list&lt; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Split_Along_Plane( <B><FONT COLOR="#228B22">const</FONT></B> plane&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;theplane ) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>




<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; contour_of_points&lt;T&gt; contour_of_points&lt;T&gt;::Bounding_Box_Along( <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;r_n, T margin<I><FONT COLOR="#B22222">/* = (T)(0.0)*/</FONT></I> ) <B><FONT COLOR="#228B22">const</FONT></B> {
    contour_of_points&lt;T&gt; bounding_box;
    bounding_box.closed = true;

    <B><FONT COLOR="#A020F0">if</FONT></B>(r_n.z != 0.0){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;This routine is unable to sensibly handle non-zero z-components in the direction unit vector. Please use another algorithm!&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> bounding_box;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt; 3 ){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Too few points in this contour to adaquetly compute a bounding box. Ignoring it and continuing..&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> bounding_box;
    }

    <I><FONT COLOR="#B22222">//Now we determine the (2D) bounding box (which is oriented with the unit vector!) by projecting each point onto 
</FONT></I>    <I><FONT COLOR="#B22222">// the r_1 and r_2 coordinate system.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; r_1( r_n.x, r_n.y, r_n.z);
    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; r_2(-r_n.y, r_n.x, r_n.z); <I><FONT COLOR="#B22222">//(= r_1 rotated by +pi/2).
</FONT></I>
    vec3&lt;T&gt; r_1_most  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.front();
    vec3&lt;T&gt; r_2_most  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.front();
    vec3&lt;T&gt; r_1_least = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.front();
    vec3&lt;T&gt; r_2_least = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.front();
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(); it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end(); ++it){
        <I><FONT COLOR="#B22222">//Length of the vector on the units which define the bounding box coordinates.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> T r_1_dot_centered  = r_1.Dot( (*it) );
        <B><FONT COLOR="#228B22">const</FONT></B> T r_2_dot_centered  = r_2.Dot( (*it) );
        
        <B><FONT COLOR="#228B22">const</FONT></B> T r_1_dot_r_1_most  = r_1.Dot( r_1_most  );  <I><FONT COLOR="#B22222">//It is silly to compute these each time. ...&quot;Clean up crew to aisle $HERE.&quot;
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> T r_1_dot_r_1_least = r_1.Dot( r_1_least );
        <B><FONT COLOR="#228B22">const</FONT></B> T r_2_dot_r_2_most  = r_2.Dot( r_2_most  );
        <B><FONT COLOR="#228B22">const</FONT></B> T r_2_dot_r_2_least = r_2.Dot( r_2_least );

        <B><FONT COLOR="#A020F0">if</FONT></B>( r_1_dot_centered &gt; r_1_dot_r_1_most  ) r_1_most  = (*it);
        <B><FONT COLOR="#A020F0">if</FONT></B>( r_1_dot_centered &lt; r_1_dot_r_1_least ) r_1_least = (*it);

        <B><FONT COLOR="#A020F0">if</FONT></B>( r_2_dot_centered &gt; r_2_dot_r_2_most  ) r_2_most  = (*it);
        <B><FONT COLOR="#A020F0">if</FONT></B>( r_2_dot_centered &lt; r_2_dot_r_2_least ) r_2_least = (*it);
    }
    <I><FONT COLOR="#B22222">//FUNCINFO(&quot; Four extremity points: &quot; &lt;&lt; r_1_most &lt;&lt; &quot;  --  &quot; &lt;&lt; r_2_most &lt;&lt; &quot;  --  &quot; &lt;&lt; r_1_least &lt;&lt; &quot;  --  &quot; &lt;&lt; r_2_least);
</FONT></I>
    <I><FONT COLOR="#B22222">//We have the extremity points from the contour now. We make four lines describing the bounding box, 
</FONT></I>    <I><FONT COLOR="#B22222">// and each line bounding box lies on top of a(t least one) point in the contour.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">// Counter clockwise orientation:  (clockwise would just negate each unit vector!)
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">// Line 1:  point = r_1_most  ,  unit vector = -r_2
</FONT></I>    <I><FONT COLOR="#B22222">// Line 2:  point = r_2_least ,  unit vector = -r_1
</FONT></I>    <I><FONT COLOR="#B22222">// Line 3:  point = r_1_least ,  unit vector =  r_2
</FONT></I>    <I><FONT COLOR="#B22222">// Line 4:  point = r_2_most  ,  unit vector =  r_1
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; u_l1( -r_2.x, -r_2.y, -r_2.z ),    p_l1( r_1_most  );
    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; u_l2( -r_1.x, -r_1.y, -r_1.z ),    p_l2( r_2_least );
    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; u_l3(  r_2.x,  r_2.y,  r_2.z ),    p_l3( r_1_least );
    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; u_l4(  r_1.x,  r_1.y,  r_1.z ),    p_l4( r_2_most  );

    <B><FONT COLOR="#228B22">const</FONT></B> line&lt;T&gt; L1( p_l1, p_l1 + u_l1 );
    <B><FONT COLOR="#228B22">const</FONT></B> line&lt;T&gt; L2( p_l2, p_l2 + u_l2 );
    <B><FONT COLOR="#228B22">const</FONT></B> line&lt;T&gt; L3( p_l3, p_l3 + u_l3 );
    <B><FONT COLOR="#228B22">const</FONT></B> line&lt;T&gt; L4( p_l4, p_l4 + u_l4 );

    <I><FONT COLOR="#B22222">//Now determine the four points where the bounding box intersects.
</FONT></I>    vec3&lt;T&gt; intersection;

<I><FONT COLOR="#B22222">/*
    //Negative (clockwise) orientation.
    if( L4.Intersects_With_Line_Once(L1, intersection) ){
        bounding_box.points.push_back( intersection + (r_1 + r_2)*margin);
    }else{
        FUNCERR(&quot;Unable to determine the point of intersection. Unable to continue&quot;);
    }

    if( L1.Intersects_With_Line_Once(L2, intersection) ){
        bounding_box.points.push_back( intersection + (r_1 - r_2)*margin);
    }else{
        FUNCERR(&quot;Unable to determine the point of intersection. Unable to continue&quot;);
    }

    if( L2.Intersects_With_Line_Once(L3, intersection) ){
        bounding_box.points.push_back( intersection - (r_1 + r_2)*margin);
    }else{
        FUNCERR(&quot;Unable to determine the point of intersection. Unable to continue&quot;);
    }

    if( L3.Intersects_With_Line_Once(L4, intersection) ){
        bounding_box.points.push_back( intersection + (r_2 - r_1)*margin);
    }else{
        FUNCERR(&quot;Unable to determine the point of intersection. Unable to continue&quot;);
    }
*/</FONT></I>

    <I><FONT COLOR="#B22222">//Positive (counter-clockwise) orientation.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( L4.Intersects_With_Line_Once(L1, intersection) ){
        bounding_box.points.push_back( intersection + (r_1 + r_2)*margin);
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
<I><FONT COLOR="#B22222">//        FUNCERR(&quot;Unable to determine the point of intersection 1. Unable to continue&quot;);
</FONT></I>        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Could not determine exact point of intersection (1). Computing closest-point instead&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">if</FONT></B>( L4.Closest_Point_To_Line(L1, intersection) ){
            bounding_box.points.push_back( intersection + (r_1 + r_2)*margin);
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to determine closest point on L4 to L1. Cannot proceed&quot;</FONT></B>);
        }
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>( L3.Intersects_With_Line_Once(L4, intersection) ){
        bounding_box.points.push_back( intersection + (r_2 - r_1)*margin);
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
<I><FONT COLOR="#B22222">//        FUNCERR(&quot;Unable to determine the point of intersection 2. Unable to continue&quot;);
</FONT></I>        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Could not determine exact point of intersection (2). Computing closest-point instead&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">if</FONT></B>( L3.Closest_Point_To_Line(L4, intersection) ){
            bounding_box.points.push_back( intersection + (r_2 - r_1)*margin);
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to determine closest point on L3 to L4. Cannot proceed&quot;</FONT></B>);
        }
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>( L2.Intersects_With_Line_Once(L3, intersection) ){
        bounding_box.points.push_back( intersection - (r_1 + r_2)*margin);
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
<I><FONT COLOR="#B22222">//        FUNCERR(&quot;Unable to determine the point of intersection 3. Unable to continue&quot;);
</FONT></I>        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Could not determine exact point of intersection (3). Computing closest-point instead&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">if</FONT></B>( L2.Closest_Point_To_Line(L3, intersection) ){
            bounding_box.points.push_back( intersection - (r_1 + r_2)*margin);
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to determine closest point on L2 to L3. Cannot proceed&quot;</FONT></B>);
        }
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>( L1.Intersects_With_Line_Once(L2, intersection) ){
        bounding_box.points.push_back( intersection + (r_1 - r_2)*margin);
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
<I><FONT COLOR="#B22222">//        FUNCERR(&quot;Unable to determine the point of intersection 4. Unable to continue&quot;);
</FONT></I>        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Could not determine exact point of intersection (4). Computing closest-point instead&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">if</FONT></B>( L1.Closest_Point_To_Line(L2, intersection) ){
            bounding_box.points.push_back( intersection + (r_1 - r_2)*margin);
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to determine closest point on L1 to L2. Cannot proceed&quot;</FONT></B>);
        }
    }


    <I><FONT COLOR="#B22222">//Now we dump the bounding box contour.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> bounding_box;
}

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Bounding_Box_Along( <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp; , <B><FONT COLOR="#228B22">float</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> ;
<B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Bounding_Box_Along( <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; , <B><FONT COLOR="#228B22">double</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> ;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This routine is hacky and doesn't produce the most reliable results. In particular, we wrap each contour in a bounding box
</FONT></I><I><FONT COLOR="#B22222">// and ray-cast within the edges of the box. This means that mis-shapen contours will be troublesome.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//The number of generated points needs to be quite high to avoid unsightly edges and corners. A proper routine would
</FONT></I><I><FONT COLOR="#B22222">// address these points (or maybe at least smooth the unsightly edges).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Works somewhat alright, but we haven't had a need to use it yet. Fix it if you need to!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::list&lt; contour_of_points&lt;T&gt; &gt; contour_of_points&lt;T&gt;::Split_Against_Ray( <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;r_n ) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_of_points&lt;T&gt;&gt; output;

    FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;This routine may or may not work OK.&quot;</FONT></B>);

    <I><FONT COLOR="#B22222">//Grab the bounding box.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;T&gt; the_bounding_box = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Bounding_Box_Along(r_n, 1.0);
    <B><FONT COLOR="#A020F0">if</FONT></B>(the_bounding_box.points.size() != 4){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to compute a bounding box. Ignoring and continuing.&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> output;
    }

    <I><FONT COLOR="#B22222">//Given the bounding box and the contour data, we now crawl along the edge and ray cast through the contour. 
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> number_of_contour_points = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size());
    <I><FONT COLOR="#B22222">//const long int number_of_new_points = number_of_contour_points;  //Too many!
</FONT></I>    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> number_of_new_points = number_of_contour_points / 3;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> min_number_of_new_points = 10;    <I><FONT COLOR="#B22222">//NOTE: We are NOT guaranteed to get this many. This is an upper bound!
</FONT></I>                                                     <I><FONT COLOR="#B22222">// The bounding box may cover a large area which is void of contour!
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( number_of_new_points &lt; min_number_of_new_points ) number_of_new_points = min_number_of_new_points;

    <B><FONT COLOR="#228B22">auto</FONT></B> BB_point_iter = the_bounding_box.points.begin();
    <I><FONT COLOR="#B22222">//These points are considered to be specified in a counter clockwise orientation. 
</FONT></I>
    <I><FONT COLOR="#B22222">//const vec3&lt;T&gt; r_0 = (*BB_point_iter); //  &lt;--- This one is not used here. Maybe I should use it?
</FONT></I>    ++BB_point_iter;
    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; r_1 = (*BB_point_iter); 
    ++BB_point_iter;
    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; r_2 = (*BB_point_iter); 
    ++BB_point_iter;
    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; r_3 = (*BB_point_iter); 

    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; dr_32(r_3 - r_2); <I><FONT COLOR="#B22222">//WAS r2 - r1. 
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> T width_of_bb = dr_32.length();
    <B><FONT COLOR="#228B22">const</FONT></B> T dL = width_of_bb / static_cast&lt;T&gt;(number_of_new_points); <I><FONT COLOR="#B22222">//dL is the length of separation between ray casts along the unit vector orthogonal to r_n in the XY plane.
</FONT></I>    
    <I><FONT COLOR="#B22222">//We work our way along the bounding box's &quot;lower&quot; edge and ray cast upward through the contour in the direction of the unit vector provided.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;vec3&lt;T&gt;&gt; halfway_points;
    vec3&lt;T&gt; u_ray(r_1 - r_2);   <I><FONT COLOR="#B22222">//WAS r_3 - r_2 !!!
</FONT></I><I><FONT COLOR="#B22222">//    u_ray -= r_2;
</FONT></I>    u_ray.z = 0.0;
    u_ray = u_ray.unit();

    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> TIMES_STUCK_IN_KEY = 0; <I><FONT COLOR="#B22222">//Hack to ensure we don't loop endlessly...
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(T L = 0.05*dL; L &lt; width_of_bb; L += dL){
        <I><FONT COLOR="#B22222">//First, we precisely specify the ray cast line. u_ray is the unit vector and p_ray is the point defining the line of the ray. It is NOT constrained to the bounding box!
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; p_ray = r_2 + r_n*L;

        <I><FONT COLOR="#B22222">//Now we find which pairs of points are joined by a line which intersects the ray cast line. We determine the precise point where the pair of point's line intersects the ray cast line.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;vec3&lt;T&gt;&gt; intersection_points;

        <I><FONT COLOR="#B22222">//Get all intersection points.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> plane&lt;T&gt; theplane(r_n, p_ray); 
        {
            <B><FONT COLOR="#228B22">auto</FONT></B> iter_1 = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed ? --(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end()) :    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin();
            <B><FONT COLOR="#228B22">auto</FONT></B> iter_2 = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed ?   <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin() : ++(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin());

<I><FONT COLOR="#B22222">//            auto iter_1 = this-&gt;points.begin();
</FONT></I><I><FONT COLOR="#B22222">//            auto iter_2 = ++(this-&gt;points.begin());
</FONT></I>            <B><FONT COLOR="#A020F0">for</FONT></B>( ;  iter_2 != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end();  ++iter_2){
                vec3&lt;T&gt; intersection;
                <B><FONT COLOR="#A020F0">if</FONT></B>(theplane.Is_Point_Above_Plane(*iter_1) != theplane.Is_Point_Above_Plane(*iter_2)){
                    <B><FONT COLOR="#A020F0">if</FONT></B>(theplane.Intersects_With_Line_Once(line&lt;T&gt;(*iter_1,*iter_2), intersection)){
                        intersection_points.push_back( intersection );
                    }<B><FONT COLOR="#A020F0">else</FONT></B>{
                        FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Unable to find intersection (maybe it intersects many times?). Assuming center point is intersection!&quot;</FONT></B>);
                        intersection_points.push_back( (*iter_1 + *iter_2)*0.5 );
                    }
                }
                iter_1 = iter_2;
            }
        }

        <I><FONT COLOR="#B22222">//Now we sort the intersections based on their distance from the edge of the bounding box. This is required because the contour can snake around any number of ways, and we might
</FONT></I>        <I><FONT COLOR="#B22222">// not start circling the contour at the point nearest the first (&quot;lowest&quot;) intersection.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> lambda_distance_along_u_ray = [u_ray](<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;b) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> (u_ray.Dot(a) &lt; u_ray.Dot(b)); };

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::sort( intersection_points.begin(), intersection_points.end(), lambda_distance_along_u_ray );
 
        <I><FONT COLOR="#B22222">//Now, given the total number of intersections, we can compute the total length of the ray cast which is within the contour.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( (intersection_points.size() % 2) != 0 ){
            ++TIMES_STUCK_IN_KEY;
            <B><FONT COLOR="#A020F0">if</FONT></B>(TIMES_STUCK_IN_KEY &gt; 25){
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;We have crossed an odd number of contour lines, but we should have crossed an even number. Unable to nudge, so giving up!&quot;</FONT></B>);
                <B><FONT COLOR="#A020F0">continue</FONT></B>;
            }

<I><FONT COLOR="#B22222">//            FUNCERR(&quot;We have crossed an odd number of contour lines, but we should have crossed an even number.&quot;);
</FONT></I><I><FONT COLOR="#B22222">//            FUNCWARN(&quot;We have crossed an odd number of contour lines, but we should have crossed an even number. Nudging ray slightly...&quot;);
</FONT></I>            L += 0.01*dL;
            L -= dL;  <I><FONT COLOR="#B22222">//To counter the loop's L += dL.
</FONT></I>            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>( intersection_points.size() == 0 ){
            ++TIMES_STUCK_IN_KEY;
            <B><FONT COLOR="#A020F0">if</FONT></B>(TIMES_STUCK_IN_KEY &gt; 25){
                FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;We failed to find any points of intersection. Unable to nudge, so giving up!&quot;</FONT></B>);
                <B><FONT COLOR="#A020F0">continue</FONT></B>;
            }
<I><FONT COLOR="#B22222">//            FUNCERR(&quot;We failed to find any points of intersection. This is likely an issue with the bounding box or the data being wonky. This could be due to multi-contour input - if so, fix me please!&quot;);
</FONT></I><I><FONT COLOR="#B22222">//            FUNCWARN(&quot;We failed to find any points of intersection - was the contour oddly shaped, excessively small, or very point-sparse? Nudging ray slightly...&quot;);
</FONT></I>            L -= 0.007*dL;
            L -= dL;  <I><FONT COLOR="#B22222">//To counter the loop's L += dL.
</FONT></I>            <B><FONT COLOR="#A020F0">continue</FONT></B>;
<I><FONT COLOR="#B22222">//return output;
</FONT></I>        }

        TIMES_STUCK_IN_KEY = 0;

        T contour_length_at_this_L = 0.0;
        <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; (2*i)&lt;intersection_points.size(); ++i){
            contour_length_at_this_L += intersection_points[2*i + 0].distance( intersection_points[2*i + 1] );
        }

        <I><FONT COLOR="#B22222">//Knowing this total length, we can walk through the intersection points until we find the point which is halfway through the contour (but which is somewhere inside the contour!)
</FONT></I>        vec3&lt;T&gt; the_center_point;
        T remaining_contour_halfway_length = 0.5*contour_length_at_this_L;
        <B><FONT COLOR="#228B22">bool</FONT></B> found_a_center_point = false;
        <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; (2*i)&lt;intersection_points.size(); ++i){
            <B><FONT COLOR="#228B22">const</FONT></B> T separation = intersection_points[2*i + 0].distance( intersection_points[2*i + 1] );

            <I><FONT COLOR="#B22222">//If we do not terminate the search for the halfway point within this pair of intersection points.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>( remaining_contour_halfway_length &gt; separation ){
                remaining_contour_halfway_length -= separation;

            <I><FONT COLOR="#B22222">//If we DO terminate between this pair.
</FONT></I>            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                found_a_center_point = true;
                the_center_point = intersection_points[2*i + 0] + u_ray * remaining_contour_halfway_length;
                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }

        <I><FONT COLOR="#B22222">//Knowing this point, we push it back into the list of halfway points. Since we have walked the bounding box in a specific way, we will be able to place the point with the correct contour given
</FONT></I>        <I><FONT COLOR="#B22222">// its location in the halfway point vector.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(found_a_center_point == true){
            halfway_points.push_back( the_center_point );
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Was unable to find a center-point. This is an algorithmic error.&quot;</FONT></B>);
        }

    }

    <B><FONT COLOR="#A020F0">if</FONT></B>( halfway_points.size() == 0 ){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;No mid-contour points were generated. Not exactly sure why.. Maybe insufficient number of points were requested?&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> output;
    }

    <I><FONT COLOR="#B22222">//We should now have an ordered list of center points which split the contour. We just have to figure out where best to attach them to the contour endpoints.
</FONT></I>    <I><FONT COLOR="#B22222">// We take the two (newly-generated) endpoints and determine which contour point is nearest to them. We then split the contours on these points.
</FONT></I>
    vec3&lt;T&gt; nearest_first( (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.front() );
    vec3&lt;T&gt; nearest_last( (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.front() );
    vec3&lt;T&gt; halfway_first = halfway_points.front();
    vec3&lt;T&gt; halfway_last  = halfway_points.back();

    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> offset_first = 0;
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> offset_last  = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.begin(); it != (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.end(); ++it ){
        <B><FONT COLOR="#A020F0">if</FONT></B>( halfway_first.distance( (*it) ) &lt; halfway_first.distance( nearest_first ) ){
            nearest_first = (*it);
            offset_first = std::distance( (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.begin(), it );
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>( halfway_last.distance( (*it) )  &lt; halfway_last.distance(  nearest_last )  ){
            nearest_last  = (*it);
            offset_last = std::distance( (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.begin(), it );
        }
    }

    <I><FONT COLOR="#B22222">//At this point, the contour is split into two pieces. We enter the contour loop by inserting the halfway points and then looping around as needed.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt; vec3&lt;T&gt; &gt; contour_A;  <I><FONT COLOR="#B22222">//Goes in direction from first to last along the halfway points.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt; vec3&lt;T&gt; &gt; contour_B;  <I><FONT COLOR="#B22222">//Goes in direction from last to first along the halfway points.
</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i &lt; static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(halfway_points.size()); ++i){
        contour_A.push_back( halfway_points[i] );
        contour_B.push_back( halfway_points[(halfway_points.size() - 1) - i] );
    }

    { <I><FONT COLOR="#B22222">//Contour A.
</FONT></I>      <B><FONT COLOR="#228B22">bool</FONT></B> passed_first = false;
      <B><FONT COLOR="#228B22">bool</FONT></B> passed_last  = false;
      <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0;
      <B><FONT COLOR="#A020F0">while</FONT></B>(!(passed_first &amp;&amp; passed_last)){
          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ii = i%(*<B><FONT COLOR="#A020F0">this</FONT></B>).points.size();
          <B><FONT COLOR="#A020F0">if</FONT></B>( ii == offset_last ){
              passed_last = true;  <I><FONT COLOR="#B22222">//Start pushing points and watching for the first point during this iteration.
</FONT></I>          }
          <B><FONT COLOR="#A020F0">if</FONT></B>( (ii == offset_first) &amp;&amp; (passed_last == true) ){
              passed_first = true; <I><FONT COLOR="#B22222">//Exit the loop after this iteration (we need both first and last endpoints on the contours.)
</FONT></I>          }
          <B><FONT COLOR="#A020F0">if</FONT></B>(passed_last == true){
              <B><FONT COLOR="#228B22">auto</FONT></B> it = (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.begin();
              <B><FONT COLOR="#5F9EA0">std</FONT></B>::advance(it, ii);
              contour_A.push_back( (*it) );
          }
          ++i;
      }
    }

    { <I><FONT COLOR="#B22222">//Contour B.
</FONT></I>      <B><FONT COLOR="#228B22">bool</FONT></B> passed_first = false;
      <B><FONT COLOR="#228B22">bool</FONT></B> passed_last  = false;
      <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0;
      <B><FONT COLOR="#A020F0">while</FONT></B>(!(passed_first &amp;&amp; passed_last)){
          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ii = i%(*<B><FONT COLOR="#A020F0">this</FONT></B>).points.size();
          <B><FONT COLOR="#A020F0">if</FONT></B>( (ii == offset_last) &amp;&amp; (passed_first == true) ){
              passed_last = true;  <I><FONT COLOR="#B22222">//Exit the loop after this iteration (we need both first and last endpoints on the contours.)
</FONT></I>          }
          <B><FONT COLOR="#A020F0">if</FONT></B>( ii == offset_first ){
              passed_first = true; <I><FONT COLOR="#B22222">//Start pushing points and watching for the first point during this iteration.
</FONT></I>          }
          <B><FONT COLOR="#A020F0">if</FONT></B>(passed_first == true){
              <B><FONT COLOR="#228B22">auto</FONT></B> it = (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.begin();
              <B><FONT COLOR="#5F9EA0">std</FONT></B>::advance(it, ii);
              contour_B.push_back( (*it) );
          }
          ++i;
      }
    }


   {
    contour_of_points&lt;T&gt; temp;
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;contour_A.size(); ++i){
        temp.points.push_back( contour_A[i] );
    }
    temp.closed = true;
    temp.Remove_Sequential_Duplicate_Points(nullptr);    <I><FONT COLOR="#B22222">//NOTE: May fail if &lt;= 3 points remain...  Maybe resample for small point sizes?
</FONT></I>    output.push_back( temp );
   }

   {
    contour_of_points&lt;T&gt; temp;
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;contour_B.size(); ++i){
        temp.points.push_back( contour_B[i] );
    }
    temp.closed = true;
    temp.Remove_Sequential_Duplicate_Points(nullptr);    <I><FONT COLOR="#B22222">//NOTE: May fail if &lt;= 3 points remain...  Maybe resample for small point sizes?
</FONT></I>    output.push_back( temp );
   }

    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(output);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Split_Against_Ray(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
<B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Split_Against_Ray(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Splits contour into an inner (core) and outer (peel). Projects from 3D point onto contour plane. The 2D ~analog is Scale_Dist_From_Point().
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Only use this routine on simple, ~spherical/round contours. No ray-casting is performed, so it will not gracefully handle
</FONT></I><I><FONT COLOR="#B22222">// large dips or folds (unless a very small core is desired).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: It is recommended to use a contour collection's centroid (but go nuts, if desired).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine always creates TWO output contours. The core is always first. One or more may be empty, so make sure to check!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::list&lt;contour_of_points&lt;T&gt;&gt; contour_of_points&lt;T&gt;::Split_Into_Core_Peel_Spherical(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;point, T frac_dist) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_of_points&lt;T&gt;&gt; output;
    <B><FONT COLOR="#A020F0">if</FONT></B>(frac_dist &lt; (T)(0.0)){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Passed a negative scale factor. This is nonsensical and nothing reasonable can be computed. Continuing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> std::move(output);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(frac_dist &gt; (T)(1.0)){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Passed a scale factor &gt; 1.0. This case is not handled and would produce a core larger than peel! Continuing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> std::move(output);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.empty()){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempted to perform core and peel splitting with no contour points! Continuing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> std::move(output);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed != true){ 
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;The core and peel technique is not able to reasonably handle open contours. Unable to continue&quot;</FONT></B>);
        <I><FONT COLOR="#B22222">//The peel is easy enough to deal with, but how do we treat the core? Should we always assume it
</FONT></I>        <I><FONT COLOR="#B22222">// is closed, no matter what? This is quite ambiguous. It seems ill-defined to consider a core and
</FONT></I>        <I><FONT COLOR="#B22222">// peel for contours which are open!
</FONT></I>    }

    <I><FONT COLOR="#B22222">//Prepare space for the inner and outer data.
</FONT></I>    output.push_back(contour_of_points&lt;T&gt;()); <I><FONT COLOR="#B22222">//inner (core).
</FONT></I>    output.push_back(contour_of_points&lt;T&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points)); <I><FONT COLOR="#B22222">//outer (peel).
</FONT></I>    output.front().closed = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed;
    output.back().closed  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed;

    <I><FONT COLOR="#B22222">//Loop through the points, computing the boundary between core and peel via projection
</FONT></I>    <I><FONT COLOR="#B22222">// (ie. the contour of the core/inner contour of peel). 
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> C = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Centroid();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> P_C = point - C;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> P_C_len = P_C.length();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> P_C_sq_len = P_C_len * P_C_len;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(); p_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end(); ++p_it){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Pi_P = (*p_it) - point;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Pi_P_len = Pi_P.length();
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Pi_P_sq_len = Pi_P_len * Pi_P_len;

        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> C_Pi = C - (*p_it);
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> C_Pi_len = C_Pi.length();
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> C_Pi_sq_len = C_Pi_len * C_Pi_len;

        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> numer = (T)(2.0)*((T)(1.0)-frac_dist)*C_Pi_len*Pi_P_sq_len;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> denom = C_Pi_sq_len + Pi_P_sq_len - P_C_sq_len;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> D = std::isfinite((T)(1.0)/denom) ? (numer/denom) : std::numeric_limits&lt;T&gt;::max();
        <I><FONT COLOR="#B22222">//Only push back points which remain on the present side (and within the bounds) of the centroid.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(isininc((T)(0.0),D,C_Pi_len)){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> PiPrime = C_Pi.unit()*D + (*p_it);
            output.front().points.push_back(PiPrime);
        }
    }

    <I><FONT COLOR="#B22222">//The inner (core, first) is ready to go, but we need to boolean subtract it from the outer (peel).
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(output.front().points.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> std::move(output);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> peel_final_point = output.back().points.back();

    decltype(output.front().points) inner_copy(output.front().points);
    inner_copy.push_back( inner_copy.front() );
    inner_copy.reverse();

    output.back().points.splice(output.back().points.end(), std::move(inner_copy));
    output.back().points.push_back(peel_final_point);

    <I><FONT COLOR="#B22222">//Cleanup to contours.
</FONT></I>    output.front().Remove_Sequential_Duplicate_Points(nullptr);
    output.back().Remove_Sequential_Duplicate_Points(nullptr);
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(output);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Split_Into_Core_Peel_Spherical(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;, <B><FONT COLOR="#228B22">float</FONT></B>  frac_dist) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Split_Into_Core_Peel_Spherical(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;, <B><FONT COLOR="#228B22">double</FONT></B> frac_dist) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This function sums all the contour points and divides by the number of points, giving the 'average' point. This could be used as a 
</FONT></I><I><FONT COLOR="#B22222">// center point, a rough indication of 'where' a contour is, or as a means of rotating the contour.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec3&lt;T&gt; contour_of_points&lt;T&gt;::Average_Point(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    vec3&lt;T&gt; out((T)(0), (T)(0), (T)(0));
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> iter = (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.begin(); iter != (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.end(); ++iter){
        out += (*iter);
    }
    out /= (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.size();
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Average_Point(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Average_Point(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This function returns the 'average pointed weighted by the area enclosed by the contour.' In other words, this returns the 
</FONT></I><I><FONT COLOR="#B22222">// center of mass of contour if the contour were filled with a homogeneous medium with a planar mass density.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Splitting a contour on this point (along a straight line in the plane of the contour which intersects this point) will 
</FONT></I><I><FONT COLOR="#B22222">// result in two or more contours. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// NOTE: This routine will *NOT* provide a point about which to generically split a contour into parts of equal area, despite
</FONT></I><I><FONT COLOR="#B22222">// what you may have read online about 'centroids.' If you do not believe this to be true, compute the centroid for a simple
</FONT></I><I><FONT COLOR="#B22222">// right triangle and then split it into two parts using a straight line of non-round-number slope. Compute the area of each
</FONT></I><I><FONT COLOR="#B22222">// piece and examine that it is not what you might expect. In particular, if the result is &quot;off by a bit,&quot; observe that the
</FONT></I><I><FONT COLOR="#B22222">// difference IS off by a bit! There is no such generic &quot;splits it into two&quot; point even for a simple polygon!
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec3&lt;T&gt; contour_of_points&lt;T&gt;::Centroid(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//If there are pathological cases, we can deal with them fairly easily.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() == 0) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Attempted to compute Center of area for a contour with no points&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt; 3){
         vec3&lt;T&gt; R((T)(0), (T)(0), (T)(0));
         <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> i = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(); i != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end(); i++){
             R += *i;
         }
         R /= static_cast&lt;T&gt;( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() );
         <B><FONT COLOR="#A020F0">return</FONT></B> R;
    }

    <I><FONT COLOR="#B22222">//First, we determine the average contour point. We hope that this is within the contour. 
</FONT></I>    <I><FONT COLOR="#B22222">// More precisely, we hope the contour is planar (or nearly planar!) Any point interior to 
</FONT></I>    <I><FONT COLOR="#B22222">// the contour will work, though, so maybe this should be fixed.                 FIXME
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; C( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Average_Point() );
    vec3&lt;T&gt; RA((T)(0), (T)(0), (T)(0));
    T Area = (T)(0);

    <I><FONT COLOR="#B22222">//Cycle through the points in the contour sequentially, accumulating the area and area*center of the 
</FONT></I>    <I><FONT COLOR="#B22222">// triangle made by two neighbouring points (A and B) and the center point (C).
</FONT></I>    contour_of_points&lt;T&gt; temp_contour;
    temp_contour.closed = true;
    <B><FONT COLOR="#228B22">auto</FONT></B> j = --( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end() );
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> i = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(); i != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end(); j = i++){
        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; A = *j;
        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; B = *i;
        temp_contour.points.clear();
        temp_contour.points.push_back(C);
        temp_contour.points.push_back(A);
        temp_contour.points.push_back(B);
        <B><FONT COLOR="#228B22">const</FONT></B> T area = temp_contour.Get_Signed_Area(); <I><FONT COLOR="#B22222">//Sign will cancel if it is uniformly oriented.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; r_a( temp_contour.Average_Point() );

<I><FONT COLOR="#B22222">//The problem with these is that the result we get is not a signed distance... (I think.)
</FONT></I><I><FONT COLOR="#B22222">//..it is a shame, too, because creating a contour_of_points/populating a list each time is hard on the stack.
</FONT></I><I><FONT COLOR="#B22222">//        const T area = ((A-C).Cross(B-C)).length() * (T)(0.5);  //The area of the triangle ABC.
</FONT></I><I><FONT COLOR="#B22222">//        const T area = std::sqrt(((A-C).Cross(B-C)).Dot( (A-C).Cross(B-C) )) * (T)(0.5);  //The area of the triangle ABC.
</FONT></I>
<I><FONT COLOR="#B22222">//        const T area = std::sqrt(((A).Cross(B)).Dot( (A).Cross(B) )) * (T)(0.5);  //The area of the triangle ABC.
</FONT></I><I><FONT COLOR="#B22222">//        const vec3&lt;T&gt; r_a( (A + B) / (T)(3.0) );               //The center of the triangle.
</FONT></I>
<I><FONT COLOR="#B22222">//FUNCINFO(&quot;The current area is &quot; &lt;&lt; area &lt;&lt; &quot; and the current RA is &quot; &lt;&lt; r_a);
</FONT></I>        Area += area;
        RA += r_a * area;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> RA/Area;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Centroid(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Centroid(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This routine will produce a point which lies somewhere within the region of a contour. It may be outside of the contour
</FONT></I><I><FONT COLOR="#B22222">// for U-shaped contours, and may not lie in the local plane of the contour. It is best used for quick and dirty location
</FONT></I><I><FONT COLOR="#B22222">// of a contour or for checking which side of a plane a spit contour lies on.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec3&lt;T&gt; contour_of_points&lt;T&gt;::First_N_Point_Avg(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>((N &lt;= 0) || (N &gt; static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size()))){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Attempted to average N=&quot;</FONT></B> &lt;&lt; N &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; points. This is not possible. The contour has &quot;</FONT></B> &lt;&lt; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; points&quot;</FONT></B>);
    }
    vec3&lt;T&gt; out;
    <B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin();
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B>(i &lt; N){
        out += *it;
        ++it;
        ++i;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out/static_cast&lt;T&gt;(N);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::First_N_Point_Avg(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::First_N_Point_Avg(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//This routine returns the (positive-or-zero) perimeter of a contour. No attempt it made to ensure the points are in any
</FONT></I><I><FONT COLOR="#B22222">// specific order (or orientation.)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//This routine can handle empty contours and single points (zero perimeter.)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  T contour_of_points&lt;T&gt;::Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    T out = (T)(0);
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt;= 1) <B><FONT COLOR="#A020F0">return</FONT></B> out;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(), it2 = ++(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()); (it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end()) &amp;&amp; (it2 != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end()); ++it, ++it2){
        out += it-&gt;distance(*it2);
    }

    <I><FONT COLOR="#B22222">//Handle the last edge, if it is closed.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed){ out += (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin())-&gt;distance( *(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.rbegin()) ); }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//This routine performs (numerical) contour integration over the contour with the provided (scalar-valued) kernel.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// More precisely, this function computes:  $ \Chi = \sum_{i=1}^{N} \Chi_{i} $ where the summation is over the 
</FONT></I><I><FONT COLOR="#B22222">// straight line segments between contour points, and 
</FONT></I><I><FONT COLOR="#B22222">//  $ \Chi_{i} = \int_{\vec{A_{i}}}^{\vec{B_{i}}}  k( \vec{r}; \vec{A_{i}}, \vec{B_{i}} ) ds $
</FONT></I><I><FONT COLOR="#B22222">// or, equivalently,
</FONT></I><I><FONT COLOR="#B22222">//  $ \Chi_{i} = \int_{0}^{1} k( \vec{r(t)}; \vec{A_{i}}, \vec{B_{i}} ) q_{i} dt $
</FONT></I><I><FONT COLOR="#B22222">// where $ q_{i} \equiv | \vec{B_{i}} - \vec{A_{i}} | \equiv | \vec{U_{i}} |.$
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Most importantly, the kernel cannot depend on any additional parameters over the duration of the integration.
</FONT></I><I><FONT COLOR="#B22222">// The factors passed to the kernel may or may not be used: U is passed in as a convenience, but it is merely B-A.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine is robust with regard to whether or not the contour is closed, and can handle fully-3D 
</FONT></I><I><FONT COLOR="#B22222">// contours.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This is a numerical scheme. The actual integration is the weakest aspect: it should be upgraded ASAP. FIXME.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    T contour_of_points&lt;T&gt;::Integrate_Simple_Scalar_Kernel(std::function&lt;    T    (<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;r,  <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;B, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;U)&gt; k) <B><FONT COLOR="#228B22">const</FONT></B> {
    T out = 0.0;

    <B><FONT COLOR="#A020F0">if</FONT></B>(!k){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;This routine requires a scalar kernel. If no kernel is required, provide a function which always gives 1.0&quot;</FONT></B>);
    }

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p1_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(); p1_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end(); ++p1_it){
        <I><FONT COLOR="#B22222">//Set up the points. Loop point B (point 2) around to the first point if the contour is closed.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> p2_it = p1_it;
        ++p2_it;
        <B><FONT COLOR="#A020F0">if</FONT></B>(p2_it == <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end()){
            <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed == true){
                p2_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin();
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }

        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; A = *p1_it;
        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; B = *p2_it;
        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; U = B - A;
        <I><FONT COLOR="#B22222">//const vec3&lt;T&gt; U_unit = U.unit();
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> T U_length = U.length();

        <I><FONT COLOR="#B22222">//Perform a simple numerical integration.
</FONT></I>        T tot = 0.0;
        <B><FONT COLOR="#228B22">const</FONT></B> T dt = 0.0001;
        <B><FONT COLOR="#A020F0">for</FONT></B>(T t = 0.0; t &lt;= (1.0-dt); t += dt){
            <B><FONT COLOR="#228B22">const</FONT></B> T t0 = t;
            <B><FONT COLOR="#228B22">const</FONT></B> T t1 = t + dt;
            <B><FONT COLOR="#228B22">const</FONT></B> T p0 = k( A + U*t0,   A, B, U);
            <B><FONT COLOR="#228B22">const</FONT></B> T p1 = k( A + U*t1,   A, B, U);
            tot += 0.5*(p0 + p1)*dt;
        }
        out += tot * U_length;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Integrate_Simple_Scalar_Kernel(std::function&lt; <B><FONT COLOR="#228B22">float</FONT></B>  (<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;r,  <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;B, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;U)&gt; k) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Integrate_Simple_Scalar_Kernel(std::function&lt; <B><FONT COLOR="#228B22">double</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;r,  <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;B, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;U)&gt; k) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This routine performs (numerical) contour integration over the contour with the provided (vector-valued) kernel.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// More precisely, this function computes:  $ \Chi = \sum_{i=1}^{N} \Chi_{i} $ where the summation is over the 
</FONT></I><I><FONT COLOR="#B22222">// straight line segments between contour points, and 
</FONT></I><I><FONT COLOR="#B22222">//  $ \Chi_{i} = \int_{\vec{A_{i}}}^{\vec{B_{i}}}  k( \vec{r}; \vec{A_{i}}, \vec{B_{i}} ) d\vec{r} $
</FONT></I><I><FONT COLOR="#B22222">// or, equivalently,
</FONT></I><I><FONT COLOR="#B22222">//  $ \Chi_{i} = \int_{0}^{1} k( \vec{r(t)}; \vec{A_{i}}, \vec{B_{i}} ) \vec{U}_{i} dt $
</FONT></I><I><FONT COLOR="#B22222">// where $ \vec{U_{i}} \equiv \vec{B_{i}} - \vec{A_{i}} .$
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Most importantly, the kernel cannot depend on any additional parameters over the duration of the integration.
</FONT></I><I><FONT COLOR="#B22222">// The factors passed to the kernel may or may not be used: U is passed in as a convenience, but it is merely B-A.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine is robust with regard to whether or not the contour is closed, and can handle fully-3D 
</FONT></I><I><FONT COLOR="#B22222">// contours.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This is a numerical scheme. The actual integration is the weakest aspect: it should be upgraded ASAP. FIXME.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    T contour_of_points&lt;T&gt;::Integrate_Simple_Vector_Kernel(std::function&lt; vec3&lt;T&gt; (<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;r,  <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;B, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;U)&gt; k) <B><FONT COLOR="#228B22">const</FONT></B>{
    T out = 0.0;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!k){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;This routine requires a vector kernel. If no kernel is required, figure out how to provide a static kernel to do what you want.&quot;</FONT></B>);
    }

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p1_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(); p1_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end(); ++p1_it){
        <I><FONT COLOR="#B22222">//Set up the points. Loop point B (point 2) around to the first point if the contour is closed.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> p2_it = p1_it;
        ++p2_it;
        <B><FONT COLOR="#A020F0">if</FONT></B>(p2_it == <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end()){
            <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed == true){
                p2_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin();
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }
        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; A = *p1_it;
        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; B = *p2_it;
        <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; U = B - A;
        <I><FONT COLOR="#B22222">//const vec3&lt;T&gt; U_unit = U.unit();
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> T U_length = U.length();

        <I><FONT COLOR="#B22222">//Perform a simple numerical integration.
</FONT></I>        T tot = 0.0;
        <B><FONT COLOR="#228B22">const</FONT></B> T dt = 0.0001;
        <B><FONT COLOR="#A020F0">for</FONT></B>(T t = 0.0; t &lt;= (1.0-dt); t += dt){
            <B><FONT COLOR="#228B22">const</FONT></B> T t0 = t;
            <B><FONT COLOR="#228B22">const</FONT></B> T t1 = t + dt;
            <B><FONT COLOR="#228B22">const</FONT></B> T p0 = U.Dot( k( A + U*t0,   A, B, U) );
            <B><FONT COLOR="#228B22">const</FONT></B> T p1 = U.Dot( k( A + U*t1,   A, B, U) );
            tot += 0.5*(p0 + p1)*dt;
        }
        out += tot * U_length;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Integrate_Simple_Vector_Kernel(std::function&lt; vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; (<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;r,  <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;B, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;U)&gt; k) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Integrate_Simple_Vector_Kernel(std::function&lt; vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; (<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;r,  <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;B, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;U)&gt; k) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    contour_of_points&lt;T&gt; contour_of_points&lt;T&gt;::Resample_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//First, do some preliminary checks.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt;= 1) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Attempted to perform resampling on a contour with &quot;</FONT></B> &lt;&lt; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; points. Surely this was not intended!&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(N &lt;= 0) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Attempted to perform resampling into &quot;</FONT></B> &lt;&lt; N &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; points. Surely this was not intended!&quot;</FONT></B>);
    
    <I><FONT COLOR="#B22222">//Issue some reasonable warnings. These could be safely removed - we are not losing any info because we are making a copy. Leave it here for testing, though!
</FONT></I><I><FONT COLOR="#B22222">//    if(static_cast&lt;float&gt;(N) &lt; 0.2*static_cast&lt;float&gt;(this-&gt;points.size())){
</FONT></I><I><FONT COLOR="#B22222">//        FUNCWARN(&quot;Resampling into less than 1/5th of the original contour point density. Watch out for contour mangling!&quot;);
</FONT></I><I><FONT COLOR="#B22222">//    }
</FONT></I>
    decltype(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points) newpoints;
    <B><FONT COLOR="#228B22">const</FONT></B> T spacing = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Perimeter() / static_cast&lt;T&gt;(N);
    <B><FONT COLOR="#228B22">const</FONT></B> T zero = (T)(0);
    T offset = (T)(0);
    T remain = (T)(0);

    <B><FONT COLOR="#228B22">auto</FONT></B> itA = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(), itB = ++(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin());
    <B><FONT COLOR="#A020F0">while</FONT></B>(true){
        <B><FONT COLOR="#A020F0">if</FONT></B>(!(itA != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end())){ <I><FONT COLOR="#B22222">//Wrap around will only be required if the contour is closed (not always, though.) itB will be the one to wrap!
</FONT></I>            FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;The first iterator wrapped around. This should not happen, and is likely due to round off. There are &quot;</FONT></B> &lt;&lt; newpoints.size() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;/&quot;</FONT></B> &lt;&lt; N &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; points.&quot;</FONT></B>);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>(!(itB != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end())) itB = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin();

        <B><FONT COLOR="#228B22">const</FONT></B> line_segment&lt;T&gt; line(*itA, *itB);  <I><FONT COLOR="#B22222">//From A to B.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> somepoints = line.Sample_With_Spacing(spacing, offset, remain); <I><FONT COLOR="#B22222">//'remain' is adjusted each time.
</FONT></I>        <I><FONT COLOR="#B22222">//FUNCINFO(&quot;Spacing is &quot; &lt;&lt; spacing &lt;&lt; &quot;, offset is &quot; &lt;&lt; offset &lt;&lt; &quot; and remaining is now &quot; &lt;&lt; remain &lt;&lt; &quot;  . We got &quot; &lt;&lt; somepoints.size() &lt;&lt; &quot; points, and the dl between contour points was &quot; &lt;&lt; itA-&gt;distance(*itB));
</FONT></I>
        offset = (zero - remain);
        remain = zero;
<I><FONT COLOR="#B22222">//        newpoints.splice(newpoints.end(), somepoints);
</FONT></I>        <B><FONT COLOR="#A020F0">while</FONT></B>(!somepoints.empty() &amp;&amp; (static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(newpoints.size()) &lt; N)){
            <B><FONT COLOR="#228B22">auto</FONT></B> it = somepoints.begin();
            newpoints.push_back(*it);
            somepoints.erase(it);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>(static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(newpoints.size()) == N) <B><FONT COLOR="#A020F0">break</FONT></B>;
        ++itA; 
        ++itB;
    }

    contour_of_points&lt;T&gt; out(std::move(newpoints));
    out.closed = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Resample_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Resample_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Scales distance from each point to given point by factor (scale).
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    contour_of_points&lt;T&gt; contour_of_points&lt;T&gt;::Scale_Dist_From_Point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;point, T scale) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(scale &lt; (T)(0.0)){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Passed a negative scaling factor. We cannot compute anything logical with this value. Continuing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> contour_of_points&lt;T&gt;();
    }

    contour_of_points&lt;T&gt; out(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points);
    out.closed = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = out.points.begin(); p_it != out.points.end(); ++p_it){
        *p_it = (*p_it)*scale + point*((T)(1.0) - scale);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Scale_Dist_From_Point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;, <B><FONT COLOR="#228B22">float</FONT></B>  scale) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Scale_Dist_From_Point(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;, <B><FONT COLOR="#228B22">double</FONT></B> scale) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Performs a resampling only if the contour is longer than the resample size.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    contour_of_points&lt;T&gt; contour_of_points&lt;T&gt;::Resample_LTE_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size()) &gt; N){
        <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Resample_Evenly_Along_Perimeter(N);
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        <B><FONT COLOR="#A020F0">return</FONT></B> (*<B><FONT COLOR="#A020F0">this</FONT></B>);
    }
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Resample_LTE_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Resample_LTE_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; contour_of_points&lt;T&gt; &amp;  contour_of_points&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;T&gt; &amp;rhs) {
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B> == &amp;rhs) <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed = rhs.closed;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points = rhs.points;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp; contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This routine attempts to determine equality between contours, ignoring the starting position of the contour. This is a computationally
</FONT></I><I><FONT COLOR="#B22222">// expensive task, so some shortcuts might be taken!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Currently, this routine assumes that contours are either ordered or anti-ordered, meaning that this equality
</FONT></I>    <I><FONT COLOR="#B22222">// *does not* discriminate between contours which are jumbled. Namely, with contours of points A,B,C,D,E,F like
</FONT></I>    <I><FONT COLOR="#B22222">//    C1 = A B C D E,    C2 = A C E D B,   C3 = A B C D E F    , we consider C1 == C2, but C3 != C2 or C1.
</FONT></I>    <I><FONT COLOR="#B22222">// This is done by sorting the points into a jumble in some (poorly-defined) way. To 
</FONT></I>    <I><FONT COLOR="#B22222">// retire this 'feature,' one will need to cycle through each contour until a common point is found, and then
</FONT></I>    <I><FONT COLOR="#B22222">// cycle through the rest of the points (in order!) to see if a true match exists.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">// The current technique was chosen for it's simplicity and because it is believed it will satisfactorially
</FONT></I>    <I><FONT COLOR="#B22222">// work in most situations.                                                                                                           FIXME
</FONT></I>    
    <I><FONT COLOR="#B22222">//Check for basic, quick things to help filter as much as possible.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size()  != in.points.size() ) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.empty() &amp;&amp; in.points.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed != in.closed) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B> == &amp;in) <B><FONT COLOR="#A020F0">return</FONT></B> true;

    <I><FONT COLOR="#B22222">//Now copy and sort the points in a systematic way.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> Apoints = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points;
    <B><FONT COLOR="#228B22">auto</FONT></B> Bpoints = in.points;

<I><FONT COLOR="#B22222">//    auto lambda_lt_sort = [](const vec3&lt;T&gt; &amp;a, const vec3&lt;T&gt; &amp;b) -&gt; bool { return (a &lt; b); };
</FONT></I>    Apoints.sort(); <I><FONT COLOR="#B22222">//lambda_lt_sort);  //Uses a LAME vec3::operator&lt; to sort on vector magnitude!
</FONT></I>    Bpoints.sort(); <I><FONT COLOR="#B22222">//lambda_lt_sort);  // This is most likely very bad
</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> itA = Apoints.begin(), itB = Bpoints.begin(); (itA != Apoints.end()) &amp;&amp; (itB != Bpoints.end()); ++itA, ++itB){
        <B><FONT COLOR="#A020F0">if</FONT></B>((*itA) != (*itB)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> !(*<B><FONT COLOR="#A020F0">this</FONT></B> == in);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Compares the *SIZE* of the contours. Given an equality, the closed curve is always the largest.
</FONT></I>    <I><FONT COLOR="#B22222">//Compares: [number of points]  [whether one is open / other is closed]  [Perimeter] [Centroid (vec3) &lt;]
</FONT></I>
    <I><FONT COLOR="#B22222">//First, compare the number of points.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() != rhs.points.size()) <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt; rhs.points.size());

    <I><FONT COLOR="#B22222">//Open curves are less than closed curves.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed &amp;&amp;  rhs.closed) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed &amp;&amp; !rhs.closed) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <I><FONT COLOR="#B22222">//Finally, a more expensive technique: perimeter.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> perimeterA = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Perimeter();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> perimeterB = rhs.Perimeter();
    <B><FONT COLOR="#A020F0">if</FONT></B>(perimeterA != perimeterB) <B><FONT COLOR="#A020F0">return</FONT></B> (perimeterA &lt; perimeterB);

    <I><FONT COLOR="#B22222">//Finally, delegate the task to elsewhere: rely on the vec3 operator&lt;.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Average_Point() &lt; rhs.Average_Point());
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//This is a contour-to-plane comparison which is performed on a per-point basis.
</FONT></I><I><FONT COLOR="#B22222">// The return value is -1 if contour is below P, 0 if it intersects/crosses it, 1 if it is above.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> contour_of_points&lt;T&gt;::Avoids_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;T&gt; &amp;P) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.empty()) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to determine if contour avoids plane or not - there are no points to compare!&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">bool</FONT></B> above(false), below(false);
    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt;  NN(vec3&lt;T&gt;((T)(0), (T)(0), (T)(0)) - P.N_0); <I><FONT COLOR="#B22222">//Sign reversed normal.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> plane&lt;T&gt; PN(NN, P.R_0); <I><FONT COLOR="#B22222">//Plane with opposite orientation.
</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(); it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end(); ++it){
        <I><FONT COLOR="#B22222">//Update the 'above' and 'below' bools as necessary.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> normal = P.Is_Point_Above_Plane(*it);
        <B><FONT COLOR="#A020F0">if</FONT></B>(normal){
            above = true;
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> mirror = PN.Is_Point_Above_Plane(*it);
            <B><FONT COLOR="#A020F0">if</FONT></B>(mirror){
                below = true;
            }
        }

        <I><FONT COLOR="#B22222">//Check to see if we have found at least one point above and one below. If so, break out early.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(above &amp;&amp; below) <B><FONT COLOR="#A020F0">break</FONT></B>;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>(above &amp;&amp; !below) <B><FONT COLOR="#A020F0">return</FONT></B> 1;   <I><FONT COLOR="#B22222">//Above.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!above &amp;&amp; below) <B><FONT COLOR="#A020F0">return</FONT></B> -1;  <I><FONT COLOR="#B22222">//Below.
</FONT></I>
    <I><FONT COLOR="#B22222">//if((above &amp;&amp; below) || (!above &amp;&amp; !below))  return 0;   //Crosses plane!
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Avoids_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;P) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Avoids_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;P) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;T&gt;::Remove_Sequential_Duplicate_Points(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;)&gt; Feq){
    <B><FONT COLOR="#A020F0">if</FONT></B>(!Feq) Feq = [](<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;B) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> A == B; };

    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt;= 3) <B><FONT COLOR="#A020F0">return</FONT></B>; <I><FONT COLOR="#B22222">//Not willing to possibly produce a 2-point contour!
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> p1_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed ? --(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end())  :    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin();
    <B><FONT COLOR="#228B22">auto</FONT></B> p2_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed ?    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin() : ++(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin());
    <B><FONT COLOR="#A020F0">while</FONT></B>(p2_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end()){
        <B><FONT COLOR="#A020F0">if</FONT></B>( Feq(*p1_it,*p2_it) ){
            <I><FONT COLOR="#B22222">//Remove the duplicate point.
</FONT></I>            p2_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.erase(p2_it);
            <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt;= 3) <B><FONT COLOR="#A020F0">return</FONT></B>; <I><FONT COLOR="#B22222">//Not willing to possibly produce a 2-point contour!
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            p1_it = p2_it;
            ++p2_it;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Remove_Sequential_Duplicate_Points(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;)&gt; Feq);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Remove_Sequential_Duplicate_Points(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;)&gt; Feq);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>



<I><FONT COLOR="#B22222">//Performs (recursive, if needed) needle removal. In other words, turns
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//                            B        C
</FONT></I><I><FONT COLOR="#B22222">//                   |--&lt;--&gt;--o--&lt;--&gt;--o
</FONT></I><I><FONT COLOR="#B22222">//                   |
</FONT></I><I><FONT COLOR="#B22222">//     ...--&gt;--o--&gt;--o--&gt;--o--&gt;--...         into       ...--&gt;--o--&gt;--o--&gt;--o--&gt;--...
</FONT></I><I><FONT COLOR="#B22222">//             X     A     Y                                    X     A     Y
</FONT></I><I><FONT COLOR="#B22222">//                 
</FONT></I><I><FONT COLOR="#B22222">// by eliminating the spurious, zero-area A--B--C--B--A path. These can occur when doing 
</FONT></I><I><FONT COLOR="#B22222">// boolean operations, merging adjoining contours, etc..
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;T&gt;::Remove_Needles(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;)&gt; Feq){
    <B><FONT COLOR="#A020F0">if</FONT></B>(!Feq) Feq = [](<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;B) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> A == B; };

    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt;= 3) <B><FONT COLOR="#A020F0">return</FONT></B>; <I><FONT COLOR="#B22222">//Not willing to possibly produce a 1-point contour!
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> p1_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed ? --(--(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end())) : <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin();
    <B><FONT COLOR="#228B22">auto</FONT></B> p2_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed ? <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()       : ++(++(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()));

    <B><FONT COLOR="#A020F0">while</FONT></B>(p2_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end()){
        <I><FONT COLOR="#B22222">//Find the point in between p1 and p2.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> mdl_it = std::next(p1_it);
        <B><FONT COLOR="#A020F0">if</FONT></B>(!(mdl_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end())) mdl_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin();

        <B><FONT COLOR="#A020F0">if</FONT></B>( Feq(*p1_it,*p2_it) ){
            <I><FONT COLOR="#B22222">//This is a needle, according to the user's criteria.
</FONT></I>            <I><FONT COLOR="#B22222">// Remove the point in between p1 and p2 and also p2, iterating p2.
</FONT></I>            <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.erase( mdl_it );
            p2_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.erase(p2_it);
    
            <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt;= 3) <B><FONT COLOR="#A020F0">return</FONT></B>; <I><FONT COLOR="#B22222">//Not willing to possibly produce a 1-point contour!
</FONT></I>
            <I><FONT COLOR="#B22222">//At this point, p1 and p2 are sequential (ie. there is no seperating point).
</FONT></I>            <I><FONT COLOR="#B22222">// Move p1 one step back. This helps us deal with long needles more efficiently.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(!(p1_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin())){
                p1_it = --(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end());
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                --p1_it;
            }

            <I><FONT COLOR="#B22222">//break;
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            ++p2_it;
            p1_it = mdl_it;
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Remove_Needles(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;)&gt; Feq);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Remove_Needles(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;)&gt; Feq);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Removes points which can be safely removed such that the shape of the contour is not altered.
</FONT></I><I><FONT COLOR="#B22222">// These can occur when resampling long lines, merging contours from cartesian grids, or 
</FONT></I><I><FONT COLOR="#B22222">// directly from input (which often is aligned with some regularity. 
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;T&gt;::Remove_Extraneous_Points(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;)&gt; Feq){
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt;= 3) <B><FONT COLOR="#A020F0">return</FONT></B>; <I><FONT COLOR="#B22222">//Not willing to possibly produce a 1-point contour!
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!Feq) Feq = [](<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;B) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> A == B; };

    <B><FONT COLOR="#228B22">auto</FONT></B> p1_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed ? --(--(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end())) : <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin();
    <B><FONT COLOR="#228B22">auto</FONT></B> p2_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed ? <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()       : ++(++(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin()));
    <B><FONT COLOR="#A020F0">for</FONT></B>(  ; p2_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end(); ++p2_it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt;= 3) <B><FONT COLOR="#A020F0">return</FONT></B>; <I><FONT COLOR="#B22222">//Not willing to possibly produce a 1-point contour!
</FONT></I>
        <I><FONT COLOR="#B22222">//Find the point in between p1 and p2.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> mdl_it = std::next(p1_it);
        <B><FONT COLOR="#A020F0">if</FONT></B>(!(mdl_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end())) mdl_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin();

        <B><FONT COLOR="#228B22">const</FONT></B> line&lt;T&gt; p1p2(*p1_it,*p2_it);
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dist = p1p2.Distance_To_Point(*mdl_it);
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORABS(dist) == (T)(0.0)){
            <I><FONT COLOR="#B22222">//Remove the extraneous point between p1 and p2. Keep p1 the same.
</FONT></I>            <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.erase( mdl_it );
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <I><FONT COLOR="#B22222">//Keep the point - it is needed for the contour shape. Iterate p1.
</FONT></I>            p1_it = mdl_it;
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Remove_Extraneous_Points(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;)&gt; Feq);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Remove_Extraneous_Points(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;)&gt; Feq);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//This routine produces a very simple, default plot of the data. If more customization is required, you'll have to look elsewhere!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;T&gt;::Plot(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    Plotter a_plot;
    a_plot.ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;# Default, simple plot for Contour of points: &quot;</FONT></B> &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> iter = (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.begin(); iter != (*<B><FONT COLOR="#A020F0">this</FONT></B>).points.end(); ++iter){
        a_plot.ss &lt;&lt; (*iter).x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        a_plot.ss &lt;&lt; (*iter).y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        <I><FONT COLOR="#B22222">//a_plot.ss &lt;&lt; (*iter).z &lt;&lt; &quot; &quot;;
</FONT></I>        a_plot.ss &lt;&lt; std::endl;
    }
    a_plot.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Plot(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Plot(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::string contour_of_points&lt;T&gt;::write_to_string(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream out;
    <I><FONT COLOR="#B22222">//There IS significant spaces in this representation.
</FONT></I>    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;{ contour &quot;</FONT></B>;
    out &lt;&lt; (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed ? <B><FONT COLOR="#BC8F8F">&quot;closed &quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;open &quot;</FONT></B>);
    out &lt;&lt; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.size() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; 
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.begin(); it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.end(); ++it){
        out &lt;&lt; *it &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; 
    }
    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; }&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">return</FONT></B> out.str();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::string contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::write_to_string(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::string contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::write_to_string(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Returns true if it worked/was loaded into the contour, false otherwise.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;T&gt;::load_from_string(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#A020F0">if</FONT></B>(in.size() &lt; 19) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//Not enough characters to possibly hold a contour.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(in.find(<B><FONT COLOR="#BC8F8F">' '</FONT></B>) == std::string::npos) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//All whitespace has been stripped. We cannot parse it now.
</FONT></I>
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ins(in);
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string grbg;
    ins &gt;&gt; grbg &gt;&gt; grbg; <I><FONT COLOR="#B22222">// &quot;{&quot; and &quot;contour&quot;
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(grbg != <B><FONT COLOR="#BC8F8F">&quot;contour&quot;</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    ins &gt;&gt; grbg; <I><FONT COLOR="#B22222">// &quot;closed&quot; or &quot;open&quot;
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>((grbg != <B><FONT COLOR="#BC8F8F">&quot;closed&quot;</FONT></B>) &amp;&amp; (grbg != <B><FONT COLOR="#BC8F8F">&quot;open&quot;</FONT></B>)) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <I><FONT COLOR="#B22222">//Here we can be reasonably certain it (looks) like a contour.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.clear();
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;closed = (grbg == <B><FONT COLOR="#BC8F8F">&quot;closed&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N;
    ins &gt;&gt; N;
    <B><FONT COLOR="#A020F0">if</FONT></B>(N &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    vec3&lt;T&gt; p;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; ++i){
        ins &gt;&gt; p;
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;points.push_back(p);
    }
    ins &gt;&gt; grbg; <I><FONT COLOR="#B22222">// final &quot;}&quot;
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(grbg != <B><FONT COLOR="#BC8F8F">&quot;}&quot;</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::load_from_string(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::load_from_string(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------- contour_collection: a collection of logically-related contour_of_points  ---------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    contour_collection&lt;T&gt;::contour_collection(){ }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::contour_collection(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::contour_collection(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    contour_collection&lt;T&gt;::contour_collection(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;T&gt; &amp;in) : contours(in.contours) { }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::contour_collection(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;in);
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::contour_collection(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>        

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    contour_collection&lt;T&gt;::contour_collection(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;contour_of_points&lt;T&gt;&gt; &amp;in) : contours(in) { }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::contour_collection(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;&gt; &amp;in);
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::contour_collection(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Member functions.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  T contour_collection&lt;T&gt;::Get_Signed_Area(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//NOTE: ALL contours must be closed. See the implementation in contour_of_points.
</FONT></I>    T Area = (T)(0);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        Area += c_it-&gt;Get_Signed_Area();
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> Area; <I><FONT COLOR="#B22222">//NOTE: Do NOT take the absolute value. We want to keep the sign for adding/subtracting/etc.. contour areas!
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Get_Signed_Area(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Get_Signed_Area(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//This routine verifies that all contours are counter clockwise. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: No effort is made to ensure the ordering of points or contours is sane (how could we?)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;T&gt;::Is_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//First, we compute the (signed) area. If the sign is positive, then the contour is counter-clockwise oriented.
</FONT></I>    <I><FONT COLOR="#B22222">// Otherwise, it is of zero area or is clockwise.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(!c_it-&gt;Is_Counter_Clockwise()) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Is_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Is_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//This routine will cycle through each contour and reorient to be CCW (if required.)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;T&gt;::Reorient_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(!c_it-&gt;Is_Counter_Clockwise()) c_it-&gt;Reorient_Counter_Clockwise();
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Reorient_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Reorient_Counter_Clockwise(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>





<I><FONT COLOR="#B22222">//This function sums all the points of all contours and divides by the total number of points, giving the 'average' point. 
</FONT></I><I><FONT COLOR="#B22222">// This value has limited use becaue it depends on the density of points in the contour. It is not a true center of volume
</FONT></I><I><FONT COLOR="#B22222">// for this reason.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec3&lt;T&gt; contour_collection&lt;T&gt;::Average_Point(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    vec3&lt;T&gt; out((T)(0), (T)(0), (T)(0));
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = c_it-&gt;points.begin(); p_it != c_it-&gt;points.end(); ++p_it){
            out += (*p_it);
            ++N;
        }
    }
    out /= static_cast&lt;T&gt;(N);
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Average_Point(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Average_Point(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This function returns the 'average pointed weighted by the area enclosed by the contours.' In other words, this returns the 
</FONT></I><I><FONT COLOR="#B22222">// center of mass of the contours as if they were filled with a homogeneous medium with a planar mass density. See the 
</FONT></I><I><FONT COLOR="#B22222">// contour_of_points implementation to learn more.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Each contour in the collection is assumed to be oriented as the user desires. Mixing orientation is not advised,
</FONT></I><I><FONT COLOR="#B22222">// as it will (probably) shift the computed centroid!
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This is NOT the average of the contour centroids, but attempts to legitimately weight each centroid by the area in the
</FONT></I><I><FONT COLOR="#B22222">// given contour. This may or may not be a validcentroid, but it is certainly NOT the straight averaging of centroids! 
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec3&lt;T&gt; contour_collection&lt;T&gt;::Centroid(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    T Area = (T)(0);   
    vec3&lt;T&gt; RA((T)(0), (T)(0), (T)(0));
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> area = c_it-&gt;Get_Signed_Area();
        Area += area;
        RA   += (c_it-&gt;Centroid())*area;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> RA/Area;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Centroid(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Centroid(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This routine returns a point which should be contained within the boundary of one of the contours in the collection.
</FONT></I><I><FONT COLOR="#B22222">// The point can be OUTSIDE the contour if it is U-shaped. This point is NOT an overall average point or centroid.
</FONT></I><I><FONT COLOR="#B22222">// It is useful when dealing with planes for determining if above or below. No split-on-a-plane contours should have
</FONT></I><I><FONT COLOR="#B22222">// a U-shape on the edge of the boundary.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Uses first N contours with first M points from each. Decent defaults are: N = 1 and M = 3. 
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; vec3&lt;T&gt; contour_collection&lt;T&gt;::Generic_Avg_Boundary_Point(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> M) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>((N &lt;= 0) || (N &gt; static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.size()))){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Attempted to average N=&quot;</FONT></B> &lt;&lt; N &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; contours. This is not possible. The collection has &quot;</FONT></B> &lt;&lt; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.size() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; contours&quot;</FONT></B>);
    }
    vec3&lt;T&gt; out;
    <B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin();
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B>(i &lt; N){
        out += it-&gt;First_N_Point_Avg(M);
        ++it;
        ++i;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out/static_cast&lt;T&gt;(N);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Generic_Avg_Boundary_Point(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> M) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Generic_Avg_Boundary_Point(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> M) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//This routine returns the (positive-or-zero) total perimeter of the contours. No attempt it made to ensure the 
</FONT></I><I><FONT COLOR="#B22222">// points are in any specific order (or orientation.) Overall orientation doesn't matter, because we always sum
</FONT></I><I><FONT COLOR="#B22222">// the (positive) distance from point to point, regardless of direction/phase.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  T contour_collection&lt;T&gt;::Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    T out = (T)(0);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        out += c_it-&gt;Perimeter();
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Simple average of the perimeters of individual contours.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  T contour_collection&lt;T&gt;::Average_Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> N = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.size();
    <B><FONT COLOR="#A020F0">if</FONT></B>(N == 0) <B><FONT COLOR="#A020F0">return</FONT></B> (T)(0);
    <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Perimeter()/static_cast&lt;T&gt;(N));
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Average_Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Average_Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  T contour_collection&lt;T&gt;::Longest_Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    T longest = (T)(0);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> perim = c_it-&gt;Perimeter();
        <B><FONT COLOR="#A020F0">if</FONT></B>(perim &gt; longest) longest = perim;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> longest;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Longest_Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Longest_Perimeter(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::list&lt;contour_collection&lt;T&gt;&gt; contour_collection&lt;T&gt;::Split_Along_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;T&gt; &amp;theplane) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//There will be two (or one) collections here. Which piece goes where is tricky to do in general.
</FONT></I>    <I><FONT COLOR="#B22222">// Those contours with an average point below the plane (ie. have negative signed distance) are first. 
</FONT></I>    <I><FONT COLOR="#B22222">// Those above (ie. have positive signed distance) are second.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_collection&lt;T&gt;&gt; out;
    out.push_back(contour_collection&lt;T&gt;()); <I><FONT COLOR="#B22222">//Below.
</FONT></I>    out.push_back(contour_collection&lt;T&gt;()); <I><FONT COLOR="#B22222">//Above.
</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        <B><FONT COLOR="#228B22">auto</FONT></B> split_cs = c_it-&gt;Split_Along_Plane(theplane);
        <B><FONT COLOR="#A020F0">if</FONT></B>(split_cs.empty()) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;No contours returned from splitting. We should have one or more&quot;</FONT></B>);

        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> sc_it = split_cs.begin(); sc_it != split_cs.end(); ){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Rave = sc_it-&gt;Average_Point();
            <B><FONT COLOR="#A020F0">if</FONT></B>(!theplane.Is_Point_Above_Plane(Rave)){
                out.front().contours.push_back(*sc_it);
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                out.back().contours.push_back(*sc_it);
            }
            sc_it = split_cs.erase(sc_it);
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Split_Along_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;theplane) <B><FONT COLOR="#228B22">const</FONT></B>;
<B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;&gt; contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Split_Along_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;theplane) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::list&lt;contour_collection&lt;T&gt;&gt; contour_collection&lt;T&gt;::Split_Against_Ray(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;thenormal) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//There will be two (or one) collections here. Which piece goes where is tricky to do in general, but should be fairly easy to 
</FONT></I>    <I><FONT COLOR="#B22222">// figure out in most problem domains. Therefore, let the user figure out which part they want. 
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: We make no guarantee about the order of the returned contour_collections.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_collection&lt;T&gt;&gt; out;
    out.push_back(contour_collection&lt;T&gt;());
    out.push_back(contour_collection&lt;T&gt;());
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        <B><FONT COLOR="#228B22">auto</FONT></B> split_cs = c_it-&gt;Split_Against_Ray(thenormal);
        <B><FONT COLOR="#A020F0">if</FONT></B>(split_cs.empty()) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;No contours returned from splitting. We should have either one or two&quot;</FONT></B>);
        out.front().contours.push_back(split_cs.front());    
        split_cs.erase(split_cs.begin());      

        <B><FONT COLOR="#A020F0">if</FONT></B>(split_cs.empty()) <B><FONT COLOR="#A020F0">continue</FONT></B>; <I><FONT COLOR="#B22222">//This is OK - it means the splitting plane missed this contour.
</FONT></I>        out.back().contours.push_back(split_cs.front());
        split_cs.erase(split_cs.begin());

        <B><FONT COLOR="#A020F0">if</FONT></B>(!split_cs.empty()) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Contour was split into more than 2 parts on a plane. This is not possible&quot;</FONT></B>);
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Split_Against_Ray(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;thenormal) <B><FONT COLOR="#228B22">const</FONT></B>;
<B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;&gt; contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Split_Against_Ray(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;thenormal) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Splits contour into an inner (core) and outer (peel) using the cc centroid.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Only use this routine on simple, ~spherical/round contours. No ray-casting is performed, so it will not gracefully handle
</FONT></I><I><FONT COLOR="#B22222">// large dips or folds (unless a very small core is desired).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine always creates TWO output ccs. The core is always first. One or more may be empty, so make sure to check!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::list&lt;contour_collection&lt;T&gt;&gt; contour_collection&lt;T&gt;::Split_Into_Core_Peel_Spherical(T frac_dist) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;contour_collection&gt; output;
    <B><FONT COLOR="#A020F0">if</FONT></B>(frac_dist &lt; (T)(0.0)){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Passed a negative scale factor. This is nonsensical and nothing reasonable can be computed. Continuing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> std::move(output);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(frac_dist &gt; (T)(1.0)){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Passed a scale factor &gt; 1.0. This case is not handled and would produce a core larger than peel! Continuing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> std::move(output);
    }

    <I><FONT COLOR="#B22222">//Prepare space for the inner and outer data.
</FONT></I>    output.push_back(contour_collection&lt;T&gt;()); <I><FONT COLOR="#B22222">//inner (core).
</FONT></I>    output.push_back(contour_collection&lt;T&gt;()); <I><FONT COLOR="#B22222">//outer (peel).
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> C = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Centroid();
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        <B><FONT COLOR="#228B22">auto</FONT></B> c_list = c_it-&gt;Split_Into_Core_Peel_Spherical(C, frac_dist);
        <B><FONT COLOR="#A020F0">if</FONT></B>(!(c_list.back().points.empty()))  output.back().contours.push_back(std::move(c_list.back()));
        <B><FONT COLOR="#A020F0">if</FONT></B>(!(c_list.front().points.empty())) output.front().contours.push_back(std::move(c_list.front()));
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> output;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;&gt; contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Split_Into_Core_Peel_Spherical(<B><FONT COLOR="#228B22">float</FONT></B>  frac_dist) <B><FONT COLOR="#228B22">const</FONT></B>;
<B><FONT COLOR="#228B22">template</FONT></B> std::list&lt;contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Split_Into_Core_Peel_Spherical(<B><FONT COLOR="#228B22">double</FONT></B> frac_dist) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; contour_collection&lt;T&gt; &amp;  contour_collection&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;T&gt; &amp;rhs){
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B> == &amp;rhs) <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours = rhs.contours;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp; contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp; contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This routine attempts to determine equality between a collection of contours, ignoring the starting position of each contour.
</FONT></I><I><FONT COLOR="#B22222">// This is a computationally expensive task, so some shortcuts might be taken! See the contour_of_points operator== for more
</FONT></I><I><FONT COLOR="#B22222">// info.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine will NOT ignore unsorted contours. This means if the nth contour of the input does not match the nth
</FONT></I><I><FONT COLOR="#B22222">// input of the local contours, then they are NOT considered equal!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//First, check the obvious things.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.size() != in.contours.size()) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <I><FONT COLOR="#B22222">//Now walk through the data and compare piecewise.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> itA = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(), itB = in.contours.begin(); (itA != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end()) &amp;&amp; (itB != in.contours.end()); ++itA, ++itB){
        <B><FONT COLOR="#A020F0">if</FONT></B>((*itA) != (*itB)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;T&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> !(*<B><FONT COLOR="#A020F0">this</FONT></B> == in);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;T&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Compares the number of the contours, and then compares ONLY the first contour. 
</FONT></I>    <I><FONT COLOR="#B22222">//                                                           NOTE TO SELF: Would it be at all advantageous to sort the 
</FONT></I>    <I><FONT COLOR="#B22222">//                                                           contours prior to comparing the first two? Will it ever matter??
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.size() != rhs.contours.size()) <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.size() &lt; rhs.contours.size());
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> itA = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(), itB = rhs.contours.begin();
    <B><FONT COLOR="#A020F0">return</FONT></B> ((*itA) &lt; (*itB));
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    contour_collection&lt;T&gt; contour_collection&lt;T&gt;::Resample_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B> {
    contour_collection&lt;T&gt; out;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        out.contours.push_back( c_it-&gt;Resample_Evenly_Along_Perimeter(N) );
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Resample_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Resample_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Performs a resampling only if the contour is longer than the resample size.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    contour_collection&lt;T&gt; contour_collection&lt;T&gt;::Resample_LTE_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B> {
    contour_collection&lt;T&gt; out;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        out.contours.push_back( c_it-&gt;Resample_LTE_Evenly_Along_Perimeter(N) );
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Resample_LTE_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Resample_LTE_Evenly_Along_Perimeter(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This is a contour-to-plane comparison which is performed on a per-point basis.
</FONT></I><I><FONT COLOR="#B22222">// The return value is -1 if contour is below P, 0 if it intersects/crosses it, 1 if it is above.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> contour_collection&lt;T&gt;::Avoids_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;T&gt; &amp;P) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.empty()) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to determine if contour collection avoids plane or not - there are no points to compare!&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">bool</FONT></B> above(false), below(false);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++it){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> avoids = it-&gt;Avoids_Plane(P);
        <B><FONT COLOR="#A020F0">if</FONT></B>(avoids == -1) below = true;
        <B><FONT COLOR="#A020F0">if</FONT></B>(avoids ==  1) above = true;

        <B><FONT COLOR="#A020F0">if</FONT></B>(above &amp;&amp; below) <B><FONT COLOR="#A020F0">break</FONT></B>;  <I><FONT COLOR="#B22222">//Crosses plane. Break early.
</FONT></I>    }

    <B><FONT COLOR="#A020F0">if</FONT></B>(above &amp;&amp; !below) <B><FONT COLOR="#A020F0">return</FONT></B>  1; <I><FONT COLOR="#B22222">//Above.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!above &amp;&amp; below) <B><FONT COLOR="#A020F0">return</FONT></B> -1; <I><FONT COLOR="#B22222">//Below.
</FONT></I>    <I><FONT COLOR="#B22222">//if((above &amp;&amp; below) || (!above &amp;&amp; !below))  return 0;   //Crosses plane!
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Avoids_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;P) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Avoids_Plane(<B><FONT COLOR="#228B22">const</FONT></B> plane&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;P) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Given a notion of 'closeness' between points (ie. probably just A==B, but maybe something more exotic)
</FONT></I><I><FONT COLOR="#B22222">// we try to merge contours which have (at least) two sequential points in opposing orientations.
</FONT></I><I><FONT COLOR="#B22222">//    o--&gt;---o        o--&gt;---o         o------&gt;------o        o------&gt;------o        o------&gt;------o
</FONT></I><I><FONT COLOR="#B22222">//    |      |        |      |         |             |        |             |        |             |
</FONT></I><I><FONT COLOR="#B22222">//    o-&gt;--&lt;-o  ===&gt;  o      o   AND   o-&lt;--&gt;--o-&lt;-&gt;-o  ===&gt;  o       o-&lt;-&gt;-o  ===&gt;  o             o
</FONT></I><I><FONT COLOR="#B22222">//    |      |        |      |         |             |        |             |        |             |
</FONT></I><I><FONT COLOR="#B22222">//    o--&lt;---o        o--&lt;---o         o------&lt;------o        o------&lt;------o        o------&lt;------o
</FONT></I><I><FONT COLOR="#B22222">// Contours which adjoin themselves are *NOT* merged by this routine. A separate routine should be written
</FONT></I><I><FONT COLOR="#B22222">// if/when this is needed (but be careful because it is easy to end up with total islands in this case!).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Note: In the diagram above on the right, you can see how multiple adjoins (&quot;needles&quot;) are handled.
</FONT></I><I><FONT COLOR="#B22222">// Sometimes unnecessary points will remain in the contours. The user is suggested to use the appropriate
</FONT></I><I><FONT COLOR="#B22222">// routine (unnecessary_point_removal, resampling, etc..) AFTER all merging has been completed. It is 
</FONT></I><I><FONT COLOR="#B22222">// important to do so AFTER because this routine depends on points on separate contours exactly overlapping.
</FONT></I><I><FONT COLOR="#B22222">// Removing some seemingly unnecessary points could inhibit further merging!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;T&gt;::Merge_Adjoining_Contours(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;)&gt; Feq){
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.size() &lt; 2) <B><FONT COLOR="#A020F0">return</FONT></B>; <I><FONT COLOR="#B22222">//Nothing to do.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!Feq) Feq = [](<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; &amp;B) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> A == B; };

    <B><FONT COLOR="#228B22">bool</FONT></B> Altered = true;
    <B><FONT COLOR="#A020F0">while</FONT></B>(Altered == true){ <I><FONT COLOR="#B22222">//Keep iterating until nothing happens. We can probably get rid of this with a smarter looping strategy...
</FONT></I>        Altered = false;
    
        <B><FONT COLOR="#228B22">auto</FONT></B> c1_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin();
        <B><FONT COLOR="#A020F0">while</FONT></B>(c1_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end()){
            <B><FONT COLOR="#A020F0">if</FONT></B>(c1_it-&gt;points.size() &lt;= 2){
                ++c1_it;
                <B><FONT COLOR="#A020F0">continue</FONT></B>;
            }
            <B><FONT COLOR="#228B22">auto</FONT></B> c2_it = std::next(c1_it);
    
            <B><FONT COLOR="#5F9EA0">continue_cycling_through</FONT></B>:         <I><FONT COLOR="#B22222">//  &lt;-------------------- NOTE!
</FONT></I>            <B><FONT COLOR="#A020F0">while</FONT></B>(c2_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end()){
                <B><FONT COLOR="#A020F0">if</FONT></B>(c2_it-&gt;points.size() &lt;= 2){
                    ++c2_it;
                    <B><FONT COLOR="#A020F0">continue</FONT></B>;
                }
    
                <I><FONT COLOR="#B22222">//Cycle through the points of c1 forward and that of c2 backward looking for matches.
</FONT></I>                <B><FONT COLOR="#228B22">auto</FONT></B> p11_it = c1_it-&gt;closed ? --(c1_it-&gt;points.end()) :    c1_it-&gt;points.begin();
                <B><FONT COLOR="#228B22">auto</FONT></B> p12_it = c1_it-&gt;closed ?   c1_it-&gt;points.begin() : ++(c1_it-&gt;points.begin());
                <B><FONT COLOR="#A020F0">while</FONT></B>(p12_it != c1_it-&gt;points.end()){
                    <B><FONT COLOR="#228B22">auto</FONT></B> p21_it = c2_it-&gt;closed ? --(c2_it-&gt;points.end()) :    c2_it-&gt;points.begin();
                    <B><FONT COLOR="#228B22">auto</FONT></B> p22_it = c2_it-&gt;closed ?   c2_it-&gt;points.begin() : ++(c2_it-&gt;points.begin());
                    <B><FONT COLOR="#A020F0">while</FONT></B>(p22_it != c2_it-&gt;points.end()){
                        <B><FONT COLOR="#A020F0">if</FONT></B>( Feq(*p11_it,*p22_it) &amp;&amp; Feq(*p12_it,*p21_it) ){
                            <I><FONT COLOR="#B22222">//The contours adjoin, acording to the user's criteria.
</FONT></I>                            Altered = true;
    
                            <I><FONT COLOR="#B22222">//Rotate c2 so that p22_it is the first point in the list.
</FONT></I>                            <B><FONT COLOR="#A020F0">if</FONT></B>(!c2_it-&gt;closed) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;This routine cannot merge when c2 is not closed. You'll need to figure out how to if this is needed!&quot;</FONT></B>);
                            <I><FONT COLOR="#B22222">//     NOTE: Probably the easiest way is to split the contour into two pieces and perform the merge on each separately. 
</FONT></I>                            <I><FONT COLOR="#B22222">//     In the general case, this merging could produce some nasty resulting contours! Good luck.
</FONT></I>                            <B><FONT COLOR="#5F9EA0">std</FONT></B>::rotate(c2_it-&gt;points.begin(), p22_it, c2_it-&gt;points.end());
    
                            <I><FONT COLOR="#B22222">//Remove the duplicate points from c2.
</FONT></I>                            c2_it-&gt;points.erase( c2_it-&gt;points.begin() );
                            c2_it-&gt;points.erase( --(c2_it-&gt;points.end()) );
    
                            <I><FONT COLOR="#B22222">//Insert the points from c2 into c1 after p11_it/before p12_it.
</FONT></I>                            c1_it-&gt;points.splice( p12_it, std::move(c2_it-&gt;points) );

                            <I><FONT COLOR="#B22222">//NOTE: It may be OK to uncomment the following line. I'm worried that it may eliminate
</FONT></I>                            <I><FONT COLOR="#B22222">// necessary points for further merging. The benefit would be (I think) increased speed.
</FONT></I>                            <I><FONT COLOR="#B22222">// Brief testing on cartesian 2D-gridded contours indicated that it seemed to work.
</FONT></I>                            <I><FONT COLOR="#B22222">// Probably better to leave it the safe way. Speed-up was not drastic...
</FONT></I>                            <I><FONT COLOR="#B22222">//c1_it-&gt;Remove_Needles(Feq);
</FONT></I>
                            <I><FONT COLOR="#B22222">//Erase c2. c1 will remain valid because it is != c2.
</FONT></I>                            c2_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.erase(c2_it);
    
                            <I><FONT COLOR="#B22222">//Jump out of the point loops because the iterators for c2 are now invalid. 
</FONT></I>                            <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">continue_cycling_through</FONT></B>;  <I><FONT COLOR="#B22222">//  &lt;-------------------- NOTE!
</FONT></I>                        }
                        p21_it = p22_it;
                        ++p22_it;
                    }
                    p11_it = p12_it;
                    ++p12_it;
                }
                ++c2_it;
            }
            ++c1_it;
        }
    }

    <I><FONT COLOR="#B22222">//Remove this if enabling the above needle-removal.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        c_it-&gt;Remove_Needles(Feq);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Merge_Adjoining_Contours(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;)&gt; Feq);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Merge_Adjoining_Contours(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;,<B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;)&gt; Feq);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Tries to find a rudimentary surface from the contour data. If points are sep. by &gt; min_dist, they are considered not coupled.
</FONT></I><I><FONT COLOR="#B22222">// There is zero guarantee that this procedure will use all available points (in fact, it most likely will not). 
</FONT></I><I><FONT COLOR="#B22222">// The data is stored as: &lt;three vec3's holding triangle vertices&gt; &lt;one vec3 normal&gt;
</FONT></I><I><FONT COLOR="#B22222">//Note: Do NOT use this routine on data with wildly varying sampling rates.
</FONT></I><I><FONT COLOR="#B22222">//Note: Do NOT use this routine on data with wildly varying contour separation.
</FONT></I><I><FONT COLOR="#B22222">//Note: This routine only &quot;works&quot; for contours in xy plane.
</FONT></I><I><FONT COLOR="#B22222">//Note: Do NOT use this routine on disjoint contour sets (ie. has islands).
</FONT></I><I><FONT COLOR="#B22222">//Note: This routine assumes that all contours are closed.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::vector&lt;vec3&lt;T&gt;&gt; contour_collection&lt;T&gt;::Generate_Basic_Surface(T min_dist) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;vec3&lt;T&gt;&gt; out;
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.size() &lt;= 2){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempted to perform basic surface reconstruction on data with too few contours (&lt;=2). Continuing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
    }

    <I><FONT COLOR="#B22222">//First, sort the data into distinct heights along z.
</FONT></I>    <B><FONT COLOR="#228B22">typedef</FONT></B> typename std::list&lt;contour_of_points&lt;T&gt;&gt;::const_iterator  height_to_c_it_t;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;T,height_to_c_it_t&gt; slices;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> z = (c_it-&gt;First_N_Point_Avg(3)).Dot( vec3&lt;T&gt;((T)(0),(T)(0),(T)(1)) );
        <B><FONT COLOR="#A020F0">if</FONT></B>(slices.find(z) != slices.end()){
            FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempting to perform basic surface reconstruction on data which contains disjoint islands. Ignoring smallest contour at this height and continuing.&quot;</FONT></B>);
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> A1 = c_it-&gt;Get_Signed_Area();
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> A2 = slices[z]-&gt;Get_Signed_Area();
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORABS(A1) &gt; YGORABS(A2)){
                slices[z] = c_it;
            }
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            slices[z] = c_it;
        }
    }

    <I><FONT COLOR="#B22222">//Now, stepping over the contours from the bottom to the top (or vice versa) we step over the points
</FONT></I>    <I><FONT COLOR="#B22222">// one by one and find nearest neighbours.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> s1_it = slices.begin();
    <B><FONT COLOR="#228B22">auto</FONT></B> s2_it = ++(slices.begin());
    vec3&lt;T&gt; Last_N2, Last_N1;

    <B><FONT COLOR="#A020F0">while</FONT></B>(s2_it != slices.end()){
        <I><FONT COLOR="#B22222">//p0_it is point on slice 1.
</FONT></I>        <I><FONT COLOR="#B22222">//p1_it is point immediately after p0_it on slice 1.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> p0_it = --(s1_it-&gt;second-&gt;points.end());  
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p1_it = s1_it-&gt;second-&gt;points.begin(); p1_it != s1_it-&gt;second-&gt;points.end(); ++p1_it){

            <I><FONT COLOR="#B22222">//Find the two (distinct) nearest points [in the second contour].
</FONT></I>            <B><FONT COLOR="#228B22">auto</FONT></B> N1 = s2_it-&gt;second-&gt;points.begin(); <I><FONT COLOR="#B22222">//Nearest.
</FONT></I>            <B><FONT COLOR="#228B22">auto</FONT></B> N2 = s2_it-&gt;second-&gt;points.begin(); <I><FONT COLOR="#B22222">//Second-nearest. (penultimate nearest).
</FONT></I>            T dist_N1(1E50), dist_N2(1E60);
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p2_it = s2_it-&gt;second-&gt;points.begin(); p2_it != s2_it-&gt;second-&gt;points.end(); ++p2_it){
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dist = ((*p0_it + *p1_it)/2.0).distance(*p2_it);
                <B><FONT COLOR="#A020F0">if</FONT></B>(dist &lt; dist_N1){
                    <I><FONT COLOR="#B22222">//Bump the previous nearest down the line.
</FONT></I>                    dist_N2 = dist_N1;
                    N2 = N1;
       
                    <I><FONT COLOR="#B22222">//Update the nearest.
</FONT></I>                    dist_N1 = dist;
                    N1 = p2_it;
                    <B><FONT COLOR="#A020F0">continue</FONT></B>;
                }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(dist &lt; dist_N2){
                    dist_N2 = dist;
                    N2 = p2_it;
                }
            }

            <I><FONT COLOR="#B22222">//Now, we have several neighbouring points. Construct surface triangles and continue.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>( (dist_N1 != 1E50) &amp;&amp; (dist_N2 != 1E60) &amp;&amp; (dist_N1 != dist_N2) &amp;&amp; (N1 != N2) ){
                <I><FONT COLOR="#B22222">//Keep orientation consistent!
</FONT></I>                out.push_back(*p0_it); out.push_back(*p1_it); out.push_back(*N2); out.push_back((*p1_it - *p0_it).Cross(*N2 - *p0_it)); 
                out.push_back(*p0_it); out.push_back(*N2);    out.push_back(*N1); out.push_back((*N2 - *p0_it).Cross(*N1 - *p0_it)); 

            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                <I><FONT COLOR="#B22222">//FUNCWARN(&quot; .... encountered insufficient data for terrible surface reconstruction? :) ...&quot;);
</FONT></I>                <I><FONT COLOR="#B22222">//NOTE: News flash! World's Worst Algorithm Sucks! What did you expect?!
</FONT></I>            }
            p0_it = p1_it;
        }
        s1_it = s2_it;
        ++s2_it;

    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt;vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;&gt; contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Generate_Basic_Surface(<B><FONT COLOR="#228B22">float</FONT></B>  min_dist) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Generate_Basic_Surface(<B><FONT COLOR="#228B22">double</FONT></B> min_dist) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::vector&lt;vec3&lt;T&gt;&gt; contour_collection&lt;T&gt;::Generate_Reconstructed_Surface(T qual) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;vec3&lt;T&gt;&gt; out;
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.size() &lt;= 2){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempted to perform basic surface reconstruction on data with too few contours (&lt;=2). Continuing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
    }
   
    <B><FONT COLOR="#228B22">const</FONT></B> vec3&lt;T&gt; Contour_Separation_Unit((T)(0),(T)(0),(T)(1));

    <I><FONT COLOR="#B22222">//First, sort the data into distinct heights along z.
</FONT></I>    <B><FONT COLOR="#228B22">typedef</FONT></B> typename std::list&lt;contour_of_points&lt;T&gt;&gt;::const_iterator  height_to_c_it_t;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;T,height_to_c_it_t&gt; slices;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> z = (c_it-&gt;First_N_Point_Avg(3)).Dot( Contour_Separation_Unit );
        <B><FONT COLOR="#A020F0">if</FONT></B>(slices.find(z) != slices.end()){
            FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempting to perform basic surface reconstruction on data which contains disjoint islands. Ignoring smallest contour at this height and continuing.&quot;</FONT></B>);
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> A1 = c_it-&gt;Get_Signed_Area();
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> A2 = slices[z]-&gt;Get_Signed_Area();
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORABS(A1) &gt; YGORABS(A2)){
                slices[z] = c_it;
            }
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            slices[z] = c_it;
        }
    }

    <I><FONT COLOR="#B22222">//Now, stepping over the contours from the bottom to the top (or vice versa) we step over the points
</FONT></I>    <I><FONT COLOR="#B22222">// one by one and find nearest neighbours.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> s1_it = slices.begin();
    <B><FONT COLOR="#228B22">auto</FONT></B> s2_it = ++(slices.begin());
    vec3&lt;T&gt; Last_N2, Last_N1;

    <B><FONT COLOR="#A020F0">while</FONT></B>(s2_it != slices.end()){
        <B><FONT COLOR="#A020F0">if</FONT></B>(!s1_it-&gt;second-&gt;closed || !s2_it-&gt;second-&gt;closed){
            FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Performing surface reconstruction on a contour which isn't closed. Treating as closed and continuing!&quot;</FONT></B>);
        }

<I><FONT COLOR="#B22222">//        const auto height_sep = YGORABS(s2_it-&gt;first - s1_it-first);
</FONT></I>
        <I><FONT COLOR="#B22222">//Create copies of the contours (so we can later rotate them).
</FONT></I>        contour_of_points&lt;T&gt; copy1(*(s1_it-&gt;second));
        contour_of_points&lt;T&gt; copy2(*(s2_it-&gt;second));

        <I><FONT COLOR="#B22222">//Ensure the orientation is the same.
</FONT></I>        copy1.Reorient_Counter_Clockwise();
        copy2.Reorient_Counter_Clockwise();

        <I><FONT COLOR="#B22222">//Find the two closest points from s1 and s2. Rotate the contours so they are first in each.
</FONT></I>        {
          <B><FONT COLOR="#228B22">auto</FONT></B> p0_s1_it = copy1.points.begin();
          <B><FONT COLOR="#228B22">auto</FONT></B> p0_s2_it = copy2.points.begin();
          T min_sq_dist = p0_s1_it-&gt;sq_dist(*p0_s2_it);
          <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_s1_it = copy1.points.begin(); p_s1_it != copy1.points.end(); ++p_s1_it){
              <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_s2_it = copy2.points.begin(); p_s2_it != copy2.points.end(); ++p_s2_it){
                  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> sq_dist = p_s1_it-&gt;sq_dist(*p_s2_it);
                  <B><FONT COLOR="#A020F0">if</FONT></B>(sq_dist &lt; min_sq_dist){
                      min_sq_dist = sq_dist;
                      p0_s1_it = p_s1_it;
                      p0_s2_it = p_s2_it;
                  }
              }
          }
          <B><FONT COLOR="#5F9EA0">std</FONT></B>::rotate(copy1.points.begin(), p0_s1_it, copy1.points.end());
          <B><FONT COLOR="#5F9EA0">std</FONT></B>::rotate(copy2.points.begin(), p0_s2_it, copy2.points.end());
        }

        <I><FONT COLOR="#B22222">//Resample the contours evenly.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> num_points1 = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(copy1.points.size());
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> num_points2 = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(copy2.points.size());
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> num_points = YGORMAX(num_points1, num_points2);
        num_points = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;( std::round( static_cast&lt;T&gt;(num_points)*qual ) );

        copy1.Resample_Evenly_Along_Perimeter(num_points);
        copy2.Resample_Evenly_Along_Perimeter(num_points);

<I><FONT COLOR="#B22222">//        const auto lperim1 = copy1.Average_Perimeter();
</FONT></I><I><FONT COLOR="#B22222">//        const auto lperim2 = copy2.Average_Perimeter();
</FONT></I>
        <I><FONT COLOR="#B22222">//Cycle through the (now ordered) points, reconstructing triangle faces.
</FONT></I>        <I><FONT COLOR="#B22222">// NOTE: These are very naturally GL_TRIANGLE_FANS. Probably a good idea to exploit it!
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">//                       p0_s2_it             p1_s2_it
</FONT></I>        <I><FONT COLOR="#B22222">//  ...---&gt;----o---&gt;-------o--------------------o--------&gt;-----o----&gt;----...     &lt;---Contour s2 (above)
</FONT></I>        <I><FONT COLOR="#B22222">//                         |              ___---|
</FONT></I>        <I><FONT COLOR="#B22222">//                         |       ___----      |
</FONT></I>        <I><FONT COLOR="#B22222">//                         |___----             |
</FONT></I>        <I><FONT COLOR="#B22222">//  ...---&gt;----o---&gt;-------o--------------------o--------&gt;-----o----&gt;----...     &lt;---Contour s1 (below)
</FONT></I>        <I><FONT COLOR="#B22222">//                       p0_s1_it             p1_s1_it
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> p0_s1_it = copy1.points.begin();
        <B><FONT COLOR="#228B22">auto</FONT></B> p0_s2_it = copy2.points.begin();
        <B><FONT COLOR="#228B22">auto</FONT></B> p1_s1_it = std::next(p0_s1_it);
        <B><FONT COLOR="#228B22">auto</FONT></B> p1_s2_it = std::next(p0_s2_it);

        <B><FONT COLOR="#A020F0">while</FONT></B>( (p1_s1_it != copy1.points.end()) &amp;&amp; (p1_s2_it != copy2.points.end()) ){
<I><FONT COLOR="#B22222">/*
            //If we have become separated by a significant distance due to rapid contour changes, then attempt
            // to jog it a little.
            const auto p_s1_avg = (*p0_s1_it + *p1_s1_it)*0.5;
            const auto p_s2_avg = (*p0_s2_it + *p1_s2_it)*0.5;
            const auto reasonable_dist = 2.0*std::sqrt(height_sep*height_sep + (*p1_s1_it - *p0_s1_it).sq_dist());
//            const auto reasonable_dist1 = 2.0*std::sqrt(height_sep*height_sep + (*p1_s1_it - *p0_s1_it).sq_dist());
            const auto dist = (p_s1_avg - p_s2_avg).distance();
            if(dist &gt; reasonable_dist){ //Jogged too far over...
 
            p0_s1_it = p1_s1_it;
            ++p1_s1_it;

                continue;
            }
*/</FONT></I>
            out.push_back(*p0_s1_it); out.push_back(*p1_s1_it); out.push_back(*p1_s2_it); <I><FONT COLOR="#B22222">//Lower triangle. 
</FONT></I>            out.push_back((*p1_s2_it - *p1_s1_it).Cross(*p0_s1_it - *p1_s1_it).unit()); <I><FONT COLOR="#B22222">//Normal
</FONT></I>
            out.push_back(*p0_s1_it); out.push_back(*p1_s2_it); out.push_back(*p0_s2_it); <I><FONT COLOR="#B22222">//Upper triangle. 
</FONT></I>            out.push_back((*p0_s1_it - *p0_s2_it).Cross(*p1_s2_it - *p0_s2_it).unit()); <I><FONT COLOR="#B22222">//Normal
</FONT></I>
            p0_s1_it = p1_s1_it;
            ++p1_s1_it;
            p0_s2_it = p1_s2_it;
            ++p1_s2_it;
        }

        s1_it = s2_it;
        ++s2_it;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt;vec3&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;&gt; contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Generate_Reconstructed_Surface(<B><FONT COLOR="#228B22">float</FONT></B>  qual) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::vector&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Generate_Reconstructed_Surface(<B><FONT COLOR="#228B22">double</FONT></B> qual) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>





<I><FONT COLOR="#B22222">//This routine produces a very simple, default plot of the data. If more customization is required, you'll have to look elsewhere!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;T&gt;::Plot(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title) <B><FONT COLOR="#228B22">const</FONT></B> {
    Plot3_List_of_contour_of_points(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(), <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(), title);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Plot(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Plot(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;T&gt;::Plot(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Plot(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>); <I><FONT COLOR="#B22222">//No title.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Plot(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Plot(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>



<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::string contour_collection&lt;T&gt;::write_to_string(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream out;
    <I><FONT COLOR="#B22222">//There IS significant spaces in this representation.
</FONT></I>    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;{ contour_collection &quot;</FONT></B>;
    out &lt;&lt; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.size() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> c_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.begin(); c_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.end(); ++c_it){
        out &lt;&lt; c_it-&gt;write_to_string() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; ENDOFCONTOUR &quot;</FONT></B>;
    }
    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; }&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">return</FONT></B> out.str();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::string contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::write_to_string(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::string contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::write_to_string(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Returns true if it worked/was loaded into the contour, false otherwise.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;T&gt;::load_from_string(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#A020F0">if</FONT></B>(in.size() &lt; 25) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//Not enough characters to possibly hold a contour.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(in.find(<B><FONT COLOR="#BC8F8F">' '</FONT></B>) == std::string::npos) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//All whitespace has been stripped. We cannot parse it now.
</FONT></I><I><FONT COLOR="#B22222">//    if(in.find(&quot;ENDOFCONTOUR&quot;) == std::string::npos) return false;  //There are no contours, or formatting is bad.
</FONT></I>
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ins(in);
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string grbg;
    ins &gt;&gt; grbg &gt;&gt; grbg; <I><FONT COLOR="#B22222">// &quot;{&quot; and &quot;contour_collection&quot;
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(grbg != <B><FONT COLOR="#BC8F8F">&quot;contour_collection&quot;</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <I><FONT COLOR="#B22222">//Here we can be reasonably certain it (looks) like a contour collection.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.clear();
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N;
    ins &gt;&gt; N;
    <B><FONT COLOR="#A020F0">if</FONT></B>(N &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; ++i){
        <I><FONT COLOR="#B22222">//Loop until the next end of the contour is found.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string raw, contour_string;
        <B><FONT COLOR="#A020F0">do</FONT></B>{
            ins &gt;&gt; raw;
            <B><FONT COLOR="#A020F0">if</FONT></B>(raw != <B><FONT COLOR="#BC8F8F">&quot;ENDOFCONTOUR&quot;</FONT></B>) contour_string += raw + <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        }<B><FONT COLOR="#A020F0">while</FONT></B>(raw != <B><FONT COLOR="#BC8F8F">&quot;ENDOFCONTOUR&quot;</FONT></B>);

        <I><FONT COLOR="#B22222">//Attempt to parse the accumulated contour.
</FONT></I>        contour_of_points&lt;T&gt; contour;
        <B><FONT COLOR="#A020F0">if</FONT></B>(!contour.load_from_string(contour_string)) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//Failure to parse!
</FONT></I>        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;contours.push_back(contour);
    }
    ins &gt;&gt; grbg; <I><FONT COLOR="#B22222">// final &quot;}&quot;
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(grbg != <B><FONT COLOR="#BC8F8F">&quot;}&quot;</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::load_from_string(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::load_from_string(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------- samples_1D: a convenient way to collect a sequentially-sampled array of data ------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; samples_1D&lt;T&gt;::samples_1D(){ }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::samples_1D(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::samples_1D(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; samples_1D&lt;T&gt;::samples_1D(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt; vec2&lt;T&gt; &gt; &amp;in_samps) : samples(in_samps)  { }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::samples_1D(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt; vec2&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &gt; &amp;in_points);
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::samples_1D(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt; vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &gt; &amp;in_points);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; samples_1D&lt;T&gt;::samples_1D(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;in) : samples(in.samples)  { }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::samples_1D(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;in);
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::samples_1D(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;T&gt;::push_back(T x, T y){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.push_back( vec2&lt;T&gt;(x,y) );
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::push_back(<B><FONT COLOR="#228B22">float</FONT></B>  x, <B><FONT COLOR="#228B22">float</FONT></B>  y);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::push_back(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  <B><FONT COLOR="#228B22">bool</FONT></B> samples_1D&lt;T&gt;::empty() <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.empty();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::empty() <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::empty() <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  size_t samples_1D&lt;T&gt;::size() <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.size();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> size_t samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::size() <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> size_t samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::size() <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Selects those with a key within [L,H] (inclusive), leaving the order intact.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  samples_1D&lt;T&gt; samples_1D&lt;T&gt;::Select_Those_Within_Inc(T L, T H) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Easy, inefficient way: copy everything, prune out those which do not satisfy the criteria.
</FONT></I>    samples_1D&lt;T&gt; out(*<B><FONT COLOR="#A020F0">this</FONT></B>);
    <B><FONT COLOR="#228B22">auto</FONT></B> it = out.samples.begin();
    <B><FONT COLOR="#A020F0">while</FONT></B>(it != out.samples.end()){
        <B><FONT COLOR="#A020F0">if</FONT></B>(!isininc(L,it-&gt;x,H)){
            it = out.samples.erase(it);
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            ++it;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Select_Those_Within_Inc(<B><FONT COLOR="#228B22">float</FONT></B>  L, <B><FONT COLOR="#228B22">float</FONT></B>  H) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Select_Those_Within_Inc(<B><FONT COLOR="#228B22">double</FONT></B> L, <B><FONT COLOR="#228B22">double</FONT></B> H) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;   T samples_1D&lt;T&gt;::Interpolate_Linearly(<B><FONT COLOR="#228B22">const</FONT></B> T &amp;x) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Step 0 - Sanity checks.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.size() &lt; 2) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to interpolate - there are less than 2 samples&quot;</FONT></B>);

    <I><FONT COLOR="#B22222">//Step 1 - Check if the point is within the endpoints. 
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> T first_x = (*(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.begin())).x;
    <B><FONT COLOR="#228B22">const</FONT></B> T last_x  = (*(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.rbegin())).x;

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> Ordered_Low_First = (first_x &lt; last_x) ? true : false;
    <B><FONT COLOR="#228B22">const</FONT></B> T lowest_x  = (first_x &lt; last_x) ? first_x : last_x;
    <B><FONT COLOR="#228B22">const</FONT></B> T highest_x = (first_x &lt; last_x) ? last_x  : first_x;

    <B><FONT COLOR="#A020F0">if</FONT></B>(!isininc(lowest_x, x, highest_x)){
        <I><FONT COLOR="#B22222">//Here will we 'interpolate' to zero. I *think* this is makes the most mathematical sense.
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B> (T)(0.0);
    }

    <I><FONT COLOR="#B22222">//Step 2 - Check if the point is bounded by two samples (or if it is sitting exactly on a sample.)
</FONT></I><I><FONT COLOR="#B22222">//    bool bounded = false;
</FONT></I>    T x0(0), x1(0), y0(0), y1(0); <I><FONT COLOR="#B22222">//Initialized to 0 to silence warnings.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it0 = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.begin(); it0 != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.end(); ++it0){
        <B><FONT COLOR="#228B22">auto</FONT></B> it1 = it0;
        ++it1;

        <B><FONT COLOR="#A020F0">if</FONT></B>(Ordered_Low_First){
            <B><FONT COLOR="#A020F0">if</FONT></B>( isininc( it0-&gt;x, x, it1-&gt;x ) ){
                <I><FONT COLOR="#B22222">//Check if the point is *exactly* on a sample. Important for integer (&quot;bin&quot;) samples.
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B>( x == it0-&gt;x ) <B><FONT COLOR="#A020F0">return</FONT></B> it0-&gt;y;
                <B><FONT COLOR="#A020F0">if</FONT></B>( x == it1-&gt;x ) <B><FONT COLOR="#A020F0">return</FONT></B> it1-&gt;y;

<I><FONT COLOR="#B22222">//                bounded = true;
</FONT></I>                x0 = it0-&gt;x;   x1 = it1-&gt;x;
                y0 = it0-&gt;y;   y1 = it1-&gt;y;
                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#A020F0">if</FONT></B>( isininc( it1-&gt;x, x, it0-&gt;x ) ){
                <I><FONT COLOR="#B22222">//Check if the point is *exactly* on a sample. Important for integer (&quot;bin&quot;) samples.
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B>( x == it0-&gt;x ) <B><FONT COLOR="#A020F0">return</FONT></B> it0-&gt;y;
                <B><FONT COLOR="#A020F0">if</FONT></B>( x == it1-&gt;x ) <B><FONT COLOR="#A020F0">return</FONT></B> it1-&gt;y;

<I><FONT COLOR="#B22222">//                bounded = true;
</FONT></I>                x0 = it1-&gt;x;   x1 = it0-&gt;x;
                y0 = it1-&gt;y;   y1 = it0-&gt;y;
                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }
    }

    <I><FONT COLOR="#B22222">//Step 3 - Given a (distinct) lower and an upper point, we perform the linear interpolation.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> y0 + ( y1 - y0 ) * (x - x0)/( x1 - x0 );
}

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Interpolate_Linearly(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> &amp;x) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Interpolate_Linearly(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;x) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;T&gt;::Order_Data_Lowest_First(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.sort( []( vec2&lt;T&gt; A, vec2&lt;T&gt; B ) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> A.x &lt; B.x; } );
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Order_Data_Lowest_First(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Order_Data_Lowest_First(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;T&gt;::Order_Data_Lowest_Last(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.sort( []( vec2&lt;T&gt; A, vec2&lt;T&gt; B ) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> A.x &gt; B.x; } );
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Order_Data_Lowest_Last(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Order_Data_Lowest_Last(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> Function&gt; T samples_1D&lt;T&gt;::Integrate_Generic(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;g, Function F) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Computes the generic integral: \int_{-inf}^{inf} F(f(x), g(x), x) dx.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: This function acts a generic backend for the other integration routines.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: The &quot;Function F&quot; template needs only to define:  T operator(T f_x, T g_x, T x). A typical function would be
</FONT></I>    <I><FONT COLOR="#B22222">// the overlap integration where F = f_x*g_x.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//History:  - v. 0.0 - simple, inefficient, imprecise midpoint rule w/ interpolation of f and g.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Step 0 - Sanity checks.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.size() &lt; 2) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to interpolate f - there are less than 2 samples&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(g.samples.size() &lt; 2) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to interpolate g - there are less than 2 samples&quot;</FONT></B>);

    <I><FONT COLOR="#B22222">//Step 1 - Establish actual endpoints.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> T f_first_x = (*(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.begin())).x;
    <B><FONT COLOR="#228B22">const</FONT></B> T f_last_x  = (*(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.rbegin())).x;
    <B><FONT COLOR="#228B22">const</FONT></B> T g_first_x = (*(g.samples.begin())).x;
    <B><FONT COLOR="#228B22">const</FONT></B> T g_last_x  = (*(g.samples.rbegin())).x;

    <B><FONT COLOR="#228B22">const</FONT></B> T f_lowest_x  = (f_first_x &lt; f_last_x) ? f_first_x : f_last_x;
    <B><FONT COLOR="#228B22">const</FONT></B> T f_highest_x = (f_first_x &lt; f_last_x) ? f_last_x  : f_first_x;
    <B><FONT COLOR="#228B22">const</FONT></B> T g_lowest_x  = (g_first_x &lt; g_last_x) ? g_first_x : g_last_x;
    <B><FONT COLOR="#228B22">const</FONT></B> T g_highest_x = (g_first_x &lt; g_last_x) ? g_last_x  : g_first_x;

    <B><FONT COLOR="#228B22">const</FONT></B> T lowest_x = (f_lowest_x &lt; g_lowest_x) ? f_lowest_x : g_lowest_x;
    <B><FONT COLOR="#228B22">const</FONT></B> T highest_x = (f_highest_x &gt; g_highest_x) ? f_highest_x : g_highest_x;

    <I><FONT COLOR="#B22222">//Step 2 - Given the bounds, we integrate by interpolation.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> T dx = (highest_x - lowest_x) / (T)(100.0);
    T res = (T)(0.0);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> x = lowest_x;  x &lt; (highest_x-0.5*dx); x += dx){
<I><FONT COLOR="#B22222">//        res += dx * this-&gt;Interpolate_Linearly(x+0.5*dx) * g.Interpolate_Linearly(x+0.5*dx);
</FONT></I>        res += dx * F( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Interpolate_Linearly(x+0.5*dx), g.Interpolate_Linearly(x+0.5*dx), x+0.5*dx );
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Integrate_Generic(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;g, std::function&lt; <B><FONT COLOR="#228B22">float</FONT></B>(<B><FONT COLOR="#228B22">float</FONT></B>, <B><FONT COLOR="#228B22">float</FONT></B>, <B><FONT COLOR="#228B22">float</FONT></B>)&gt; F) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Integrate_Generic(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;g, std::function&lt; <B><FONT COLOR="#228B22">double</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B>, <B><FONT COLOR="#228B22">double</FONT></B>, <B><FONT COLOR="#228B22">double</FONT></B>)&gt; F) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;   T samples_1D&lt;T&gt;::Integrate_Overlap(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;g) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">auto</FONT></B> F = [](T f_x, T g_x, T x) -&gt; T {
        <B><FONT COLOR="#A020F0">return</FONT></B> f_x * g_x;
    };
<I><FONT COLOR="#B22222">//    return Integrate_Generic&lt;T&gt;&lt; std::function&lt; T (T, T, T)&gt; &gt;(g, F); //Does not compile.
</FONT></I><I><FONT COLOR="#B22222">//    return this-&gt;template Integrate_Generic&lt;decltype(F)&gt;(g, F);  //Works, but weird syntax!
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Integrate_Generic&lt;decltype(F)&gt;(g, F); <I><FONT COLOR="#B22222">//Works.
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Integrate_Overlap(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;g) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Integrate_Overlap(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;g) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  samples_1D&lt;T&gt; samples_1D&lt;T&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;rhs){
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B> == &amp;rhs) <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples = rhs.samples;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;rhs);
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;rhs);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  samples_1D&lt;T&gt; samples_1D&lt;T&gt;::Sum_With(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;g) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Step 0 - Sanity checks.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(g.samples.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> samples_1D&lt;T&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples);
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> samples_1D&lt;T&gt;();

    samples_1D&lt;T&gt; out;
    samples_1D&lt;T&gt; gcopy = samples_1D&lt;T&gt;( g.samples );
    samples_1D&lt;T&gt; fcopy = samples_1D&lt;T&gt;( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples );

    gcopy.Order_Data_Lowest_First();
    fcopy.Order_Data_Lowest_First();

    <B><FONT COLOR="#228B22">const</FONT></B> T f_first_x = (*(fcopy.samples.begin())).x;
    <B><FONT COLOR="#228B22">const</FONT></B> T f_last_x  = (*(fcopy.samples.rbegin())).x;
    <B><FONT COLOR="#228B22">const</FONT></B> T g_first_x = (*(gcopy.samples.begin())).x;
    <B><FONT COLOR="#228B22">const</FONT></B> T g_last_x  = (*(gcopy.samples.rbegin())).x;

    <B><FONT COLOR="#228B22">const</FONT></B> T f_lowest_x  = (f_first_x &lt; f_last_x) ? f_first_x : f_last_x;
    <B><FONT COLOR="#228B22">const</FONT></B> T f_highest_x = (f_first_x &lt; f_last_x) ? f_last_x  : f_first_x;
    <B><FONT COLOR="#228B22">const</FONT></B> T g_lowest_x  = (g_first_x &lt; g_last_x) ? g_first_x : g_last_x;
    <B><FONT COLOR="#228B22">const</FONT></B> T g_highest_x = (g_first_x &lt; g_last_x) ? g_last_x  : g_first_x;

    <I><FONT COLOR="#B22222">//Get the part on the left where only one set of samples lies.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> f_it = fcopy.samples.begin(); 
    <B><FONT COLOR="#228B22">auto</FONT></B> g_it = gcopy.samples.begin();

    <B><FONT COLOR="#A020F0">while</FONT></B>( true ){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> fvalid = (f_it != fcopy.samples.end());  
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> gvalid = (g_it != gcopy.samples.end());

        <B><FONT COLOR="#A020F0">if</FONT></B>(fvalid &amp;&amp; !gvalid){
            out.samples.push_back( *f_it );
            ++f_it;
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(gvalid &amp;&amp; !fvalid){
            out.samples.push_back( *g_it );
            ++g_it;
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(fvalid &amp;&amp; gvalid){
            <I><FONT COLOR="#B22222">//The point which is left-most gets pushed into the summation.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>( f_it-&gt;x == g_it-&gt;x ){
                out.samples.push_back( vec2&lt;T&gt;(f_it-&gt;x, f_it-&gt;y + g_it-&gt;y) );
                ++f_it;
                ++g_it;
                <B><FONT COLOR="#A020F0">continue</FONT></B>;
            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( f_it-&gt;x &lt; g_it-&gt;x ){
                <B><FONT COLOR="#A020F0">if</FONT></B>(isininc(g_lowest_x, f_it-&gt;x, g_highest_x)){ <I><FONT COLOR="#B22222">//If we can interpolate, then do so. This saves errors on single-point samples.
</FONT></I>                    out.samples.push_back( vec2&lt;T&gt;(f_it-&gt;x, f_it-&gt;y + gcopy.Interpolate_Linearly(f_it-&gt;x))  );
                }<B><FONT COLOR="#A020F0">else</FONT></B>{
                    out.samples.push_back( *f_it );
                }
                ++f_it;
                <B><FONT COLOR="#A020F0">continue</FONT></B>;
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                <B><FONT COLOR="#A020F0">if</FONT></B>(isininc(f_lowest_x, g_it-&gt;x, f_highest_x)){ <I><FONT COLOR="#B22222">//If we can interpolate, then do so. This saves errors on single-point samples.
</FONT></I>                    out.samples.push_back( vec2&lt;T&gt;(g_it-&gt;x, g_it-&gt;y + fcopy.Interpolate_Linearly(g_it-&gt;x))  );
                }<B><FONT COLOR="#A020F0">else</FONT></B>{
                    out.samples.push_back( *g_it );
                }
                ++g_it;
                <B><FONT COLOR="#A020F0">continue</FONT></B>;
            }
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(!fvalid &amp;&amp; !gvalid){
            <B><FONT COLOR="#A020F0">break</FONT></B>; <I><FONT COLOR="#B22222">//Done.
</FONT></I>        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Sum_With(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Sum_With(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  samples_1D&lt;T&gt; samples_1D&lt;T&gt;::Subtract(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;B) <B><FONT COLOR="#228B22">const</FONT></B> {
    samples_1D neg(B);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = neg.samples.begin(); it != neg.samples.end(); ++it) it-&gt;y = -it-&gt;y;
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Sum_With(neg);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Subtract(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Subtract(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; samples_1D&lt;T&gt; samples_1D&lt;T&gt;::Resample_Average_Into_N_Equal_Sized_Bins(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, <B><FONT COLOR="#228B22">bool</FONT></B> explicitbins) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Ensure we are sorted from lowest to highest.
</FONT></I>    samples_1D&lt;T&gt; out( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples );
    out.Order_Data_Lowest_First();

    <I><FONT COLOR="#B22222">//Get the min/max x-value and bin spacing.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> xmin = out.samples.front().x;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> xmax = out.samples.back().x;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dx   = (xmax - xmin)/static_cast&lt;T&gt;(N);
    out.samples.clear();

    <I><FONT COLOR="#B22222">//Cycle through the original data. We make N passes because we cannot use the copied/sorted data.
</FONT></I>    <I><FONT COLOR="#B22222">// This should be fixed, but the solution is not obvious. Maybe a more functionally pure approach
</FONT></I>    <I><FONT COLOR="#B22222">// with sorting?
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; ++i){
        T val((T)(0)), num((T)(0));
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> btm = xmin + static_cast&lt;T&gt;(i)*dx;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> top = xmin + static_cast&lt;T&gt;(i+1)*dx;
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.begin(); p_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.end(); ++p_it){
            <B><FONT COLOR="#A020F0">if</FONT></B>(isininc(btm, p_it-&gt;x, top)){
                val += p_it-&gt;y;
                num += (T)(1);
            }
        }
        <I><FONT COLOR="#B22222">//If the user wants a pure resample, omit the bins.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(!explicitbins){
            out.samples.push_back(vec2&lt;T&gt;((T)(0.5)*(btm+top), val/num));

        <I><FONT COLOR="#B22222">//Otherwise, if displaying on screen (or similar) we explicitly show the bin edges.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(num != (T)(0)){
            out.samples.push_back(vec2&lt;T&gt;(btm, (T)(0)) );
            out.samples.push_back(vec2&lt;T&gt;(btm, val/num));
            out.samples.push_back(vec2&lt;T&gt;(top, val/num));
            out.samples.push_back(vec2&lt;T&gt;(top, (T)(0)) );
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Resample_Average_Into_N_Equal_Sized_Bins(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, <B><FONT COLOR="#228B22">bool</FONT></B> showbins) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Resample_Average_Into_N_Equal_Sized_Bins(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, <B><FONT COLOR="#228B22">bool</FONT></B> showbins) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Replaces x-values with (integer) rank. N-plicates get an averaged (maybe non-integer) rank.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Rank is 0-based!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; samples_1D&lt;T&gt; samples_1D&lt;T&gt;::Rank_x(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    samples_1D&lt;T&gt; out(*<B><FONT COLOR="#A020F0">this</FONT></B>);

    <I><FONT COLOR="#B22222">//First, sort x's lowest-first and cycle through, replacing the x-value with the rank (1-based integer). 
</FONT></I>    <I><FONT COLOR="#B22222">// All neighbouring points which share a common x (N-plicates!) get an averaged rank. This is important for
</FONT></I>    <I><FONT COLOR="#B22222">// statistical purposes and could be filtered out afterward if desired.
</FONT></I>    out.Order_Data_Lowest_First(); <I><FONT COLOR="#B22222">//Sort on x.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(out.samples.size() &lt; 2) <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = out.samples.begin(); p_it != out.samples.end(); ){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> X = p_it-&gt;x; <I><FONT COLOR="#B22222">//The x-value of interest.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> p2_it = p_it;      <I><FONT COLOR="#B22222">//Point where N-plicates stop.
</FONT></I>        size_t num(1);          <I><FONT COLOR="#B22222">//Number of N-plicates x.
</FONT></I>       
        <I><FONT COLOR="#B22222">//Iterate just past the N-plicates. 
</FONT></I>        <B><FONT COLOR="#A020F0">while</FONT></B>(((++p2_it) != out.samples.end()) &amp;&amp; (p2_it-&gt;x == X)) ++num;
        
        <I><FONT COLOR="#B22222">//This rank gives the average of N sequential natural numbers.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> rank = static_cast&lt;T&gt;(std::distance(out.samples.begin(),p_it));
        rank += (T)(0.5) * static_cast&lt;T&gt;(num - 1); 
        
        <I><FONT COLOR="#B22222">//Set the rank and iterate past all the N-plicates.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> pp_it = p_it; pp_it != p2_it; ++pp_it){
            <I><FONT COLOR="#B22222">//FUNCINFO(&quot;Assigning x-value &quot; &lt;&lt; p_it-&gt;x &lt;&lt; &quot; a rank of &quot; &lt;&lt; rank);
</FONT></I>            p_it-&gt;x = rank;
            ++p_it;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Rank_x(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Rank_x(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Replaces y-values with (integer) rank. N-plicates get an averaged (maybe non-integer) rank.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Rank is 0-based!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; samples_1D&lt;T&gt; samples_1D&lt;T&gt;::Rank_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    samples_1D&lt;T&gt; out(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Swap_x_and_y().Rank_x().Swap_x_and_y());
    out.Order_Data_Lowest_First();
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Rank_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Rank_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; samples_1D&lt;T&gt; samples_1D&lt;T&gt;::Swap_x_and_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    samples_1D&lt;T&gt; out(*<B><FONT COLOR="#A020F0">this</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = out.samples.begin(); p_it != out.samples.end(); ++p_it){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> copyx = p_it-&gt;x;
        p_it-&gt;x = p_it-&gt;y;
        p_it-&gt;y = copyx;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Swap_x_and_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Swap_x_and_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; T samples_1D&lt;T&gt;::Average_x(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    T out((T)(0));
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.begin(); p_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.end(); ++p_it){
        out += p_it-&gt;x;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out / static_cast&lt;T&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.size());
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Average_x(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Average_x(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; T samples_1D&lt;T&gt;::Average_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    T out((T)(0));
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.begin(); p_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.end(); ++p_it){
        out += p_it-&gt;y;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out / static_cast&lt;T&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.size());
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>  samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Average_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Average_y(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//------------------------------- Statistical quantities ---------------------------------
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::tuple&lt;T,T,T,T&gt; samples_1D&lt;T&gt;::Spearmans_Rank_Correlation_Coefficient(<B><FONT COLOR="#228B22">bool</FONT></B> *OK<I><FONT COLOR="#B22222">/*=nullptr*/</FONT></I>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Computes a correlation coefficient suitable for judging correlation (without any underlying model!) when the data is 
</FONT></I>    <I><FONT COLOR="#B22222">// monotonically increasing or decreasing.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//See http://en.wikipedia.org/wiki/Spearman's_rank_correlation_coefficient#Definition_and_calculation for more info.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Returns three numbers:
</FONT></I>    <I><FONT COLOR="#B22222">//  1) The coefficient itself (rho),
</FONT></I>    <I><FONT COLOR="#B22222">//  2) The number of samples used (type T - NOT integer),
</FONT></I>    <I><FONT COLOR="#B22222">//  3) The z-value,
</FONT></I>    <I><FONT COLOR="#B22222">//  4) The t-value.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: To compute the P-value from the t-value, use DOF = N-2 where N is given as the second return value.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> ret_on_err = std::make_tuple((T)(-1),(T)(-1),(T)(-1),(T)(-1)); 

    <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; ranked(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Rank_x().Rank_y());
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> avgx = ranked.Average_x();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> avgy = ranked.Average_y();

    T numer((T)(0)), denomA((T)(0)), denomB((T)(0));
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = ranked.samples.begin(); p_it != ranked.samples.end(); ++p_it){
        numer  += (p_it-&gt;x - avgx)*(p_it-&gt;y - avgy);
        denomA += (p_it-&gt;x - avgx)*(p_it-&gt;x - avgx);
        denomB += (p_it-&gt;y - avgy)*(p_it-&gt;y - avgy);
    }
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> rho = numer/std::sqrt(denomA*denomB);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isfinite(rho) || (YGORABS(rho) &gt; (T)(1))){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Found coefficient which was impossible or nan. Bailing&quot;</FONT></B>);
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Found coefficient which was impossible or nan. Bailing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> ret_on_err;
    }
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> num = static_cast&lt;T&gt;(ranked.samples.size());

    <B><FONT COLOR="#A020F0">if</FONT></B>(ranked.samples.size() &lt; 3){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to compute z-value - too little data&quot;</FONT></B>);
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to compute z-value - too little data&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> ret_on_err;
    }
    <B><FONT COLOR="#228B22">const</FONT></B> T zval = std::sqrt((num - 3.0)/1.060)*std::atanh(rho);

    <B><FONT COLOR="#A020F0">if</FONT></B>(ranked.samples.size() &lt; 2){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to compute t-value - too little data&quot;</FONT></B>);
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to compute t-value - too little data&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> ret_on_err;
    }
    <B><FONT COLOR="#228B22">const</FONT></B> T tval_n = rho*std::sqrt(num - (T)(2.0));
    <B><FONT COLOR="#228B22">const</FONT></B> T tval_d = std::sqrt((T)(1.0) - rho*rho);
    <B><FONT COLOR="#228B22">const</FONT></B> T tval   = std::isfinite((T)(1.0)/tval_d) ? tval_n/tval_d : std::numeric_limits&lt;T&gt;::max(); <I><FONT COLOR="#B22222">//Is actually infinite!
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::make_tuple(rho, num, zval, tval);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::tuple&lt;<B><FONT COLOR="#228B22">float</FONT></B> ,<B><FONT COLOR="#228B22">float</FONT></B> ,<B><FONT COLOR="#228B22">float</FONT></B> ,<B><FONT COLOR="#228B22">float</FONT></B> &gt; samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Spearmans_Rank_Correlation_Coefficient(<B><FONT COLOR="#228B22">bool</FONT></B> *OK) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::tuple&lt;<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Spearmans_Rank_Correlation_Coefficient(<B><FONT COLOR="#228B22">bool</FONT></B> *OK) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Computes Sxy, Sxx, Syy which are used for linear regression.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::tuple&lt;T,T,T&gt; samples_1D&lt;T&gt;::Compute_Sxy_Sxx_Syy(<B><FONT COLOR="#228B22">bool</FONT></B> *OK<I><FONT COLOR="#B22222">/*=nullptr*/</FONT></I>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> ret_on_err = std::make_tuple((T)(-1),(T)(-1),(T)(-1));

    <I><FONT COLOR="#B22222">//Ensure the data is suitable.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.size() &lt; 1){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to calculate Sxy,Sxx,Syy with so few points. Bailing&quot;</FONT></B>);
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to calculate Sxy,Sxx,Syy with so few points. Bailing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> ret_on_err;
    }

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> mean_x = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Average_x();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> mean_y = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Average_y();
    T Sxx((T)(0)), Sxy((T)(0)), Syy((T)(0));
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> v_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.begin(); v_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.end(); ++v_it){
        Sxy += (v_it-&gt;x - mean_x)*(v_it-&gt;y - mean_y);
        Sxx += (v_it-&gt;x - mean_x)*(v_it-&gt;x - mean_x);
        Syy += (v_it-&gt;y - mean_y)*(v_it-&gt;y - mean_y);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::make_tuple(Sxy,Sxx,Syy);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::tuple&lt;<B><FONT COLOR="#228B22">float</FONT></B> ,<B><FONT COLOR="#228B22">float</FONT></B> ,<B><FONT COLOR="#228B22">float</FONT></B> &gt; samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Compute_Sxy_Sxx_Syy(<B><FONT COLOR="#228B22">bool</FONT></B> *OK) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::tuple&lt;<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Compute_Sxy_Sxx_Syy(<B><FONT COLOR="#228B22">bool</FONT></B> *OK) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//Returns the pieces of a linear line: slope (A), intercept (B):  y = x*A + B.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::tuple&lt;T,T&gt; samples_1D&lt;T&gt;::Linear_Least_Squares_Regression(<B><FONT COLOR="#228B22">bool</FONT></B> *OK<I><FONT COLOR="#B22222">/*=nullptr*/</FONT></I>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">bool</FONT></B> l_OK(false);
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> ret_on_err = std::make_tuple((T)(-1),(T)(-1));

    <I><FONT COLOR="#B22222">//Ensure the data is suitable.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.size() &lt; 2){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Unable to perform linear regression with so few points. Bailing&quot;</FONT></B>);
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to perform linear regression with so few points. Bailing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> ret_on_err;
    }

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> mean_x = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Average_x();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> mean_y = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Average_y();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Sxyxxyy = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Compute_Sxy_Sxx_Syy(&amp;l_OK);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!l_OK){
        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Encountered problem computing Sxy,Sxx,Syy, which is needed for linear regression. Bailing&quot;</FONT></B>);
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Encountered problem computing Sxy,Sxx,Syy, which is needed for linear regression. Bailing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> ret_on_err;
    }
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Sxy = std::get&lt;0&gt;(Sxyxxyy);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> Sxx = std::get&lt;1&gt;(Sxyxxyy);
    <I><FONT COLOR="#B22222">//const auto Syy = std::get&lt;2&gt;(Sxyxxyy); //Not needed.
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> slope = Sxy/Sxx;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isfinite(slope)){ <I><FONT COLOR="#B22222">//Will catch nan too.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Linear regression computation failed. Slope was nan or infinite. Bailing&quot;</FONT></B>);
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Linear regression computation failed. Slope was nan or infinite. Bailing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> ret_on_err;
    }
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> intercept = mean_y - slope*mean_x;

    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::make_tuple(slope,intercept);
}       
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::tuple&lt;<B><FONT COLOR="#228B22">float</FONT></B> ,<B><FONT COLOR="#228B22">float</FONT></B> &gt; samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Linear_Least_Squares_Regression(<B><FONT COLOR="#228B22">bool</FONT></B> *OK) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::tuple&lt;<B><FONT COLOR="#228B22">double</FONT></B>,<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Linear_Least_Squares_Regression(<B><FONT COLOR="#228B22">bool</FONT></B> *OK) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>



<I><FONT COLOR="#B22222">//Normalizes data so that \int_{-inf}^{inf} f(x) (times) f(x) dx ~= 1.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;   <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;T&gt;::Normalize_wrt_Self_Overlap(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#228B22">const</FONT></B> T AA = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Integrate_Overlap( *<B><FONT COLOR="#A020F0">this</FONT></B> );
    <B><FONT COLOR="#228B22">const</FONT></B> T A  = sqrt(AA);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.begin(); it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.end(); ++it){
        it-&gt;y /= A;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;::Normalize_wrt_Self_Overlap(<B><FONT COLOR="#228B22">void</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Normalize_wrt_Self_Overlap(<B><FONT COLOR="#228B22">void</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This routine writes the numerical data to file in a 2-column format. It can be directly plotted or
</FONT></I><I><FONT COLOR="#B22222">// otherwise manipulated by, say, GNUplot.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine will not overwrite or append an existing file. It will return 'false' on any error
</FONT></I><I><FONT COLOR="#B22222">// or if encountering an existing file.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;   <B><FONT COLOR="#228B22">bool</FONT></B> samples_1D&lt;T&gt;::Write_To_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Check if the file already exists. 
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(Does_File_Exist_And_Can_Be_Read(filename)) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#A020F0">return</FONT></B> WriteStringToFile(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Write_To_String(), filename);
<I><FONT COLOR="#B22222">//    std::stringstream out;
</FONT></I><I><FONT COLOR="#B22222">//    for(auto it = this-&gt;samples.begin(); it != this-&gt;samples.end(); ++it){
</FONT></I><I><FONT COLOR="#B22222">//        out &lt;&lt; it-&gt;x &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;y &lt;&lt; std::endl;
</FONT></I><I><FONT COLOR="#B22222">//    }
</FONT></I><I><FONT COLOR="#B22222">//    return WriteStringToFile(out.str(),filename);
</FONT></I>}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Write_To_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename) <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Write_To_File(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;   std::string samples_1D&lt;T&gt;::Write_To_String() <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream out;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.begin(); it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;samples.end(); ++it){
        out &lt;&lt; it-&gt;x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; it-&gt;y &lt;&lt; std::endl;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out.str();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::string samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt;::Write_To_String() <B><FONT COLOR="#228B22">const</FONT></B>;
    <B><FONT COLOR="#228B22">template</FONT></B> std::string samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Write_To_String() <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//This routine produces a very simple, default plot of the data.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: No attempt is made to ensure the data is ordered - this may or may not be desirable for the user.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;T&gt;::Plot(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;Title) <B><FONT COLOR="#228B22">const</FONT></B> {
<I><FONT COLOR="#B22222">/*
    Plotter a_plot;
    a_plot.ss &lt;&lt; &quot;# Default, simple plot for 1D sequential samples: &quot; &lt;&lt; std::endl;

    for(auto s_it = this-&gt;samples.begin(); s_it != this-&gt;samples.end(); ++s_it){
        a_plot.ss &lt;&lt; s_it-&gt;x &lt;&lt; &quot; &quot;;
        a_plot.ss &lt;&lt; s_it-&gt;y &lt;&lt; &quot; &quot;;
        a_plot.ss &lt;&lt; std::endl;
    }
    a_plot.Plot();
    return;
*/</FONT></I>
<I><FONT COLOR="#B22222">/*
    Plotter2 a_plot;
    if(!(Title.empty())) a_plot.Set_Global_Title(Title);
    //a_plot.Set_Current_Line_Title(it-&gt;first);
    for(auto s_it = this-&gt;samples.begin(); s_it != this-&gt;samples.end(); ++s_it){
        a_plot.Insert(s_it-&gt;x, s_it-&gt;y);
    }
    //a_plot.Next_Line();
    a_plot.Plot();
    return;
*/</FONT></I>
    Plotter2 plot_coll;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!Title.empty()) plot_coll.Set_Global_Title(Title);
    plot_coll.Insert_samples_1D(*<B><FONT COLOR="#A020F0">this</FONT></B>);<I><FONT COLOR="#B22222">//,&quot;&quot;, const std::string &amp;linetype = &quot;&quot;);
</FONT></I>    plot_coll.Plot();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
<I><FONT COLOR="#B22222">//    template void samples_1D&lt;float &gt;::Plot(const std::string &amp;) const;
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::Plot(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;) <B><FONT COLOR="#228B22">const</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;( std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;T&gt; &amp;L ) {
    <I><FONT COLOR="#B22222">//Note: This friend is templated (Y) within the templated class (T). We only
</FONT></I>    <I><FONT COLOR="#B22222">// care about friend template when T==Y.
</FONT></I>    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;(samples_1D. num_samples= &quot;</FONT></B> &lt;&lt; L.samples.size() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = L.samples.begin(); s_it != L.samples.end(); ++s_it){
        out &lt;&lt; *s_it;
        out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        <I><FONT COLOR="#B22222">/*if(std::next(s_it) != L.samples.end()) out &lt;&lt; &quot;, &quot;; */</FONT></I>
    }
    out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;L );
    <B><FONT COLOR="#228B22">template</FONT></B> std::ostream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(std::ostream &amp;out, <B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;L );
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;    std::istream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&gt;&gt;( std::istream &amp;in, samples_1D&lt;T&gt; &amp;L ) {
    <I><FONT COLOR="#B22222">//Note: This friend is templated (Y) within the templated class (T). We only
</FONT></I>    <I><FONT COLOR="#B22222">// care about friend template when T==Y.
</FONT></I>    L.samples.clear(); 
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string grbg;
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N;
    in &gt;&gt; grbg; <I><FONT COLOR="#B22222">//'(samples_1D.'
</FONT></I>    in &gt;&gt; grbg; <I><FONT COLOR="#B22222">//'num_samples='
</FONT></I>    in &gt;&gt; N;    <I><FONT COLOR="#B22222">//'13'   ...or something...
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;N; ++i){
        vec2&lt;T&gt; shtl;
        in &gt;&gt; shtl;
        L.samples.push_back(shtl);
    }
    in &gt;&gt; grbg; <I><FONT COLOR="#B22222">//')'
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> in;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::istream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;&gt;(std::istream &amp;out, samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;L );
    <B><FONT COLOR="#228B22">template</FONT></B> std::istream &amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;&gt;(std::istream &amp;out, samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;L );
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>



<I><FONT COLOR="#B22222">//This function takes a list of (possibly unordered) numbers and returns a histogram with N bars of equal width
</FONT></I><I><FONT COLOR="#B22222">// suitable for plotting or further computation. The histogram will be normalized such that each bar will be 
</FONT></I><I><FONT COLOR="#B22222">// (number_of_points_represented_by_bar/total_number_of_points). In other words, the occurence rate.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//It is very efficient and should be fixed. I was in a hurry when I wrote it.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; samples_1D&lt;T&gt; Bag_of_numbers_to_N_equal_bin_samples_1D_histogram(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;T&gt; &amp;nums, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, <B><FONT COLOR="#228B22">bool</FONT></B> explicitbins){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;T&gt; in(nums);
    in.sort();
    samples_1D&lt;T&gt; out;

    <I><FONT COLOR="#B22222">//Get the min/max x-value and bin spacing.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> xmin = in.front();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> xmax = in.back();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dx   = (xmax - xmin)/static_cast&lt;T&gt;(N);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> tot  = static_cast&lt;T&gt;(in.size());

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; ++i){
        T num((T)(0));
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> btm = xmin + static_cast&lt;T&gt;(i)*dx;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> top = xmin + static_cast&lt;T&gt;(i+1)*dx;
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.begin(); it != in.end(); ++it){
            <B><FONT COLOR="#A020F0">if</FONT></B>(isininc(btm, *it, top)){
                num += (T)(1);
            }
        }
        <I><FONT COLOR="#B22222">//If the user wants a pure resample, omit the bins.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(!explicitbins){
            out.samples.push_back(vec2&lt;T&gt;((T)(0.5)*(btm+top), num/tot));

        <I><FONT COLOR="#B22222">//Otherwise, if displaying on screen (or similar) we explicitly show the bin edges.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(num != (T)(0)){
            out.samples.push_back(vec2&lt;T&gt;(btm, (T)(0)) );
            out.samples.push_back(vec2&lt;T&gt;(btm, num/tot));
            out.samples.push_back(vec2&lt;T&gt;(top, num/tot));
            out.samples.push_back(vec2&lt;T&gt;(top, (T)(0)) );
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORMATH_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; Bag_of_numbers_to_N_equal_bin_samples_1D_histogram(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">float</FONT></B> &gt; &amp;nums, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, <B><FONT COLOR="#228B22">bool</FONT></B> explicitbins);
    <B><FONT COLOR="#228B22">template</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; Bag_of_numbers_to_N_equal_bin_samples_1D_histogram(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;nums, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N, <B><FONT COLOR="#228B22">bool</FONT></B> explicitbins);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>




<I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////              SANDBOX STUFF              ///////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>

<I><FONT COLOR="#B22222">/*
    I didn't need this at the moment, but I feel it is something which might be useful for many things.
    Cannot get it to work so I abandoned it for a special case which happened to be applicable (planar_image).

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //This is a generic 3D bounding box routine. It is written in such a way as to 
    // hopefully move it into a more general spot somewhere in YgorMath.cc.

    // Diagram:
    //              _______------D_                               
    //            A __             --__                      
    //           /    --__             ---_                  
    //           |        --__             -_                
    //          /             --__     ___-- C                   
    //          |                  B --     /                
    //       r1  --__             /         |                    
    //         /     --__         |        /            
    //         |         --__    /    ____ |            
    //        /              --_ | ---      r3                   
    //        |                   r2      /             
    //       E __               /         |                  
    //           --__           |        /                  
    //               --__      /       __G           z         
    //                   --__  |  ___--              |  y         
    //                        F --                   | /    
    //                                               |/____x
    // Requirements:
    //   1) The points (A,B,C,D) must be ordered (in either orientation). 
    //   2) The points (E,F,G,H) must be ordered in the SAME orientation as (A,B,C,D).
    //   3) Point A must be next to all of (B,D,E).
    //   4) Point B must be next to all of (A,C,F).
    //   5) Point C must be next to all of (C,D,G).
    //   6) Point D must be next to all of (A,C,H).  (etc.)
    //
    // Notes:
    //   1) This routine does *not* require any of the points to lie on any planes, just
    //      that they are ordered uniformly.
    //   2) We may be given (r1,r2,r3,r4) and a thickness (A + E)*0.5 instead. This limits
    //      the geometry, but is equivalent (ie. we can reconstruct (A,B,C,D,E,F,G,H)).
    //

    const auto r1 = this-&gt;position(           0,              0);  // = (A + E)*0.5;
    const auto r2 = this-&gt;position(this-&gt;rows-1,              0);  // = (B + F)*0.5;
    const auto r3 = this-&gt;position(this-&gt;rows-1,this-&gt;columns-1);  // = (C + G)*0.5;  
    const auto r4 = this-&gt;position(           0,this-&gt;columns-1);  // = (D + H)*0.5;

    const auto dt = this-&gt;pxl_dz; // = |A-E| == |B-F| == etc..

    const auto A  = r1 + ((r2-r1).Cross(r4-r1)).unit()*(dt*0.5);
    const auto B  = A  + (r2-r1);
    const auto C  = A  + (r3-r1);
    const auto D  = A  + (r4-r1);

    const auto E  = r1 - ((r2-r1).Cross(r4-r1)).unit()*(dt*0.5);
    const auto F  = A  + (r2-r1);
    const auto G  = A  + (r3-r1);
    const auto H  = A  + (r4-r1);

    //Now create planes describing the edges. (Arbitraily) choose outward as the 
    // positive orientation. Once we choose the orientation, we must stick with it.
    std::list&lt;plane&lt;double&gt;&gt; planes;
    planes.push_back(plane&lt;double&gt;( ((B-A).Cross(D-A)).unit(), A ));
    planes.push_back(plane&lt;double&gt;( ((E-A).Cross(B-A)).unit(), A ));
    planes.push_back(plane&lt;double&gt;( ((D-A).Cross(E-A)).unit(), A ));

    planes.push_back(plane&lt;double&gt;( ((C-G).Cross(F-G)).unit(), G ));
    planes.push_back(plane&lt;double&gt;( ((F-G).Cross(H-G)).unit(), G ));
    planes.push_back(plane&lt;double&gt;( ((H-G).Cross(C-G)).unit(), G ));

    //Cycle through planes to see if the point is *above* (as per our out-positive
    // orientation).
    for(auto it = planes.begin(); it != planes.end(); ++it){
        if(it-&gt;Is_Point_Above_Plane(in)) return false;
    }

    return true;

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/</FONT></I>
</PRE>
<HR>
<A NAME="file30">
<H1>YgorMath_Samples.cc 30/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file29">prev</A>][<A HREF="#file31">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorMath_Samples.cc - A few sample things which can be used for testing.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMath.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMath_Samples.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------- contour_of_points ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//These functions are factories which produce contours. They were made using inkscape, outlining some shapes by hand, saving the images as 
</FONT></I><I><FONT COLOR="#B22222">// postscript, and processing the point data directly.
</FONT></I>

<I><FONT COLOR="#B22222">//Blob with a few curls and some higher-frequency juts on the left. Point-density is fairly high on the left side compared with the right side.
</FONT></I>contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points_sample_blob(<B><FONT COLOR="#228B22">void</FONT></B>){
    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out( std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;( { 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(24.449, 361.555, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(32.449, 382.125, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(54.164, 392.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(75.879, 388.984, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(106.734, 364.984, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(157.02, 305.555, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.449, 242.695, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.449, 183.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(302.164, 152.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(386.734, 154.695, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(403.879, 160.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(409.594, 187.84, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(391.309, 217.555, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.164, 234.695, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(294.164, 248.41, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(272.449, 274.695, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.449, 327.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(302.164, 388.984, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(424.449, 403.84, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(518.164, 295.27, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(551.309, 227.84, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(512.449, 123.84, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(443.879, 42.695, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(389.02, 23.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.309, 31.27, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.449, 56.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.879, 56.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.309, 38.125, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.879, 17.555, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(183.309, 0.41, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(146.734, 1.555, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(105.594, 15.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(66.734, 46.125, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(48.449, 91.84, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(37.02, 128.41, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(53.02, 170.695, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(67.879, 183.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(81.594, 191.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(82.734, 201.555, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(77.02, 215.27, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(69.02, 216.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(58.734, 216.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(57.594, 208.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(58.734, 199.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(51.879, 191.27, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(39.309, 190.125, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(32.449, 200.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(32.449, 211.84, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(34.734, 224.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(43.879, 228.984, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(55.309, 236.984, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(55.309, 241.555, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(50.734, 256.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(38.164, 260.984, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(27.879, 258.695, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(15.309, 274.695, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(21.02, 290.695, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(26.734, 299.84, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(31.309, 308.984, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(21.02, 312.41, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(8.449, 311.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(1.594, 324.984, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(3.879, 339.84, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(21.02, 343.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(6.164, 358.125, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(0.449, 376.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(9.594, 388.984, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(22.164, 382.125, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(18.734, 368.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(26.734, 332.984, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(31.309, 337.555, 0.0)
    }));
    out.closed = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//Gumby, waving. Points are mostly distributed evenly (by hand.) There is not much high-frequency detail, but the shape is fairly elongated/stretched.
</FONT></I>contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points_sample_gumby(<B><FONT COLOR="#228B22">void</FONT></B>){
    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out(std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;({  
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(66.141, 0.398, 0.0),  vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(51.855, 2.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(38.711, 7.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(30.711, 15.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(30.141, 28.969, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(37.566, 42.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(43.855, 57.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(51.281, 82.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(55.281, 103.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(60.996, 122.684, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(66.711, 140.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(74.141, 156.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(79.855, 171.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(86.141, 192.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(88.996, 211.824, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(91.281, 228.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(91.281, 244.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(91.855, 254.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(79.855, 247.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(65.566, 235.824, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(53.566, 220.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(44.996, 206.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(39.855, 183.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(35.281, 162.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(26.711, 153.539, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(17.566, 152.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(8.996, 158.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(6.141, 168.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(6.711, 175.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(0.996, 175.824, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(0.426, 183.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(10.141, 191.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(20.426, 198.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(24.996, 213.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(32.996, 228.398, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(43.855, 243.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(54.711, 254.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(64.996, 264.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(78.711, 272.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(90.141, 275.824, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(87.281, 293.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(84.996, 307.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(81.566, 323.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(74.141, 341.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(69.566, 357.539, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(71.281, 372.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(80.426, 378.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(91.855, 379.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(104.996, 371.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(119.281, 364.969, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(133.566, 359.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(140.426, 350.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(142.141, 335.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(142.141, 315.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(140.426, 292.398, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(140.996, 281.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(154.711, 280.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(167.281, 282.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(178.141, 289.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.566, 300.398, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.281, 312.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(194.711, 325.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(194.141, 340.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.855, 353.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.281, 362.109, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.996, 364.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(199.855, 362.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.426, 371.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(212.426, 374.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(221.566, 371.254, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(226.141, 362.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(223.855, 350.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.566, 336.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(213.566, 327.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.996, 310.684, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.855, 294.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(195.855, 281.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.426, 270.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(170.711, 263.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(159.855, 262.109, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(147.281, 260.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(141.566, 260.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(141.566, 216.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(142.141, 200.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(143.281, 179.824, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(142.711, 169.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(148.996, 143.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(154.711, 118.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(159.281, 95.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(162.141, 76.398, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(166.711, 52.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(171.281, 35.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(172.426, 19.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(167.855, 12.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(154.711, 10.109, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(142.141, 10.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(127.281, 12.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(118.711, 19.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(114.711, 28.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(115.855, 45.539, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(120.996, 60.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(122.711, 78.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(123.855, 99.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(124.426, 116.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(120.996, 138.684, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(117.566, 154.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(115.281, 170.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(114.141, 175.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(109.566, 162.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(104.996, 147.254, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(98.711, 124.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(96.426, 106.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(94.711, 84.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(94.711, 66.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(96.996, 48.969, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(99.855, 28.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(99.855, 15.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(94.711, 7.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(82.711, 2.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(73.566, 0.398, 0.0) 
    }));
    out.closed = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//Airplane, viewed from below. Landing gear is visible. Points are distributed unevenly. Long gaps are present in uninteresting parts to simplify contouring.
</FONT></I><I><FONT COLOR="#B22222">// Some high-frequency features are visible, like the tail fins, landing gear, jets.
</FONT></I>contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_of_points_sample_airplane(<B><FONT COLOR="#228B22">void</FONT></B>){
    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out(std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;({  
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(138.688, 197.984, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(137.879, 153.945, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(135.051, 151.52, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(133.031, 141.82, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(86.16, 150.309, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(85.352, 145.457, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(129.797, 126.871, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(130.605, 122.832, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(127.371, 111.922, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(126.16, 101.012, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(126.969, 84.445, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(127.777, 71.516, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(127.777, 63.434, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(96.664, 66.262, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(0.496, 92.527, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(1.305, 88.082, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(7.77, 81.617, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(6.961, 79.598, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(91.008, 51.715, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(90.602, 46.059, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(88.18, 37.977, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(91.41, 25.453, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(98.281, 21.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(104.746, 24.645, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(106.363, 29.09, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(104.746, 40.805, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(102.32, 46.867, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(106.766, 45.656, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(107.473, 38.887, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(110.301, 38.684, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(110.402, 40.805, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(114.848, 41.211, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(114.949, 38.484, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(117.879, 38.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(118.078, 43.23, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(130.203, 40, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(131.008, 20.602, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(134.242, 10.098, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(138.988, 4.137, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(142.227, 2.027, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(145.027, 0.77, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(147.316, 0.406, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(149.738, 1.148, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(152.473, 2.359, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(155.379, 4.922, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(158.082, 10.906, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(160.102, 19.391, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(160.91, 42.02, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(170.609, 43.535, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(171.414, 38.785, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(174.648, 38.785, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(174.547, 41.816, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(178.891, 42.219, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(178.992, 39.391, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.125, 39.594, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(181.82, 46.465, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(186.77, 47.676, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.055, 43.734, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(186.367, 27.473, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(193.641, 24.238, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.871, 25.047, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.508, 27.066, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.914, 44.848, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(198.488, 48.887, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(198.891, 53.734, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(281.723, 86.465, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.918, 89.699, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(286.977, 94.949, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(285.766, 98.586, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.406, 68.281, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(160.508, 64.645, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(158.891, 76.77, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(157.676, 104.242, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(152.828, 121.617, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(150.809, 126.062, 0.0), 
        vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(193.234, 147.074, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(193.234, 153.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(146.77, 143.844, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(143.133, 152.328, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(140.305, 154.75, 0.0) 
    })); 
    out.closed = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------- contour_collection ---------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//A sharp collection of text (&quot;ICCR 2013&quot;) in Knuth's Computer Modern font. The 'R' is composed of two contours. Where required, the original 
</FONT></I><I><FONT COLOR="#B22222">// cubic bezier curves have been sampled in ten positions (t-parameter = 0.0, 0.1, 0.2, ..., 0.9) giving linear line segments. The sampling is
</FONT></I><I><FONT COLOR="#B22222">// quite inconsistent for this reason. The text itself is very crisp, with smooth curls and rigid edges. All text is on the z=0 plane.
</FONT></I><I><FONT COLOR="#B22222">// The data originated from TTF computer modern (CMU in Arch Linux), was exported (using Inkscape) to postscript with text being converted to
</FONT></I><I><FONT COLOR="#B22222">// paths, and then a custom interpretter was written to harvest the curves. The interpretter was written at:
</FONT></I><I><FONT COLOR="#B22222">//  /home/hal/Dropbox/Project - Textbook/other/ICCR_2013/Presentations/Timer2        but it may have been expanded or moved since.
</FONT></I>
contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; contour_collection_sample_ICCR2013(<B><FONT COLOR="#228B22">void</FONT></B>){
    contour_collection&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; ccs;

    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out3( std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;( {
         vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(180.727, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(181.758, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(181.758, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.19, 480.917, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.587, 480.927, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.95, 480.945, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(183.279, 480.97, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(183.573, 481.002, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(183.832, 481.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.057, 481.088, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.247, 481.142, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.403, 481.204, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.523, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.523, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.62, 481.353, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.707, 481.449, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.784, 481.561, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.852, 481.69, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.909, 481.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.955, 481.996, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.992, 482.174, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.018, 482.368, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.034, 482.578, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.039, 482.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.039, 503.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.039, 503.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.034, 504.105, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.018, 504.312, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.992, 504.503, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.955, 504.678, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.908, 504.837, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.852, 504.981, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.784, 505.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.707, 505.221, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.62, 505.317, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.523, 505.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.523, 505.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.403, 505.466, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.247, 505.527, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.057, 505.581, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(183.832, 505.627, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(183.573, 505.667, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(183.279, 505.699, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.95, 505.724, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.587, 505.743, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.19, 505.753, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(181.758, 505.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(180.727, 505.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(180.727, 506.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(180.727, 506.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(181.038, 506.97, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(181.415, 506.951, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(181.859, 506.935, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.37, 506.921, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.948, 506.909, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(183.592, 506.899, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.303, 506.892, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.081, 506.886, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.925, 506.883, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(186.836, 506.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(186.836, 506.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(187.739, 506.883, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.577, 506.886, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.349, 506.892, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.056, 506.899, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.697, 506.909, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.272, 506.921, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.781, 506.935, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(192.224, 506.951, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(192.602, 506.97, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(192.914, 506.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(192.914, 505.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.883, 505.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.883, 505.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.453, 505.753, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.056, 505.743, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.694, 505.724, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.366, 505.699, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.072, 505.667, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.813, 505.627, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.588, 505.581, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.397, 505.527, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.24, 505.466, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.117, 505.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.117, 505.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.019, 505.317, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.931, 505.221, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.854, 505.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.787, 504.981, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.731, 504.837, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.684, 504.678, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.648, 504.503, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.623, 504.312, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.607, 504.105, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.602, 503.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.602, 482.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.602, 482.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.607, 482.578, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.623, 482.368, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.648, 482.174, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.684, 481.996, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.731, 481.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.787, 481.69, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.854, 481.561, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.931, 481.449, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.019, 481.353, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.117, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.117, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.24, 481.204, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.397, 481.142, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.588, 481.088, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.813, 481.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.072, 481.002, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.366, 480.97, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.694, 480.945, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.056, 480.927, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.453, 480.917, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.883, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(192.914, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(192.914, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(192.914, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(192.602, 479.702, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(192.223, 479.723, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.779, 479.742, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.267, 479.758, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.69, 479.772, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.046, 479.784, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.335, 479.792, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.558, 479.799, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(187.715, 479.803, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(186.805, 479.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(186.805, 479.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.9, 479.803, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.062, 479.799, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.289, 479.792, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(183.582, 479.784, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.941, 479.772, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.366, 479.758, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(181.857, 479.742, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(181.414, 479.723, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(181.038, 479.702, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(180.727, 479.679, 0.0)
        }));
out3.closed = true;
ccs.contours.push_back(out3);

 
    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out7( std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;( {
         vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.289, 493.366, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.33, 494.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.454, 495.706, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.66, 496.823, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.949, 497.903, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(197.32, 498.947, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(197.774, 499.956, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(198.31, 500.929, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(198.929, 501.866, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(199.63, 502.767, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.414, 503.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.414, 503.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.254, 504.439, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.124, 505.161, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.027, 505.799, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.96, 506.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.924, 506.819, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(205.92, 507.202, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.946, 507.499, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.004, 507.712, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.092, 507.839, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.211, 507.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.211, 507.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.562, 507.876, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.909, 507.856, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(211.251, 507.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(211.59, 507.779, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(211.925, 507.721, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(212.256, 507.651, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(212.582, 507.567, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(212.905, 507.471, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(213.224, 507.362, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(213.539, 507.241, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(213.539, 507.241, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(213.842, 507.113, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(214.129, 506.987, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(214.399, 506.862, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(214.653, 506.739, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(214.889, 506.618, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.109, 506.498, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.312, 506.38, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.498, 506.264, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.668, 506.15, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.82, 506.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.82, 506.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.966, 505.921, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.119, 505.794, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.279, 505.658, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.444, 505.512, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.616, 505.357, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.795, 505.193, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.979, 505.019, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.17, 504.836, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.367, 504.645, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.57, 504.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.57, 507.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.57, 507.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.634, 507.489, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.699, 507.571, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.763, 507.644, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.828, 507.707, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.892, 507.76, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.956, 507.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.02, 507.838, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.084, 507.862, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.148, 507.877, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.211, 507.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.211, 507.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.273, 507.88, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.33, 507.874, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.381, 507.864, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.427, 507.851, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.468, 507.834, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.503, 507.813, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.532, 507.788, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.556, 507.76, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.574, 507.729, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.586, 507.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.586, 507.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.597, 507.655, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.607, 507.607, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.617, 507.55, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.625, 507.485, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.632, 507.411, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.637, 507.328, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.642, 507.237, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.645, 507.138, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.647, 507.03, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.648, 506.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.648, 497.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.648, 497.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.647, 497.32, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.645, 497.206, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.641, 497.101, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.635, 497.005, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.628, 496.92, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.619, 496.843, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.609, 496.776, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.598, 496.719, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.585, 496.671, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.57, 496.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.57, 496.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.55, 496.602, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.522, 496.575, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.485, 496.552, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.441, 496.531, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.389, 496.514, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.329, 496.5, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.26, 496.49, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.184, 496.482, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.1, 496.478, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.008, 496.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.008, 496.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.933, 496.477, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.864, 496.481, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.801, 496.487, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.744, 496.495, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.694, 496.506, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.651, 496.52, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.613, 496.536, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.582, 496.555, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.557, 496.577, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.539, 496.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.539, 496.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.522, 496.629, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.506, 496.663, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.489, 496.703, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.472, 496.75, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.454, 496.803, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.437, 496.862, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.42, 496.928, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.402, 497, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.385, 497.078, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.367, 497.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.367, 497.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.23, 498.007, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.056, 498.817, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(218.846, 499.593, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(218.6, 500.334, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(218.319, 501.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(218, 501.713, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.646, 502.35, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.256, 502.953, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.83, 503.521, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.367, 504.054, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.367, 504.054, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.879, 504.543, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.373, 504.981, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(214.847, 505.367, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(214.303, 505.702, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(213.74, 505.986, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(213.159, 506.218, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(212.559, 506.399, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(211.94, 506.529, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(211.303, 506.606, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.648, 506.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.648, 506.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.456, 506.63, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.262, 506.623, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.066, 506.612, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.868, 506.597, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.667, 506.577, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.465, 506.553, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.26, 506.524, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.053, 506.491, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.844, 506.454, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.633, 506.413, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.633, 506.413, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.415, 506.363, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.187, 506.3, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(207.95, 506.226, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(207.703, 506.139, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(207.447, 506.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(207.181, 505.93, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.906, 505.807, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.621, 505.672, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.327, 505.525, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.023, 505.366, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.023, 505.366, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(205.72, 505.198, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(205.423, 505.018, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(205.134, 504.828, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.852, 504.627, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.576, 504.415, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.308, 504.192, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.047, 503.959, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.792, 503.715, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.545, 503.46, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.305, 503.194, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.305, 503.194, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.073, 502.91, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.848, 502.602, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.629, 502.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.416, 501.914, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.21, 501.534, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.01, 501.13, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.816, 500.701, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.629, 500.249, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.448, 499.773, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.273, 499.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.273, 499.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.109, 498.754, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.963, 498.219, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.834, 497.666, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.723, 497.097, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.628, 496.51, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.551, 495.906, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.491, 495.285, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.448, 494.647, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.423, 493.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.414, 493.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.414, 493.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.423, 492.654, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.448, 492.005, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.491, 491.372, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.551, 490.755, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.628, 490.153, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.723, 489.567, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.834, 488.997, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.963, 488.443, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.109, 487.904, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.273, 487.382, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.273, 487.382, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.448, 486.879, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.629, 486.4, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.816, 485.946, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.01, 485.517, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.21, 485.112, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.416, 484.732, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.629, 484.377, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.848, 484.047, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.073, 483.741, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.305, 483.46, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.305, 483.46, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.545, 483.196, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.792, 482.942, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.047, 482.699, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.308, 482.466, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.576, 482.244, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.852, 482.032, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(205.134, 481.83, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(205.423, 481.639, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(205.72, 481.458, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.023, 481.288, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.023, 481.288, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.327, 481.131, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.622, 480.986, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.908, 480.853, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(207.184, 480.732, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(207.452, 480.623, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(207.71, 480.526, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(207.959, 480.441, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.198, 480.367, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.428, 480.306, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.648, 480.257, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.648, 480.257, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.865, 480.215, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.079, 480.177, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.291, 480.144, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.499, 480.116, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.706, 480.092, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.909, 480.072, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.11, 480.057, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.308, 480.047, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.503, 480.04, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.695, 480.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.695, 480.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(211.374, 480.062, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(212.037, 480.136, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(212.684, 480.257, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(213.316, 480.428, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(213.932, 480.648, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(214.532, 480.916, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.116, 481.233, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.684, 481.598, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.237, 482.013, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.773, 482.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.773, 482.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.276, 482.979, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.732, 483.517, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(218.14, 484.089, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(218.5, 484.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(218.811, 485.334, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.075, 486.007, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.29, 486.714, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.458, 487.455, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.577, 488.23, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.648, 489.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.648, 489.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.656, 489.077, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.664, 489.113, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.671, 489.147, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.677, 489.179, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.682, 489.208, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.687, 489.235, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.69, 489.26, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.693, 489.282, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.694, 489.302, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.695, 489.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.695, 489.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.695, 489.335, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.696, 489.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.697, 489.367, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.699, 489.384, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.702, 489.401, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.705, 489.418, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.71, 489.436, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.714, 489.454, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.72, 489.472, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.727, 489.491, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.727, 489.491, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.736, 489.512, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.746, 489.531, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.757, 489.548, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.77, 489.565, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.784, 489.579, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.799, 489.593, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.815, 489.605, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.831, 489.615, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.849, 489.624, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.867, 489.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.867, 489.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.889, 489.64, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.912, 489.647, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.936, 489.654, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.961, 489.66, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.987, 489.666, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.014, 489.67, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.042, 489.674, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.071, 489.677, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.102, 489.678, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.133, 489.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.133, 489.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.23, 489.672, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.317, 489.651, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.394, 489.617, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.461, 489.568, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.518, 489.506, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.565, 489.431, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.601, 489.341, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.627, 489.238, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.643, 489.121, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.648, 488.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.648, 488.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.619, 488.238, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.531, 487.496, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.385, 486.766, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.18, 486.048, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.917, 485.342, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.595, 484.648, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.216, 483.965, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(218.778, 483.295, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(218.281, 482.637, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.727, 481.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.727, 481.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.129, 481.385, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.496, 480.844, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.829, 480.365, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.128, 479.951, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(214.393, 479.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(213.625, 479.314, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(212.822, 479.091, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(211.985, 478.931, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(211.115, 478.836, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.211, 478.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.211, 478.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.092, 478.846, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.004, 478.973, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.946, 479.184, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(205.92, 479.479, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.924, 479.859, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.96, 480.323, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.027, 480.871, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.124, 481.504, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.254, 482.221, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.414, 483.023, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.414, 483.023, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(199.63, 483.885, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(198.929, 484.785, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(198.31, 485.723, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(197.774, 486.7, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(197.32, 487.715, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.949, 488.769, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.66, 489.861, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.454, 490.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.33, 492.159, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.289, 493.366, 0.0)
        }));
 out7.closed = true;
ccs.contours.push_back(out7);
    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out11( std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;( {
         vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(225.039, 493.366, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(225.08, 494.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(225.204, 495.706, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(225.41, 496.823, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(225.699, 497.903, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(226.07, 498.947, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(226.524, 499.956, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(227.06, 500.929, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(227.679, 501.866, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(228.38, 502.767, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.164, 503.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.164, 503.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.004, 504.439, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.874, 505.161, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.777, 505.799, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.71, 506.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(233.674, 506.819, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(234.67, 507.202, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(235.696, 507.499, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(236.754, 507.712, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.842, 507.839, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.961, 507.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.961, 507.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.312, 507.876, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.659, 507.856, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(240.001, 507.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(240.34, 507.779, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(240.675, 507.721, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(241.006, 507.651, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(241.332, 507.567, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(241.655, 507.471, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(241.974, 507.362, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(242.289, 507.241, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(242.289, 507.241, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(242.592, 507.113, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(242.879, 506.987, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.149, 506.862, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.403, 506.739, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.639, 506.618, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.859, 506.498, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.062, 506.38, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.248, 506.264, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.418, 506.15, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.57, 506.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.57, 506.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.716, 505.921, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.869, 505.794, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.029, 505.658, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.194, 505.512, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.366, 505.357, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.545, 505.193, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.729, 505.019, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.92, 504.836, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(246.117, 504.645, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(246.32, 504.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.32, 507.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.32, 507.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.384, 507.489, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.449, 507.571, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.513, 507.644, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.578, 507.707, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.642, 507.76, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.706, 507.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.77, 507.838, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.834, 507.862, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.898, 507.877, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.961, 507.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.961, 507.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.023, 507.88, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.08, 507.874, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.131, 507.864, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.177, 507.851, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.218, 507.834, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.253, 507.813, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.282, 507.788, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.306, 507.76, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.324, 507.729, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.336, 507.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.336, 507.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.347, 507.655, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.357, 507.607, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.367, 507.55, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.375, 507.485, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.382, 507.411, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.387, 507.328, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.392, 507.237, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.395, 507.138, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.397, 507.03, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.398, 506.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.398, 497.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.398, 497.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.397, 497.32, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.395, 497.206, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.391, 497.101, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.385, 497.005, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.378, 496.92, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.369, 496.843, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.359, 496.776, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.348, 496.719, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.335, 496.671, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.32, 496.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.32, 496.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.3, 496.602, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.272, 496.575, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.235, 496.552, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.191, 496.531, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.139, 496.514, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.079, 496.5, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.01, 496.49, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.934, 496.482, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.85, 496.478, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.758, 496.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.758, 496.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.683, 496.477, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.614, 496.481, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.551, 496.487, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.494, 496.495, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.444, 496.506, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.401, 496.52, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.363, 496.536, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.332, 496.555, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.307, 496.577, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.289, 496.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.289, 496.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.272, 496.629, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.256, 496.663, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.239, 496.703, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.222, 496.75, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.204, 496.803, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.187, 496.862, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.17, 496.928, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.152, 497, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.135, 497.078, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.117, 497.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.117, 497.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.98, 498.007, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.806, 498.817, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.596, 499.593, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.35, 500.334, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.069, 501.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(246.75, 501.713, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(246.396, 502.35, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(246.006, 502.953, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.58, 503.521, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.117, 504.054, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.117, 504.054, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.629, 504.543, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.123, 504.981, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.597, 505.367, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.053, 505.702, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(242.49, 505.986, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(241.909, 506.218, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(241.309, 506.399, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(240.69, 506.529, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(240.053, 506.606, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.398, 506.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.398, 506.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.206, 506.63, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.012, 506.623, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.816, 506.612, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.618, 506.597, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.417, 506.577, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.215, 506.553, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.01, 506.524, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.803, 506.491, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.594, 506.454, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.383, 506.413, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.383, 506.413, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.165, 506.363, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(236.937, 506.3, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(236.7, 506.226, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(236.453, 506.139, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(236.197, 506.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(235.931, 505.93, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(235.656, 505.807, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(235.371, 505.672, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(235.077, 505.525, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(234.773, 505.366, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(234.773, 505.366, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(234.47, 505.198, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(234.173, 505.018, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(233.884, 504.828, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(233.602, 504.627, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(233.326, 504.415, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(233.058, 504.192, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.797, 503.959, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.542, 503.715, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.295, 503.46, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.055, 503.194, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.055, 503.194, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.823, 502.91, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.598, 502.602, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.379, 502.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.166, 501.914, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.96, 501.534, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.76, 501.13, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.566, 500.701, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.379, 500.249, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.198, 499.773, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.023, 499.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.023, 499.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.859, 498.754, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.713, 498.219, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.584, 497.666, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.473, 497.097, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.378, 496.51, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.301, 495.906, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.241, 495.285, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.198, 494.647, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.173, 493.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.164, 493.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.164, 493.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.173, 492.654, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.198, 492.005, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.241, 491.372, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.301, 490.755, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.378, 490.153, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.473, 489.567, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.584, 488.997, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.713, 488.443, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.859, 487.904, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.023, 487.382, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.023, 487.382, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.198, 486.879, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.379, 486.4, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.566, 485.946, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.76, 485.517, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.96, 485.112, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.166, 484.732, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.379, 484.377, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.598, 484.047, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.823, 483.741, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.055, 483.46, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.055, 483.46, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.295, 483.196, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.542, 482.942, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.797, 482.699, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(233.058, 482.466, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(233.326, 482.244, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(233.602, 482.032, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(233.884, 481.83, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(234.173, 481.639, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(234.47, 481.458, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(234.773, 481.288, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(234.773, 481.288, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(235.077, 481.131, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(235.372, 480.986, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(235.658, 480.853, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(235.934, 480.732, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(236.202, 480.623, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(236.46, 480.526, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(236.709, 480.441, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(236.948, 480.367, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.178, 480.306, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.398, 480.257, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.398, 480.257, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.615, 480.215, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.829, 480.177, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.041, 480.144, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.249, 480.116, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.456, 480.092, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.659, 480.072, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.86, 480.057, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.058, 480.047, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.253, 480.04, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.445, 480.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.445, 480.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(240.124, 480.062, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(240.787, 480.136, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(241.434, 480.257, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(242.066, 480.428, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(242.682, 480.648, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.282, 480.916, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.866, 481.233, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.434, 481.598, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.987, 482.013, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.523, 482.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.523, 482.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(246.026, 482.979, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(246.482, 483.517, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(246.89, 484.089, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.25, 484.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.561, 485.334, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.825, 486.007, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.04, 486.714, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.208, 487.455, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.327, 488.23, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.398, 489.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.398, 489.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.406, 489.077, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.414, 489.113, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.421, 489.147, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.427, 489.179, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.432, 489.208, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.437, 489.235, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.44, 489.26, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.443, 489.282, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.444, 489.302, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.445, 489.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.445, 489.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.445, 489.335, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.446, 489.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.447, 489.367, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.449, 489.384, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.452, 489.401, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.455, 489.418, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.46, 489.436, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.464, 489.454, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.47, 489.472, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.477, 489.491, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.477, 489.491, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.486, 489.512, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.496, 489.531, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.507, 489.548, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.52, 489.565, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.534, 489.579, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.549, 489.593, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.565, 489.605, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.581, 489.615, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.599, 489.624, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.617, 489.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.617, 489.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.639, 489.64, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.662, 489.647, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.686, 489.654, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.711, 489.66, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.737, 489.666, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.764, 489.67, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.792, 489.674, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.821, 489.677, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.852, 489.678, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.883, 489.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.883, 489.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.98, 489.672, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.067, 489.651, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.144, 489.617, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.211, 489.568, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.268, 489.506, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.315, 489.431, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.351, 489.341, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.377, 489.238, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.393, 489.121, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.398, 488.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.398, 488.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.369, 488.238, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.281, 487.496, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.135, 486.766, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.93, 486.048, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.667, 485.342, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.345, 484.648, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.966, 483.965, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.528, 483.295, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.031, 482.637, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(246.477, 481.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(246.477, 481.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.879, 481.385, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.246, 480.844, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.579, 480.365, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.878, 479.951, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.143, 479.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(242.375, 479.314, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(241.572, 479.091, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(240.735, 478.931, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.865, 478.836, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.961, 478.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.961, 478.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.842, 478.846, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(236.754, 478.973, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(235.696, 479.184, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(234.67, 479.479, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(233.674, 479.859, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.71, 480.323, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.777, 480.871, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.874, 481.504, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.004, 482.221, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.164, 483.023, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.164, 483.023, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(228.38, 483.885, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(227.679, 484.785, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(227.06, 485.723, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(226.524, 486.7, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(226.07, 487.715, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(225.699, 488.769, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(225.41, 489.861, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(225.204, 490.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(225.08, 492.159, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(225.039, 493.366, 0.0)
        }));
out11.closed = true;
ccs.contours.push_back(out11);
 
    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out15( std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;( {
         vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(252.961, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(253.914, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(253.914, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(254.328, 480.917, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(254.709, 480.927, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(255.057, 480.945, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(255.372, 480.97, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(255.654, 481.002, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(255.903, 481.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.119, 481.088, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.302, 481.142, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.453, 481.204, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.57, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.57, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.665, 481.353, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.749, 481.449, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.824, 481.561, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.889, 481.69, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.945, 481.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.99, 481.996, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.025, 482.174, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.05, 482.368, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.065, 482.578, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.07, 482.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.07, 503.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.07, 503.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.065, 504.105, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.05, 504.312, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.025, 504.503, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.99, 504.678, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.945, 504.837, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.889, 504.981, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.824, 505.109, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.749, 505.221, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.665, 505.317, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.57, 505.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.57, 505.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.453, 505.466, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.302, 505.527, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.119, 505.581, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(255.903, 505.627, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(255.654, 505.667, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(255.372, 505.699, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(255.057, 505.724, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(254.709, 505.743, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(254.328, 505.753, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(253.914, 505.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(252.961, 505.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(252.961, 506.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.508, 506.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.508, 506.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.366, 506.97, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.198, 506.905, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.004, 506.798, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.784, 506.648, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.538, 506.455, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.265, 506.22, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.967, 505.942, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.642, 505.621, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(272.291, 505.257, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(272.914, 504.851, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(272.914, 504.851, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.492, 504.418, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.009, 503.968, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.466, 503.503, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.862, 503.022, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.198, 502.525, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.472, 502.012, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.686, 501.484, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.839, 500.94, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.93, 500.38, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.961, 499.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.961, 499.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.941, 499.359, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.881, 498.923, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.782, 498.497, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.643, 498.081, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.464, 497.674, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.246, 497.278, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.988, 496.891, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.69, 496.513, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.353, 496.146, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.977, 495.788, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.977, 495.788, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.569, 495.447, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.14, 495.127, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(272.691, 494.825, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(272.22, 494.544, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.729, 494.283, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.217, 494.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.684, 493.819, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.131, 493.617, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.556, 493.435, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.961, 493.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.961, 493.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.721, 492.982, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.42, 492.652, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.059, 492.283, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.637, 491.877, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(272.154, 491.431, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(272.612, 490.948, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.009, 490.426, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.345, 489.866, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.621, 489.268, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.836, 488.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.352, 485.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.352, 485.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.382, 485.216, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.411, 484.999, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.439, 484.794, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.465, 484.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.491, 484.42, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.516, 484.251, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.539, 484.093, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.562, 483.948, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.582, 483.815, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.602, 483.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.602, 483.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.624, 483.576, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.647, 483.453, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.671, 483.327, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.697, 483.195, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.725, 483.06, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.754, 482.92, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.784, 482.776, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.816, 482.628, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.849, 482.475, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.883, 482.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.883, 482.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.919, 482.164, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.956, 482.016, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.992, 481.877, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.028, 481.746, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.064, 481.623, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.1, 481.508, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.136, 481.402, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.171, 481.304, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.207, 481.214, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.242, 481.132, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.242, 481.132, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.279, 481.057, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.319, 480.981, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.361, 480.904, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.405, 480.827, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.451, 480.749, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.5, 480.67, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.55, 480.591, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.602, 480.512, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.655, 480.431, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.711, 480.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.711, 480.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.767, 480.275, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.825, 480.204, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.885, 480.138, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.946, 480.076, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.009, 480.02, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.074, 479.97, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.141, 479.924, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.21, 479.884, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.28, 479.849, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.352, 479.819, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.352, 479.819, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.425, 479.792, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.5, 479.769, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.578, 479.748, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.658, 479.73, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.741, 479.714, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.827, 479.701, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.915, 479.692, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.006, 479.685, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.099, 479.68, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.195, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.195, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.378, 479.687, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.558, 479.711, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.735, 479.752, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.909, 479.808, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.081, 479.881, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.249, 479.971, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.416, 480.076, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.579, 480.198, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.74, 480.336, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.898, 480.491, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.898, 480.491, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.048, 480.667, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.185, 480.866, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.31, 481.086, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.422, 481.328, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.522, 481.592, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.61, 481.878, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.685, 482.186, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.748, 482.516, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.798, 482.868, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.836, 483.241, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.836, 483.241, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.855, 483.362, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.88, 483.471, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.911, 483.567, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.95, 483.651, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.995, 483.721, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.046, 483.779, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.105, 483.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.17, 483.856, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.241, 483.876, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.32, 483.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.32, 483.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.417, 483.875, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.504, 483.854, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.581, 483.82, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.649, 483.771, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.706, 483.709, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.752, 483.634, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.789, 483.544, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.815, 483.441, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.831, 483.324, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.836, 483.194, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.836, 483.194, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.834, 483.09, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.829, 482.982, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.82, 482.872, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.808, 482.758, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.792, 482.642, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.773, 482.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.751, 482.402, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.725, 482.278, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.696, 482.152, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.664, 482.023, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.664, 482.023, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.63, 481.89, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.592, 481.756, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.549, 481.619, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.503, 481.48, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.451, 481.338, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.396, 481.195, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.336, 481.049, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.273, 480.902, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.205, 480.752, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.133, 480.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.133, 480.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.053, 480.45, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.965, 480.304, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.867, 480.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.76, 480.028, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.644, 479.897, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.519, 479.771, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.385, 479.651, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.242, 479.535, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.091, 479.425, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.93, 479.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.93, 479.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.764, 479.222, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.593, 479.135, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.417, 479.058, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.236, 478.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.049, 478.934, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.857, 478.888, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.66, 478.851, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.458, 478.825, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.251, 478.809, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.039, 478.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.039, 478.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.425, 478.821, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.836, 478.871, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.27, 478.955, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.729, 479.072, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.212, 479.222, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.72, 479.406, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.251, 479.624, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(272.807, 479.874, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(272.388, 480.158, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.992, 480.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.992, 480.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.837, 480.621, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.691, 480.771, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.553, 480.925, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.424, 481.085, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.304, 481.248, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.193, 481.416, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.09, 481.589, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.997, 481.765, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.912, 481.947, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.836, 482.132, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.836, 482.132, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.766, 482.32, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.703, 482.503, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.645, 482.683, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.594, 482.858, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.549, 483.028, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.51, 483.195, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.477, 483.357, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.45, 483.515, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.429, 483.669, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.414, 483.819, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.414, 483.819, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.402, 483.975, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.391, 484.149, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.382, 484.341, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.374, 484.551, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.367, 484.78, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.361, 485.027, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.357, 485.291, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.354, 485.574, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.353, 485.875, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.352, 486.194, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.352, 486.194, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.349, 486.646, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.342, 487.072, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.329, 487.472, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.311, 487.846, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.288, 488.193, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.261, 488.514, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.228, 488.809, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.191, 489.078, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.149, 489.321, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.102, 489.538, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.102, 489.538, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.047, 489.741, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.976, 489.943, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.889, 490.145, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.786, 490.347, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.667, 490.549, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.532, 490.75, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.381, 490.952, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.215, 491.153, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.033, 491.353, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.836, 491.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.836, 491.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.545, 491.811, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.237, 492.042, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.91, 492.245, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.565, 492.422, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.202, 492.572, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.821, 492.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.422, 492.79, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.005, 492.858, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.57, 492.899, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.117, 492.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.508, 492.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.508, 482.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.508, 482.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.513, 482.578, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.528, 482.368, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.552, 482.174, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.587, 481.996, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.632, 481.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.687, 481.69, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.752, 481.561, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.827, 481.449, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.912, 481.353, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.008, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.008, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.124, 481.204, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.274, 481.142, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.458, 481.088, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.674, 481.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.925, 481.002, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(262.209, 480.97, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(262.526, 480.945, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(262.877, 480.927, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(263.262, 480.917, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(263.68, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.633, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.633, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.633, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.315, 479.702, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(263.938, 479.723, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(263.501, 479.742, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(263.006, 479.758, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(262.451, 479.772, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.837, 479.784, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.164, 479.792, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.431, 479.799, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(259.64, 479.803, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(258.789, 479.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(258.789, 479.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.94, 479.803, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.15, 479.799, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.419, 479.792, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(255.747, 479.784, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(255.135, 479.772, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(254.582, 479.758, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(254.088, 479.742, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(253.653, 479.723, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(253.278, 479.702, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(252.961, 479.679, 0.0)
        }));
 
out15.closed = true;
ccs.contours.push_back(out15);

    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out19( std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;( {
         vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.522, 493.776, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.961, 493.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.961, 493.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.375, 493.809, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.776, 493.825, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.164, 493.85, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.538, 493.886, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.9, 493.933, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.248, 493.99, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.583, 494.056, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.905, 494.134, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.213, 494.221, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.508, 494.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.508, 494.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.79, 494.425, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.056, 494.541, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.308, 494.665, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.544, 494.798, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.764, 494.939, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.969, 495.089, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.158, 495.248, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.332, 495.414, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.49, 495.59, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.633, 495.773, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.633, 495.773, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.766, 495.963, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.89, 496.152, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.005, 496.342, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.112, 496.531, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.21, 496.721, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.299, 496.91, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.38, 497.099, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.452, 497.287, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.515, 497.475, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.57, 497.663, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.57, 497.663, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.62, 497.852, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.665, 498.047, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.705, 498.247, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.74, 498.453, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.769, 498.665, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.793, 498.881, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.812, 499.104, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.825, 499.332, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.833, 499.565, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.836, 499.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.836, 499.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.833, 500.079, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.823, 500.346, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.806, 500.608, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.782, 500.863, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.753, 501.111, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.716, 501.353, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.674, 501.589, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.625, 501.818, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.569, 502.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.508, 502.257, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.508, 502.257, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.441, 502.465, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.367, 502.663, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.285, 502.853, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.196, 503.034, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.1, 503.206, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.997, 503.369, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.886, 503.522, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.767, 503.667, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.641, 503.803, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.508, 503.929, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.508, 503.929, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.373, 504.051, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.238, 504.169, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.103, 504.283, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.967, 504.392, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.831, 504.497, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.695, 504.598, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.558, 504.695, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.422, 504.788, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.285, 504.876, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.148, 504.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.148, 504.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.009, 505.039, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.863, 505.112, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.709, 505.181, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.547, 505.244, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.378, 505.303, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.2, 505.357, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.015, 505.406, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.823, 505.45, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.622, 505.489, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.414, 505.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.414, 505.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.204, 505.552, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.001, 505.579, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.806, 505.604, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.617, 505.626, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.435, 505.646, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.261, 505.663, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.093, 505.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.933, 505.691, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.779, 505.702, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.633, 505.71, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.633, 505.71, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.484, 505.718, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.327, 505.725, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.161, 505.732, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.987, 505.738, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.803, 505.744, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.612, 505.748, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.411, 505.752, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.202, 505.755, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(263.984, 505.756, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(263.758, 505.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(263.758, 505.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(263.38, 505.756, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(263.033, 505.754, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(262.718, 505.75, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(262.434, 505.744, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(262.182, 505.737, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.962, 505.728, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.773, 505.718, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.616, 505.707, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.491, 505.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.398, 505.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.398, 505.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.313, 505.668, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.232, 505.653, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.157, 505.635, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.087, 505.614, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.021, 505.589, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.961, 505.56, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.906, 505.529, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.857, 505.493, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.812, 505.455, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.773, 505.413, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.773, 505.413, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.739, 505.368, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.708, 505.324, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.679, 505.279, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.653, 505.233, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.63, 505.188, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.61, 505.142, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.592, 505.097, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.577, 505.051, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.565, 505.006, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.555, 504.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.555, 504.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.546, 504.91, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.538, 504.853, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.531, 504.789, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.525, 504.719, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.519, 504.642, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.515, 504.559, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.512, 504.469, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.51, 504.373, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.508, 504.271, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.508, 504.163, 0.0)
        }));
out19.closed = true;
ccs.contours.push_back(out19);

 
    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out23( std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;( {
         vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.367, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.368, 479.817, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.369, 479.945, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.372, 480.063, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.377, 480.172, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.382, 480.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.389, 480.359, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.397, 480.438, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.407, 480.507, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.418, 480.567, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.43, 480.616, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.43, 480.616, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.444, 480.661, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.464, 480.708, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.488, 480.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.518, 480.808, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.553, 480.862, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.593, 480.918, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.638, 480.976, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.689, 481.036, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.744, 481.098, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.805, 481.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(304.492, 489.726, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(304.492, 489.726, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(305.287, 490.663, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(305.999, 491.588, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.627, 492.501, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.171, 493.402, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.632, 494.291, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.009, 495.167, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.303, 496.032, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.512, 496.885, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.638, 497.725, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.68, 498.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.68, 498.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.666, 499.083, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.623, 499.597, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.553, 500.096, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.454, 500.58, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.327, 501.049, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.172, 501.502, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.989, 501.941, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.778, 502.364, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.539, 502.771, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.273, 503.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.273, 503.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.983, 503.527, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.669, 503.854, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.332, 504.142, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(305.972, 504.392, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(305.588, 504.603, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(305.181, 504.777, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(304.751, 504.911, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(304.297, 505.008, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(303.82, 505.066, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(303.32, 505.085, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(303.32, 505.085, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(302.972, 505.074, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(302.63, 505.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(302.293, 504.986, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(301.962, 504.909, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(301.635, 504.811, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(301.315, 504.69, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(301, 504.548, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.69, 504.384, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.385, 504.198, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.086, 503.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.086, 503.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.797, 503.767, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.524, 503.526, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.267, 503.268, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.027, 502.993, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.803, 502.701, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.595, 502.392, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.404, 502.067, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.23, 501.725, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.072, 501.366, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.93, 500.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.93, 500.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.957, 500.999, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.99, 501.007, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.028, 501.013, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.072, 501.02, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.12, 501.025, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.175, 501.03, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.234, 501.033, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.299, 501.036, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.369, 501.037, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.445, 501.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.445, 501.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.64, 501.032, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.827, 501.013, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.005, 500.981, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.174, 500.937, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.335, 500.881, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.487, 500.812, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.631, 500.731, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.765, 500.637, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.891, 500.531, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.008, 500.413, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.008, 500.413, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.114, 500.289, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.209, 500.16, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.293, 500.026, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.366, 499.887, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.428, 499.744, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.479, 499.596, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.519, 499.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.547, 499.287, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.564, 499.126, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.57, 498.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.57, 498.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.563, 498.75, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.542, 498.55, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.506, 498.362, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.456, 498.184, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.393, 498.017, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.315, 497.862, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.224, 497.717, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.119, 497.584, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300, 497.462, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.867, 497.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.867, 497.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.727, 497.253, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.587, 497.165, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.447, 497.088, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.309, 497.021, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.171, 496.964, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.034, 496.918, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.897, 496.881, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.761, 496.856, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.626, 496.84, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.492, 496.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.492, 496.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.435, 496.836, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.376, 496.837, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.316, 496.84, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.254, 496.845, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.191, 496.85, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.126, 496.857, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.06, 496.865, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.992, 496.875, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.923, 496.886, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.852, 496.898, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.852, 496.898, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.777, 496.915, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.698, 496.942, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.616, 496.979, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.529, 497.027, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.439, 497.085, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.345, 497.152, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.247, 497.23, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.145, 497.318, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.039, 497.415, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.93, 497.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.93, 497.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.823, 497.639, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.727, 497.764, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.643, 497.898, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.57, 498.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.508, 498.193, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.457, 498.353, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.418, 498.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.39, 498.702, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.373, 498.889, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.367, 499.085, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.367, 499.085, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.388, 499.638, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.451, 500.18, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.557, 500.71, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.705, 501.229, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.894, 501.736, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.126, 502.232, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.401, 502.717, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.717, 503.189, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.076, 503.651, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.477, 504.101, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.477, 504.101, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.913, 504.522, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.371, 504.898, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.852, 505.231, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.355, 505.519, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.882, 505.764, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(301.431, 505.963, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(302.002, 506.119, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(302.596, 506.23, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(303.213, 506.297, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(303.852, 506.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(303.852, 506.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(304.573, 506.297, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(305.268, 506.231, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(305.938, 506.122, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.583, 505.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.202, 505.772, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.796, 505.531, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.364, 505.247, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.906, 504.919, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.423, 504.547, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.914, 504.132, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.914, 504.132, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.371, 503.685, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.779, 503.213, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.14, 502.717, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.453, 502.196, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.718, 501.651, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.934, 501.08, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.103, 500.486, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.224, 499.866, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.296, 499.222, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.32, 498.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.32, 498.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.316, 498.317, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.306, 498.082, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.287, 497.849, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.262, 497.618, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.23, 497.388, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.19, 497.161, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.144, 496.936, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.09, 496.713, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.029, 496.492, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.961, 496.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.961, 496.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.887, 496.06, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.811, 495.851, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.733, 495.646, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.652, 495.447, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.569, 495.252, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.483, 495.062, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.395, 494.876, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.305, 494.696, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.212, 494.521, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.117, 494.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.117, 494.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.015, 494.179, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.897, 493.998, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.762, 493.806, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.612, 493.604, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.445, 493.392, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.261, 493.17, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.062, 492.938, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.846, 492.695, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.615, 492.442, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.367, 492.179, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.367, 492.179, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.113, 491.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.863, 491.655, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.618, 491.405, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.378, 491.162, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.143, 490.927, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.912, 490.7, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.687, 490.48, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.466, 490.268, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.25, 490.063, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.039, 489.866, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.039, 489.866, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.82, 489.664, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.575, 489.441, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.303, 489.197, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.006, 488.93, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(305.683, 488.642, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(305.334, 488.333, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(304.959, 488.003, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(304.559, 487.65, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(304.132, 487.277, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(303.68, 486.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.445, 482.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.648, 482.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.648, 482.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.318, 482.76, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.923, 482.77, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.465, 482.786, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.942, 482.809, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.354, 482.839, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.702, 482.875, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.985, 482.918, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.203, 482.967, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.356, 483.023, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.445, 483.085, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.445, 483.085, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.527, 483.219, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.61, 483.401, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.694, 483.633, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.78, 483.914, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.867, 484.245, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.955, 484.624, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.044, 485.052, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.135, 485.53, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.227, 486.056, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.32, 486.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.32, 486.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.211, 479.679, 0.0)
        }));
out23.closed = true;
ccs.contours.push_back(out23);

 
    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out27( std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;( {
         vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(315.852, 492.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(315.867, 493.627, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(315.911, 494.723, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(315.985, 495.766, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(316.089, 496.755, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(316.222, 497.69, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(316.385, 498.571, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(316.578, 499.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(316.801, 500.171, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(317.053, 500.889, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(317.336, 501.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(317.336, 501.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(317.779, 502.459, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(318.278, 503.269, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(318.834, 503.984, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.445, 504.603, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.112, 505.127, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.836, 505.556, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.615, 505.89, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.451, 506.128, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.342, 506.271, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.289, 506.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.289, 506.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.498, 506.316, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.708, 506.307, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.919, 506.293, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.13, 506.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.342, 506.248, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.556, 506.216, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.769, 506.18, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.984, 506.138, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.199, 506.091, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.414, 506.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.414, 506.038, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.632, 505.974, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.856, 505.893, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.086, 505.797, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.322, 505.685, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.564, 505.557, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.813, 505.412, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.067, 505.253, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.328, 505.077, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.595, 504.886, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.867, 504.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.867, 504.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.136, 504.456, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.395, 504.22, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.643, 503.97, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.881, 503.706, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(330.108, 503.428, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(330.325, 503.137, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(330.531, 502.832, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(330.727, 502.513, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(330.912, 502.181, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(331.086, 501.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(331.086, 501.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(331.391, 501.131, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(331.664, 500.375, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(331.905, 499.567, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.115, 498.709, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.292, 497.798, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.437, 496.837, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.55, 495.823, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.63, 494.759, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.679, 493.643, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.695, 492.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.695, 492.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.68, 491.333, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.636, 490.243, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.561, 489.207, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.457, 488.224, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.323, 487.294, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.16, 486.417, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(331.967, 485.594, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(331.745, 484.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(331.493, 484.107, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(331.211, 483.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(331.211, 483.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(330.753, 482.562, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(330.242, 481.774, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.678, 481.078, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.06, 480.475, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.39, 479.964, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.666, 479.546, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.89, 479.222, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.06, 478.99, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.178, 478.85, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.242, 478.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.242, 478.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.882, 478.813, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.521, 478.841, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.16, 478.886, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.798, 478.95, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.436, 479.032, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.073, 479.131, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.709, 479.249, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.345, 479.385, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.981, 479.539, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.617, 479.71, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.617, 479.71, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.26, 479.907, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.917, 480.129, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.587, 480.378, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.271, 480.652, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(318.967, 480.952, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(318.677, 481.277, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(318.4, 481.628, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(318.136, 482.005, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(317.886, 482.407, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(317.648, 482.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(317.648, 482.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(317.306, 483.529, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(317.001, 484.284, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(316.731, 485.098, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(316.498, 485.973, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(316.3, 486.907, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(316.139, 487.901, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(316.013, 488.955, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(315.924, 490.069, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(315.87, 491.243, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(315.852, 492.476, 0.0)
        }));
out27.closed = true;
ccs.contours.push_back(out27);

 
    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out31( std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;( {
         vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.164, 492.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.168, 491.787, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.181, 490.687, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.203, 489.66, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.234, 488.706, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.273, 487.826, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.321, 487.018, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.378, 486.284, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.444, 485.624, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.519, 485.037, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.602, 484.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.602, 484.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.707, 484.015, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.829, 483.537, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.968, 483.089, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.125, 482.67, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.299, 482.282, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.49, 481.923, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.699, 481.594, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.925, 481.296, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.169, 481.027, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.43, 480.788, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.43, 480.788, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.7, 480.577, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.972, 480.388, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.246, 480.221, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.524, 480.077, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.804, 479.955, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.086, 479.856, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.371, 479.778, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.659, 479.723, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.949, 479.69, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.242, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.242, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.56, 479.691, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.873, 479.727, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.181, 479.787, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.483, 479.871, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.78, 479.979, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.071, 480.111, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.356, 480.267, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.637, 480.448, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.911, 480.653, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.18, 480.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.18, 480.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.439, 481.136, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.679, 481.418, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.9, 481.728, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.103, 482.066, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.287, 482.432, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.453, 482.825, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.6, 483.247, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.729, 483.696, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.839, 484.174, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.93, 484.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.93, 484.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.012, 485.223, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.086, 485.83, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.152, 486.5, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.209, 487.233, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.257, 488.03, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.296, 488.89, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.327, 489.813, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.349, 490.799, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.363, 491.848, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.367, 492.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.367, 492.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.363, 494.039, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.351, 495.051, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.331, 495.997, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.304, 496.876, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.268, 497.689, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.225, 498.436, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.175, 499.115, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.116, 499.729, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.05, 500.276, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.977, 500.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.977, 500.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.861, 501.263, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.728, 501.737, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.578, 502.18, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.41, 502.591, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.225, 502.971, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.022, 503.32, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.802, 503.637, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.565, 503.922, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.311, 504.176, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.039, 504.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.039, 504.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.76, 504.596, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.481, 504.774, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.201, 504.93, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.922, 505.066, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.642, 505.182, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.362, 505.276, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.082, 505.349, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.802, 505.402, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.522, 505.433, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.242, 505.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.242, 505.444, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.138, 505.442, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.033, 505.437, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.928, 505.428, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.821, 505.416, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.713, 505.401, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.605, 505.382, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.495, 505.36, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.386, 505.334, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.275, 505.305, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.164, 505.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.164, 505.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.049, 505.238, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.929, 505.198, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.805, 505.153, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.675, 505.101, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.541, 505.045, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.403, 504.982, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.26, 504.915, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.113, 504.842, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.961, 504.763, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.805, 504.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.805, 504.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.647, 504.584, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.493, 504.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.341, 504.353, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.194, 504.217, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.05, 504.067, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.909, 503.904, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.772, 503.727, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.639, 503.537, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.509, 503.333, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.383, 503.116, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.383, 503.116, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.264, 502.886, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.152, 502.644, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.046, 502.392, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.947, 502.128, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.854, 501.854, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.768, 501.569, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.689, 501.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.616, 500.966, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.551, 500.648, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.492, 500.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.492, 500.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.43, 499.857, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.374, 499.334, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.325, 498.751, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.282, 498.106, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.246, 497.4, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.216, 496.633, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.193, 495.806, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.177, 494.918, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.167, 493.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.164, 492.96, 0.0)
        }));
out31.closed = true;
ccs.contours.push_back(out31);

 
    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out35( std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;( {
         vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(337.852, 503.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(337.852, 503.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(338.788, 503.783, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(339.677, 503.859, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(340.521, 503.987, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(341.318, 504.166, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.07, 504.397, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.775, 504.678, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(343.434, 505.011, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(344.047, 505.396, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(344.613, 505.832, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.133, 506.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.133, 506.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.261, 506.317, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.379, 506.312, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.485, 506.303, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.581, 506.291, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.666, 506.276, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.74, 506.257, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.804, 506.235, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.857, 506.209, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.899, 506.18, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.93, 506.148, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.93, 506.148, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.953, 506.111, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.974, 506.062, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.993, 506.002, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.009, 505.931, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.023, 505.849, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.035, 505.756, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.043, 505.652, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.05, 505.537, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.054, 505.41, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.055, 505.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.055, 482.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.055, 482.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.061, 482.602, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.078, 482.386, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.107, 482.188, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.147, 482.006, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.199, 481.841, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.262, 481.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.337, 481.563, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.424, 481.45, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.523, 481.353, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.633, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.633, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.768, 481.204, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.942, 481.142, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(347.157, 481.088, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(347.411, 481.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(347.705, 481.002, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(348.039, 480.97, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(348.413, 480.945, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(348.826, 480.927, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(349.28, 480.917, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(349.773, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(351.055, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(351.055, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(351.055, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(350.737, 479.702, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(350.345, 479.723, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(349.88, 479.742, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(349.341, 479.758, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(348.729, 479.772, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(348.044, 479.784, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(347.285, 479.792, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.453, 479.799, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.548, 479.803, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(344.57, 479.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(344.57, 479.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(343.591, 479.803, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.685, 479.799, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(341.853, 479.792, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(341.094, 479.784, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(340.409, 479.772, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(339.797, 479.758, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(339.258, 479.742, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(338.794, 479.723, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(338.403, 479.702, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(338.086, 479.679, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(338.086, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(339.367, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(339.367, 480.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(339.851, 480.917, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(340.296, 480.927, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(340.702, 480.945, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(341.071, 480.97, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(341.401, 481.002, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(341.693, 481.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(341.946, 481.088, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.161, 481.142, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.338, 481.204, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.477, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.477, 481.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.592, 481.353, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.695, 481.45, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.786, 481.563, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.865, 481.694, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.932, 481.841, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.987, 482.006, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(343.03, 482.188, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(343.061, 482.386, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(343.08, 482.602, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(343.086, 482.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(343.086, 503.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(343.086, 503.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.659, 503.358, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.211, 503.183, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(341.741, 503.028, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(341.25, 502.894, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(340.737, 502.781, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(340.203, 502.688, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(339.647, 502.616, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(339.07, 502.564, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(338.472, 502.533, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(337.852, 502.523, 0.0)
        }));
out35.closed = true;
ccs.contours.push_back(out35);

 
    contour_of_points&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out39( std::list&lt;vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;( {
         vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(355.977, 485.085, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(355.984, 485.316, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.004, 485.534, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.037, 485.74, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.084, 485.934, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.144, 486.115, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.218, 486.284, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.305, 486.441, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.406, 486.585, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.52, 486.716, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.648, 486.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.648, 486.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.787, 486.941, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.93, 487.036, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.076, 487.12, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.227, 487.193, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.381, 487.256, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.539, 487.307, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.701, 487.347, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.867, 487.375, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.037, 487.392, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.211, 487.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.211, 487.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.392, 487.392, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.569, 487.373, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.74, 487.342, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.905, 487.299, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.066, 487.244, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.221, 487.177, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.371, 487.097, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.516, 487.006, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.655, 486.903, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.789, 486.788, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.789, 486.788, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.913, 486.664, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.024, 486.532, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.122, 486.391, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.207, 486.241, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.28, 486.083, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.339, 485.916, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.385, 485.74, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.418, 485.556, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.438, 485.364, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.445, 485.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.445, 485.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.437, 484.943, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.414, 484.733, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.375, 484.532, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.32, 484.342, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.25, 484.162, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.164, 483.992, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.062, 483.832, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.945, 483.682, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.812, 483.542, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.664, 483.413, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.664, 483.413, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.504, 483.299, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.338, 483.2, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.167, 483.116, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.99, 483.048, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.806, 482.995, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.618, 482.957, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.423, 482.935, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.223, 482.928, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.017, 482.936, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.805, 482.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.805, 482.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.006, 482.65, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.223, 482.357, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.455, 482.081, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.704, 481.822, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.968, 481.581, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.247, 481.356, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.543, 481.149, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.854, 480.96, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.18, 480.787, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.523, 480.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.523, 480.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.875, 480.495, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.224, 480.373, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.571, 480.265, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.915, 480.171, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.257, 480.092, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.597, 480.028, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.934, 479.977, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.268, 479.942, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.601, 479.92, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.93, 479.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.93, 479.913, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.27, 479.928, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.603, 479.972, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.93, 480.046, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.251, 480.15, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.565, 480.283, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.872, 480.446, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.174, 480.639, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.468, 480.862, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.757, 481.115, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.039, 481.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.039, 481.398, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.305, 481.716, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.544, 482.077, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.755, 482.481, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.937, 482.929, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.092, 483.42, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.219, 483.954, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.318, 484.531, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.388, 485.152, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.431, 485.816, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.445, 486.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.445, 486.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.433, 487.125, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.397, 487.701, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.337, 488.252, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.252, 488.777, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.144, 489.276, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.011, 489.749, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.855, 490.196, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.675, 490.617, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.47, 491.013, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.242, 491.382, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.242, 491.382, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.992, 491.72, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.719, 492.022, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.423, 492.289, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.103, 492.52, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.76, 492.716, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.394, 492.877, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.004, 493.002, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.591, 493.091, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.155, 493.145, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.695, 493.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.93, 493.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.93, 493.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.814, 493.163, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.707, 493.165, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.608, 493.167, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.518, 493.171, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.435, 493.175, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.361, 493.18, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.295, 493.186, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.238, 493.193, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.189, 493.201, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.148, 493.21, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.148, 493.21, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.115, 493.225, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.085, 493.245, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.059, 493.27, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.037, 493.301, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.019, 493.338, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.003, 493.38, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.992, 493.427, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.984, 493.48, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.979, 493.538, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.977, 493.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.977, 493.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.983, 493.676, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361, 493.744, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.03, 493.808, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.071, 493.865, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.124, 493.916, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.189, 493.962, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.266, 494.002, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.355, 494.036, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.457, 494.063, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.57, 494.085, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.57, 494.085, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.692, 494.086, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.822, 494.089, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.959, 494.095, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.104, 494.102, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.256, 494.112, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.416, 494.124, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.584, 494.138, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.759, 494.154, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.942, 494.173, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.133, 494.194, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.133, 494.194, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.584, 494.229, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.014, 494.302, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.423, 494.413, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.811, 494.563, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.178, 494.752, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.523, 494.979, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.848, 495.244, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.151, 495.549, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.434, 495.892, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.695, 496.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.695, 496.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.906, 496.658, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.094, 497.059, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.261, 497.476, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.405, 497.909, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.527, 498.357, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.627, 498.822, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.705, 499.302, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.761, 499.797, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.794, 500.308, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.805, 500.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.805, 500.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.793, 501.307, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.759, 501.751, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.701, 502.167, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.619, 502.555, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.515, 502.915, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.388, 503.246, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.237, 503.549, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.064, 503.824, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.868, 504.07, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.648, 504.288, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.648, 504.288, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.413, 504.483, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.17, 504.658, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.92, 504.812, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.664, 504.946, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.4, 505.06, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.13, 505.153, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.852, 505.226, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.567, 505.277, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.276, 505.309, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.977, 505.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.977, 505.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.694, 505.313, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.408, 505.296, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.12, 505.267, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.828, 505.226, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.534, 505.174, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.237, 505.11, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.937, 505.035, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.635, 504.948, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.33, 504.85, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.023, 504.741, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.023, 504.741, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.723, 504.618, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.437, 504.479, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.165, 504.326, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.906, 504.158, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.662, 503.974, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.431, 503.776, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.214, 503.563, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.011, 503.335, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.823, 503.093, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.648, 502.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.648, 502.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.119, 502.815, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.541, 502.755, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.914, 502.655, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.237, 502.515, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.51, 502.334, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.734, 502.114, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.909, 501.854, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.033, 501.554, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.108, 501.215, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.133, 500.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.133, 500.835, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.127, 500.662, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.11, 500.496, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.082, 500.335, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.042, 500.181, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.991, 500.032, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.928, 499.89, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.855, 499.754, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.771, 499.624, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.676, 499.5, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.57, 499.382, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.57, 499.382, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.454, 499.272, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.331, 499.173, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.2, 499.086, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.062, 499.011, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.917, 498.948, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.765, 498.896, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.606, 498.856, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.44, 498.827, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.266, 498.81, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.086, 498.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.086, 498.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.913, 498.809, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.747, 498.826, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.586, 498.853, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.432, 498.891, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.283, 498.94, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.141, 499, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.005, 499.071, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.875, 499.153, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.751, 499.247, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.633, 499.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.633, 499.351, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.523, 499.467, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.424, 499.59, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.337, 499.723, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.262, 499.864, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.199, 500.013, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.147, 500.17, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.107, 500.336, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.078, 500.51, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.061, 500.692, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.055, 500.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.055, 500.882, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.075, 501.331, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.136, 501.765, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.237, 502.186, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.379, 502.593, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.562, 502.986, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.785, 503.365, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.049, 503.73, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.354, 504.081, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.7, 504.418, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.086, 504.741, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.086, 504.741, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.505, 505.041, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.942, 505.309, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.399, 505.545, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.875, 505.75, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.371, 505.924, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.885, 506.066, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.418, 506.177, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.971, 506.256, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.542, 506.303, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.133, 506.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.133, 506.319, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.715, 506.303, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.283, 506.256, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.836, 506.178, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.374, 506.068, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.897, 505.928, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.405, 505.756, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.899, 505.553, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.377, 505.318, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.841, 505.053, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.289, 504.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.289, 504.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.707, 504.436, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.081, 504.098, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.411, 503.744, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.697, 503.373, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.94, 502.986, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.138, 502.582, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.293, 502.162, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.404, 501.726, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.47, 501.273, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.492, 500.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.492, 500.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.476, 500.336, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.429, 499.876, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.351, 499.424, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.241, 498.981, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.101, 498.545, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.929, 498.118, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.726, 497.699, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.491, 497.288, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.226, 496.885, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.93, 496.491, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.93, 496.491, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.608, 496.114, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.267, 495.761, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.908, 495.43, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.531, 495.122, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.135, 494.837, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.721, 494.575, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.289, 494.336, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.838, 494.12, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.37, 493.927, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.883, 493.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.883, 493.757, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.479, 493.623, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.05, 493.46, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.598, 493.267, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.12, 493.045, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.619, 492.794, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.092, 492.514, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.542, 492.204, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.966, 491.865, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.366, 491.498, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.742, 491.101, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.742, 491.101, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.088, 490.684, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.399, 490.258, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.673, 489.822, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.91, 489.378, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.112, 488.925, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.276, 488.462, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.405, 487.991, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.497, 487.51, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.552, 487.021, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.57, 486.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.57, 486.523, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.545, 485.906, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.471, 485.305, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.348, 484.721, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.175, 484.153, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.952, 483.602, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.681, 483.068, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.36, 482.551, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.99, 482.051, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.571, 481.568, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.102, 481.101, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.102, 481.101, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.6, 480.665, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.074, 480.275, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.526, 479.931, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.956, 479.632, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.362, 479.38, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.746, 479.172, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.108, 479.011, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.446, 478.896, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.762, 478.827, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.055, 478.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.055, 478.804, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.399, 478.822, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.762, 478.876, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.144, 478.966, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.545, 479.092, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.965, 479.254, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.404, 479.452, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.862, 479.685, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.34, 479.955, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.836, 480.26, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.352, 480.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.352, 480.601, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.9, 480.969, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.496, 481.354, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.14, 481.758, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.831, 482.179, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.57, 482.619, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.356, 483.076, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.19, 483.552, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.072, 484.045, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.001, 484.556, 0.0), vec3&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(355.977, 485.085, 0.0)
        }));
out39.closed = true;
ccs.contours.push_back(out39);

  
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(ccs);
}


<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------------ samples_1D -------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//These functions are factories which produce some ordered samples_1D. 
</FONT></I>

<I><FONT COLOR="#B22222">//Cosmic Microwave Background data. Taken from http://www.stat.cmu.edu/~larry/all-of-nonpar/data.html. Quite noisy, and the variance increases
</FONT></I><I><FONT COLOR="#B22222">// dramatically at high-x. The first 400 points are a nice bell shape with medium-variance. See related function below for only these points.
</FONT></I>samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D_sample_CMB(<B><FONT COLOR="#228B22">void</FONT></B>){
   samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out({    vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(2.0, 123.3820),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(3.0, 611.7750),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(4.0, 756.6160),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(5.0, 1256.7000),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(6.0, 696.4790),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(7.0, 829.8190),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(8.0, 627.8620),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(9.0, 815.1740),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(10.0, 617.7500),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(11.0, 1251.6700),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(12.0, 758.7730),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(13.0, 714.5950),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(14.0, 907.1200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(15.0, 871.6480),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(16.0, 628.6330),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(17.0, 1042.0900),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(18.0, 742.3790),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(19.0, 947.1550),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(20.0, 870.9060),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(21.0, 706.1020),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(22.0, 431.8440),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(23.0, 660.0120),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(24.0, 960.8510),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(25.0, 849.1200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(26.0, 866.8620),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(27.0, 1097.4200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(28.0, 1408.1899),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(29.0, 899.1070),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(30.0, 1007.8600),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(31.0, 1078.1300),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(32.0, 1607.0800),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(33.0, 1188.0400),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(34.0, 1067.9700),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(35.0, 910.3670),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(36.0, 1104.4200),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(37.0, 1431.3400),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(38.0, 1282.0601),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(39.0, 1381.4301),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(40.0, 1927.2400),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(41.0, 1266.0400),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(42.0, 1297.2500),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(43.0, 1471.1600),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(44.0, 1363.2100),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(45.0, 1001.1000),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(46.0, 1061.7300),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(47.0, 1564.8000),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(48.0, 1044.3000),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(49.0, 1485.0300),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(50.0, 1469.1801),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(51.0, 1136.4600),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(52.0, 1658.5500),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(53.0, 1119.1100),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(54.0, 1114.6300),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(55.0, 1542.1700),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(56.0, 1526.9700),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(57.0, 1625.0699),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(58.0, 1705.0100),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(59.0, 1279.7500),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(60.0, 1930.2000),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(61.0, 1623.6300),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(62.0, 1893.5300),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(63.0, 1631.5900),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(64.0, 1451.5400),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(65.0, 1521.1200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(66.0, 1617.3400),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(67.0, 1659.0200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(68.0, 1819.3500),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(69.0, 2297.1899),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(70.0, 1762.3101),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(71.0, 1690.5000),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(72.0, 1505.2300),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(73.0, 2635.2600),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(74.0, 2110.7400),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(75.0, 1917.1400),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(76.0, 1766.5400),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(77.0, 1958.4900),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(78.0, 1831.3700),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(79.0, 1644.0000),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(80.0, 2249.8000),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(81.0, 2149.7200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(82.0, 2826.3799),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(83.0, 2002.2300),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(84.0, 1715.9200),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(85.0, 2416.5000),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(86.0, 2427.5400),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(87.0, 2503.2700),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(88.0, 1839.1700),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(89.0, 2453.2300),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(90.0, 2266.8501),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(91.0, 2570.7200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(92.0, 2456.4700),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(93.0, 2773.5901),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(94.0, 2112.3000),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(95.0, 2116.3201),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(96.0, 2442.2100),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(97.0, 2484.0100),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(98.0, 1887.4800),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(99.0, 2694.6399),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(100.0, 3034.3999),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(101.0, 2652.8899),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(102.0, 2935.2100),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(103.0, 2630.0400),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(104.0, 2863.8401),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(105.0, 2239.3799),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(106.0, 2532.6299),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(107.0, 3119.9900),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(108.0, 3531.7800),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(109.0, 2767.6899),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(110.0, 3432.7600),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(111.0, 2849.1699),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(112.0, 2872.2300),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(113.0, 2498.3201),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(114.0, 2111.7400),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(115.0, 3267.9399),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(116.0, 3479.5500),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(117.0, 4595.6299),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(118.0, 3658.6399),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(119.0, 3438.8201),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(120.0, 3007.9800),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(121.0, 4337.7402),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(122.0, 2956.8799),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(123.0, 3265.8601),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(124.0, 2981.2300),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(125.0, 3084.3501),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(126.0, 3598.5601),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(127.0, 3479.0500),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(128.0, 3553.0000),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(129.0, 3274.7100),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(130.0, 3858.1399),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(131.0, 3090.7700),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(132.0, 3187.2500),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(133.0, 3395.0901),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(134.0, 3675.7600),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(135.0, 3978.9800),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(136.0, 4476.5698),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(137.0, 3741.1499),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(138.0, 3869.3799),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(139.0, 4185.8599),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(140.0, 4172.4102),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(141.0, 4222.6001),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(142.0, 4096.1699),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(143.0, 4251.5298),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(144.0, 3655.4900),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(145.0, 5231.4399),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(146.0, 4097.1001),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(147.0, 3949.5901),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(148.0, 3900.2500),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(149.0, 3399.8000),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(150.0, 4220.6802),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(151.0, 4182.7300),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(152.0, 4428.0698),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(153.0, 4789.3198),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(154.0, 4042.2700),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(155.0, 4732.4902),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(156.0, 4129.2202),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(157.0, 4487.5200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(158.0, 5116.0200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(159.0, 4780.5698),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(160.0, 4663.0400),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(161.0, 4505.6899),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(162.0, 4278.8301),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(163.0, 4385.3301),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(164.0, 4436.9399),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(165.0, 4421.6201),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(166.0, 4444.7598),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(167.0, 4899.3999),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(168.0, 4996.2100),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(169.0, 4757.9600),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(170.0, 4289.2900),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(171.0, 4572.1001),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(172.0, 4689.1499),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(173.0, 4945.3999),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(174.0, 4636.6899),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(175.0, 5132.3501),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(176.0, 5291.8301),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(177.0, 4906.1299),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(178.0, 5036.7100),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(179.0, 6034.5400),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(180.0, 5097.6201),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(181.0, 3655.3611),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(182.0, 4459.3760),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(183.0, 4202.4458),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(184.0, 5565.5771),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(185.0, 5292.7871),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(186.0, 4965.5161),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(187.0, 5221.6299),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(188.0, 5948.0908),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(189.0, 6163.9219),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(190.0, 5495.4351),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(191.0, 5468.0000),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(192.0, 6175.0918),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(193.0, 5738.8950),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(194.0, 5214.8569),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(195.0, 4661.0420),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(196.0, 5356.1099),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(197.0, 5740.6660),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(198.0, 5702.0669),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(199.0, 5105.9868),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(200.0, 6152.4800),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(201.0, 5074.6128),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(202.0, 5240.9780),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(203.0, 5815.8320),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(204.0, 5448.9810),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(205.0, 5391.9409),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(206.0, 4888.0298),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(207.0, 4442.5239),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(208.0, 4605.2349),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(209.0, 4306.1968),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(210.0, 5648.5791),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(211.0, 5285.3618),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(212.0, 5689.2061),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(213.0, 5726.2051),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(214.0, 5140.9419),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(215.0, 6542.2061),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(216.0, 5581.5459),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(217.0, 4907.5288),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(218.0, 6008.8159),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(219.0, 5487.0908),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(220.0, 6064.0288),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(221.0, 6387.7358),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(222.0, 5969.8052),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(223.0, 5724.6572),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(224.0, 5238.1372),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(225.0, 5334.3311),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(226.0, 5632.4858),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(227.0, 5791.2051),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(228.0, 5262.7842),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(229.0, 4980.0269),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(230.0, 5383.9858),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(231.0, 5718.6958),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(232.0, 5988.0640),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(233.0, 5956.9209),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(234.0, 4419.0908),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(235.0, 6361.1450),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(236.0, 6613.8882),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(237.0, 5088.7568),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(238.0, 5748.0630),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(239.0, 5443.6909),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(240.0, 6037.1948),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(241.0, 5428.4111),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(242.0, 5102.0361),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(243.0, 5122.0449),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(244.0, 5174.9570),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(245.0, 6054.9761),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(246.0, 5410.7622),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(247.0, 5513.8818),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(248.0, 5746.8042),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(249.0, 4472.8931),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(250.0, 5341.5430),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(251.0, 4775.1792),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(252.0, 6041.2021),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(253.0, 4771.8838),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(254.0, 4761.6421),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(255.0, 5548.3301),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(256.0, 5001.9121),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(257.0, 4991.7690),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(258.0, 5665.6899),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(259.0, 5049.3291),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(260.0, 5485.4722),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(261.0, 4891.0869),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(262.0, 5812.1602),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(263.0, 5334.0020),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(264.0, 4666.9150),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(265.0, 4563.2319),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(266.0, 5203.7080),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(267.0, 4857.5439),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(268.0, 5436.7041),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(269.0, 4681.3442),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(270.0, 4083.0649),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(271.0, 5119.7788),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(272.0, 5668.4092),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(273.0, 4573.1709),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(274.0, 4795.4590),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(275.0, 4187.4028),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(276.0, 4288.6851),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(277.0, 5368.5112),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(278.0, 4723.2388),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(279.0, 5069.4639),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(280.0, 4393.5210),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(281.0, 4297.6050),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(282.0, 5330.3799),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(283.0, 5177.6611),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(284.0, 4529.8979),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(285.0, 4131.8740),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(286.0, 5141.5781),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(287.0, 3848.0061),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(288.0, 4118.6479),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(289.0, 4782.7090),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(290.0, 4564.9609),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(291.0, 3550.0920),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(292.0, 4448.3062),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(293.0, 4613.5308),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(294.0, 3849.0349),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(295.0, 4017.4641),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(296.0, 3941.2129),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(297.0, 4284.6719),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(298.0, 3918.2300),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(299.0, 4167.6909),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(300.0, 4435.9541),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(301.0, 2982.4700),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(302.0, 4162.6792),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(303.0, 3259.0049),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(304.0, 4049.6130),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(305.0, 3771.2229),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(306.0, 3326.9851),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(307.0, 3602.1389),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(308.0, 3735.2629),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(309.0, 3374.0701),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(310.0, 4242.6108),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(311.0, 3298.3911),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(312.0, 3248.4189),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(313.0, 3761.9880),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(314.0, 2944.8870),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(315.0, 4140.9878),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(316.0, 3903.4199),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(317.0, 2852.8960),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(318.0, 2986.7810),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(319.0, 3679.7161),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(320.0, 3484.5090),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(321.0, 2552.9009),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(322.0, 3556.8081),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(323.0, 3042.8201),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(324.0, 3470.5271),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(325.0, 3792.7971),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(326.0, 3158.4231),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(327.0, 2648.8240),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(328.0, 3024.1509),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(329.0, 2741.8630),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(330.0, 2744.6799),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(331.0, 2982.1550),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(332.0, 2795.1570),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(333.0, 2461.6270),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(334.0, 3159.1570),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(335.0, 2297.7520),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(336.0, 2761.8911),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(337.0, 3127.6680),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(338.0, 2565.4939),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(339.0, 2644.9419),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(340.0, 3318.8921),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(341.0, 2180.1089),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(342.0, 2791.7351),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(343.0, 2054.2849),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(344.0, 2648.9099),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(345.0, 1810.7460),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(346.0, 2168.6101),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(347.0, 2063.5420),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(348.0, 1500.0291),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(349.0, 2316.3279),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(350.0, 2152.0740),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(351.0, 2439.2820),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(352.0, 2554.9060),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(353.0, 2219.2200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(354.0, 2886.4980),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(355.0, 2479.3101),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(356.0, 2319.9810),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(357.0, 2287.5020),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(358.0, 2354.9341),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(359.0, 2115.0149),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(360.0, 1980.5830),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(361.0, 3008.0100),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(362.0, 2506.2019),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(363.0, 2058.7180),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(364.0, 2186.5710),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(365.0, 1726.1180),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(366.0, 2300.5591),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(367.0, 2164.5930),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(368.0, 1631.8470),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(369.0, 1727.1670),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(370.0, 1614.4080),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(371.0, 2058.5449),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(372.0, 1566.2500),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(373.0, 1714.9189),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(374.0, 1735.2080),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(375.0, 2358.2241),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(376.0, 2161.2090),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(377.0, 1505.6570),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(378.0, 2331.6299),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(379.0, 2039.6790),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(380.0, 1712.7939),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(381.0, 1599.7880),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(382.0, 1714.3560),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(383.0, 1453.0350),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(384.0, 1544.8420),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(385.0, 1589.2410),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(386.0, 1344.1060),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(387.0, 1993.6580),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(388.0, 1561.6450),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(389.0, 1666.1060),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(390.0, 1777.5129),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(391.0, 1811.0179),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(392.0, 2388.8811),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(393.0, 1423.7810),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(394.0, 1823.0730),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(395.0, 1899.4630),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(396.0, 1266.8140),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(397.0, 825.0203),    vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(398.0, 874.7407),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(399.0, 1766.4659),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(400.0, 1448.1400),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(401.0, 1516.8860),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(402.0, 1865.5510),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(403.0, 1262.1930),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(404.0, 2127.5220),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(405.0, 1805.7810),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(406.0, 1771.8910),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(407.0, 1760.5190),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(408.0, 1680.4060),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(409.0, 1343.1710),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(410.0, 1323.7889),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(411.0, 1835.4230),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(412.0, 2102.0730),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(413.0, 2141.4021),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(414.0, 1582.7100),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(415.0, 2441.4221),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(416.0, 1995.7791),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(417.0, 1924.9130),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(418.0, 1160.1920),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(419.0, 1719.7791),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(420.0, 2133.7610),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(421.0, 1878.4821),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(422.0, 1963.1500),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(423.0, 1605.9200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(424.0, 2282.4241),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(425.0, 1600.3660),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(426.0, 1805.1410),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(427.0, 1901.6110),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(428.0, 934.4476),    vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(429.0, 2321.0750),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(430.0, 2410.3679),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(431.0, 1538.1240),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(432.0, 1820.4351),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(433.0, 1348.0560),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(434.0, 2323.0071),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(435.0, 1926.1940),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(436.0, 1162.6560),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(437.0, 2640.8450),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(438.0, 1452.6639),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(439.0, 1675.2040),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(440.0, 1335.2550),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(441.0, 1277.1980),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(442.0, 2871.2329),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(443.0, 2083.7200),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(444.0, 1207.6390),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(445.0, 2108.8430),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(446.0, 2242.2549),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(447.0, 1751.0909),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(448.0, 1361.6670),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(449.0, 1200.1760),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(450.0, 1426.4840),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(451.0, 1744.0620),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(452.0, 2106.7471),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(453.0, 2108.6831),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(454.0, 2838.5281),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(455.0, 2632.6599),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(456.0, 1588.1570),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(457.0, 1512.8040),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(458.0, 1352.7490),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(459.0, 1577.5210),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(460.0, 1560.3240),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(461.0, 1984.0900),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(462.0, 3104.8391),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(463.0, 2826.3569),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(464.0, 2176.8479),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(465.0, 1901.6440),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(466.0, 1337.9871),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(467.0, 2034.5630),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(468.0, 1249.0710),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(469.0, 932.2463),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(470.0, 2312.3701),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(471.0, 3055.0371),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(472.0, 2153.2209),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(473.0, 2392.1150),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(474.0, 2054.9641),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(475.0, 2242.0530),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(476.0, 2273.2810),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(477.0, 1417.6110),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(478.0, 1962.6670),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(479.0, 2615.9360),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(480.0, 2351.0281),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(481.0, 1875.3070),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(482.0, 2202.9800),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(483.0, 2869.6521),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(484.0, 1994.6250),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(485.0, 3398.7749),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(486.0, 1682.7400),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(487.0, 2546.2571),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(488.0, 691.2237),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(489.0, 1757.2939),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(490.0, 2863.0300),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(491.0, 3843.4060),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(492.0, 1973.2010),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(493.0, 1755.1840),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(494.0, 2486.3411),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(495.0, 1766.4449),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(496.0, 2584.2500),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(497.0, 1349.0380),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(498.0, 2777.1411),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(499.0, 1711.4091),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(500.0, 2770.2361),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(501.0, 1602.9650),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(502.0, 2950.7280),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(503.0, 1870.4230),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(504.0, 2957.3701),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(505.0, 2524.6221),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(506.0, 1723.1940),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(507.0, 2207.9021),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(508.0, 2804.7981),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(509.0, 1780.3140),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(510.0, 2488.4341),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(511.0, 2433.6240),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(512.0, 2808.1130),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(513.0, 1853.1190),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(514.0, 1217.9370),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(515.0, 2448.9619),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(516.0, 1387.0870),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(517.0, 1065.2889),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(518.0, 2313.2661),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(519.0, 2261.7471),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(520.0, 2704.7100),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(521.0, 3779.3770),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(522.0, 2364.9590),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(523.0, 1648.0680),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(524.0, 2722.2480),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(525.0, 2033.5450),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(526.0, 3248.9021),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(527.0, 1358.1880),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(528.0, 1414.6550),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(529.0, 2783.4509),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(530.0, 3036.6350),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(531.0, 3558.9880),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(532.0, 3248.3159),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(533.0, 2003.5500),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(534.0, 3191.3440),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(535.0, 3179.0930),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(536.0, 2663.3259),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(537.0, 2312.9341),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(538.0, 2795.6240),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(539.0, 3452.6340),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(540.0, 2672.3970),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(541.0, 2880.9680),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(542.0, 2434.8401),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(543.0, 1738.8409),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(544.0, 3036.1331),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(545.0, 3722.6331),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(546.0, 3224.9580),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(547.0, 2456.0029),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(548.0, 3428.1970),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(549.0, 2696.3091),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(550.0, 1899.7030),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(551.0, 3701.2070),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(552.0, 1608.4410),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(553.0, 2400.6389),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(554.0, 3063.1780),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(555.0, 3863.6489),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(556.0, 1522.4840),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(557.0, 4987.7212),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(558.0, 2277.1531),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(559.0, 1209.2750),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(560.0, 3229.7500),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(561.0, 4036.7061),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(562.0, 444.5700),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(563.0, 2383.4241),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(564.0, 2765.2410),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(565.0, 1519.2570),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(566.0, 3228.8091),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(567.0, 608.2505),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(568.0, 177.3318),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(569.0, 2050.6270),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(570.0, 2166.8030),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(571.0, 1311.9659),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(572.0, 434.7462),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(573.0, 3556.0491),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(574.0, -772.2820),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(575.0, 3944.6951),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(576.0, 2023.6250),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(577.0, 4177.3770),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(578.0, 2011.0760),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(579.0, 2142.7910),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(580.0, 1917.5160),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(581.0, 2497.9409),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(582.0, 4248.4258),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(583.0, 4010.4209),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(584.0, 3581.6841),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(585.0, 1036.6460),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(586.0, 1189.0200),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(587.0, 3510.4089),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(588.0, 1949.7510),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(589.0, 1927.9220),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(590.0, 3757.5000),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(591.0, 1239.8030),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(592.0, 1609.0450),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(593.0, 1041.8870),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(594.0, 1562.4330),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(595.0, 2101.1289),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(596.0, 446.9620),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(597.0, 3140.7219),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(598.0, 1866.0940),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(599.0, 2580.7229),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(600.0, 1872.8070),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(601.0, 7.8509),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(602.0, 2493.1150),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(603.0, -905.1535),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(604.0, 3514.7781),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(605.0, 2266.7981),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(606.0, 1642.6110),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(607.0, 3389.5310),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(608.0, 3135.9780),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(609.0, 2359.5310),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(610.0, 2517.1121),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(611.0, 1511.4390),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(612.0, 2173.7900),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(613.0, 77.6369),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(614.0, 3061.2090),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(615.0, 2882.3650),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(616.0, 1378.3080),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(617.0, 4002.8479),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(618.0, 2059.5659),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(619.0, 1805.6810),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(620.0, -183.5365),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(621.0, -644.3215),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(622.0, 3624.0859),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(623.0, 176.8948),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(624.0, 23.6813),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(625.0, 2287.3879),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(626.0, 1413.8270),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(627.0, 6002.9219),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(628.0, 1555.9630),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(629.0, 416.8448),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(630.0, 963.5390),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(631.0, 2093.1060),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(632.0, 2419.4861),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(633.0, 4012.3931),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(634.0, 3963.0920),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(635.0, 2684.7090),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(636.0, 2126.1750),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(637.0, 406.4875),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(638.0, 2030.6440),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(639.0, 55.6879),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(640.0, 1396.4670),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(641.0, 2361.6980),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(642.0, 1164.3490),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(643.0, 327.1929),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(644.0, 640.1141),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(645.0, -1416.4240),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(646.0, 5969.7930),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(647.0, 701.9258),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(648.0, 4361.0298),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(649.0, -849.1665),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(650.0, 882.0359),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(651.0, 4734.0630),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(652.0, 3293.3269),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(653.0, 3575.1321),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(654.0, 848.2543),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(655.0, 1377.0100),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(656.0, 1957.2889),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(657.0, 3733.2339),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(658.0, 3130.6230),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(659.0, -2799.1670),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(660.0, 2147.5291),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(661.0, 5583.2808),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(662.0, 1925.8260),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(663.0, -2415.5681),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(664.0, 1137.2230),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(665.0, 1572.3220),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(666.0, -1045.0439),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(667.0, 7765.1519),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(668.0, 7214.0889),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(669.0, 596.4047),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(670.0, -581.3713),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(671.0, 3955.2739),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(672.0, 2640.3960),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(673.0, 3951.0911),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(674.0, -926.4888),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(675.0, 4009.6919),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(676.0, 6149.2319),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(677.0, 966.2288),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(678.0, 4203.1621),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(679.0, 3701.3931),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(680.0, -1315.1121),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(681.0, 5307.6851),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(682.0, -4338.0859),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(683.0, 3123.8350),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(684.0, 4638.0229),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(685.0, 1455.0880),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(686.0, 1813.9270),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(687.0, 1817.8020),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(688.0, -4805.8330),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(689.0, -2097.1321),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(690.0, 5239.7539),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(691.0, -1643.4670),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(692.0, -905.7075),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(693.0, 348.3626),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(694.0, 2570.3660),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(695.0, -223.6349),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(696.0, 5039.5508),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(697.0, 2213.0081),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(698.0, -3934.6909),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(699.0, 2561.9360),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(700.0, 6024.8579),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(701.0, 4917.7881),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(702.0, 1626.1160),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(703.0, 2613.0020),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(704.0, -1597.4060),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(705.0, 3057.1140),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(706.0, 142.7675),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(707.0, -75.1234),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(708.0, 4884.0288),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(709.0, 974.4821),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(710.0, -3186.9199),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(711.0, -373.4638),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(712.0, 1692.2360),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(713.0, 5332.4790),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(714.0, -2329.1970),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(715.0, -1644.3650),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(716.0, -1228.3571),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(717.0, 44.5899),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(718.0, -462.8018),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(719.0, 512.6001),   
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(720.0, -280.7488),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(721.0, -2736.0730),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(722.0, 4739.5649),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(723.0, 983.9019),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(724.0, 4174.4702),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(725.0, 293.5886),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(726.0, 5240.9551),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(727.0, 298.7967),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(728.0, 1637.7750),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(729.0, 910.9006),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(730.0, 1319.6331),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(731.0, 2305.6721),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(732.0, -3872.8379),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(733.0, 1380.5590),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(734.0, -2433.4331),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(735.0, 3573.4919),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(736.0, 4942.1089),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(737.0, 192.6706),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(738.0, 3114.1460),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(739.0, 5029.1538),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(740.0, 8531.1748),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(741.0, -1595.3790),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(742.0, 6205.6729),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(743.0, 6274.0889),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(744.0, 3988.8049),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(745.0, 465.6910),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(746.0, -4441.9028),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(747.0, 7197.3110),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(748.0, 3141.7939),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(749.0, 8172.9990),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(750.0, -3078.6221),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(751.0, 3639.1660),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(752.0, 3120.8479),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(753.0, 2679.3159),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(754.0, 8197.2344),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(755.0, -377.3017),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(756.0, -1600.1639),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(757.0, 2628.5730),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(758.0, 2338.4109),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(759.0, 1535.1420),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(760.0, 4072.4480),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(761.0, 174.2986),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(762.0, 2917.9890),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(763.0, 3183.3960),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(764.0, -1957.9550),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(765.0, 223.2232),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(766.0, 272.7387),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(767.0, -4436.5581),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(768.0, 10138.0801),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(769.0, 4448.0640),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(770.0, 7119.9570),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(771.0, -1237.9180),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(772.0, 6826.1841),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(773.0, 2426.8301),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(774.0, -1139.8650),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(775.0, -4528.1030),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(776.0, -526.6643),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(777.0, 3973.1860),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(778.0, -1764.6689),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(779.0, 2305.2771),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(780.0, -4457.8301),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(781.0, 3275.2429),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(782.0, 2772.2090),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(783.0, 2779.9939),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(784.0, 1142.1100),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(785.0, -4118.4028),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(786.0, 2469.2581),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(787.0, -1284.5610),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(788.0, 180.9269),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(789.0, -2440.8569),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(790.0, 5660.4448),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(791.0, 2758.9409),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(792.0, 10427.3203),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(793.0, -6023.4082),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(794.0, -3817.8020),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(795.0, 11140.8398),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(796.0, 2108.4771),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(797.0, 2942.2129),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(798.0, 8342.8037),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(799.0, -5842.7168),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(800.0, 8416.0645),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(801.0, 7627.3940),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(802.0, -559.8192),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(803.0, 12719.2305),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(804.0, 336.0424),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(805.0, 1415.5850),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(806.0, -3900.2529),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(807.0, -8128.9609),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(808.0, 6833.6162),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(809.0, -8199.5098),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(810.0, 4956.4482),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(811.0, -3875.1140),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(812.0, -994.2132),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(813.0, 2023.4150),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(814.0, -9174.2021),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(815.0, 4792.6860),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(816.0, 6656.9380),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(817.0, -156.3022),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(818.0, 11426.6797),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(819.0, -1110.5389),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(820.0, -498.7589),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(821.0, 5784.6421),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(822.0, -2338.5439),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(823.0, -4762.3799),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(824.0, 10288.1699),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(825.0, -85.8420),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(826.0, -5792.6299),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(827.0, 9432.3066),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(828.0, -1237.6071),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(829.0, 11577.6504),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(830.0, -5906.0708),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(831.0, -1436.6479),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(832.0, -747.6784),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(833.0, 3779.9199),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(834.0, 6686.0791),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(835.0, -10580.1699),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(836.0, 10068.4297),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(837.0, 284.3946),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(838.0, 4784.3169),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(839.0, -2786.4980),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(840.0, 10887.6396),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(841.0, 4101.7319),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(842.0, -3374.4199),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(843.0, 7427.2959),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(844.0, 11351.7500),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(845.0, 11252.5303),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(846.0, 10319.7402),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(847.0, 2104.9719),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(848.0, 2987.6140),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(849.0, 12221.2305),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(850.0, 7164.0972),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(851.0, 12210.5498),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(852.0, -6624.4468),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(853.0, 5208.7090),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(854.0, 18855.6504),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(855.0, -685.2932),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(856.0, 6274.0898),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(857.0, 10564.0801),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(858.0, -1976.4420),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(859.0, 3578.9741),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(860.0, 1354.5820),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(861.0, 8314.6592),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(862.0, 615.0848),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(863.0, -3321.0481),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(864.0, -2859.4780),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(865.0, -3234.6541),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(866.0, 22348.9004),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(867.0, -1656.9370),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(868.0, 6698.1982),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(869.0, -2467.7151),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(870.0, 7539.5239),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(871.0, -12382.8203),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(872.0, -10100.3799),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(873.0, 4637.5518),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(874.0, 10933.2803),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(875.0, 11104.5996),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(876.0, 3406.8711),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(877.0, -3593.0330),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(878.0, -13859.4697),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(879.0, -11088.7197),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(880.0, 26480.8809),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(881.0, -5331.9448),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(882.0, -3330.6521),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(883.0, 62.2097),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(884.0, 1993.1370),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(885.0, -5423.5371),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(886.0, 3930.3301),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(887.0, 6920.0278),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(888.0, -2487.7971),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(889.0, -5045.4678),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(890.0, 18028.8809),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(891.0, 2816.0530),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(892.0, 10693.7100),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(893.0, 4222.8682),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(894.0, 11420.1201),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(895.0, 13036.3496),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(896.0, 16760.5996),
       vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(897.0, 9046.5000),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(898.0, 12001.8301),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(899.0, 15065.5898),   vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(900.0, -17046.0801)
    });
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D_sample_CMB_first_half(<B><FONT COLOR="#228B22">void</FONT></B>){
    samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> in = samples_1D_sample_CMB();
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> cnt(0);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.samples.begin(); (it != in.samples.end()) &amp;&amp; (cnt &lt; 400); ++it, ++cnt){
        out.samples.push_back(*it);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<I><FONT COLOR="#B22222">//LIDAR data. Taken from http://www.stat.cmu.edu/~larry/all-of-nonpar/data.html (from a textbook called 'All of nonparametric statistics').
</FONT></I><I><FONT COLOR="#B22222">// Data is split into two parts. The left side is almost flat with small variance. There is a 'drop' in the middle, and the right side
</FONT></I><I><FONT COLOR="#B22222">// gradually begins to level off. The variance is high to the right of the shelf.
</FONT></I>samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D_sample_LIDAR(<B><FONT COLOR="#228B22">void</FONT></B>){
   samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out({   
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(390, -0.050355730),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(391, -0.060097060),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(393, -0.041900910),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(394, -0.050984700),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(396, -0.059913450),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(397, -0.028423920),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(399, -0.059584210),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(400, -0.039888810),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(402, -0.029395820),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(403, -0.039494450),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(405, -0.047647490),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(406, -0.060380000),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(408, -0.031230340),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(409, -0.038165840),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(411, -0.075622690),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(412, -0.050017510),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(414, -0.045729500),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(415, -0.077669660),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(417, -0.024606410),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(418, -0.071331840),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(420, -0.013207460),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(421, -0.031626150),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(423, -0.032474780),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(424, -0.088407970),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(426, -0.070241660),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(427, -0.028772630),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(429, -0.036967020),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(430, -0.101562500),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(432, -0.068313730),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(433, -0.031757510),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(435, -0.053368190),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(436, -0.057263810),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(438, -0.022955150),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(439, -0.014791660),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(441, -0.025318840),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(442, -0.095389440),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(444, -0.081261080),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(445, -0.064738010),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(447, -0.049400040),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(448, -0.024539830),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(450, -0.004223316),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(451, -0.046929080),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(453, -0.072642600),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(454, -0.063754970),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(456, -0.048675710),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(457, -0.079021940),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(459, -0.055083920),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(460, -0.036009150),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(462, -0.008198360),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(463, -0.029916380),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(465, -0.059044170),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(466, -0.043490760),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(468, -0.108366700),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(469, -0.071644950),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(471, -0.108043100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(472, -0.011447560),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(474, -0.090664970),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(475, -0.074388490),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(477, -0.088807160),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(478, -0.072401300),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(480, -0.039412080),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(481, -0.084136980),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(483, -0.044777780),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(484, -0.148665100),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(486, -0.080272660),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(487, -0.054824790),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(489, -0.012024890),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(490,  0.019348600),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(492, -0.083894270),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(493, -0.041574770),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(495, -0.061091210),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(496, -0.060443250),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(498, -0.082201860),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(499, -0.075303490),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(501, -0.044809910),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(502,  0.008222156),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(504, -0.067588090),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(505, -0.032499460),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(507, -0.021981460),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(508, -0.042326210),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(510, -0.077852130),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(511, -0.078061950),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(513,  0.026907170),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(514, -0.092260960),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(516, -0.091590450),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(517, -0.004001756),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(519, -0.018189330),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(520, -0.025276170),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(522, -0.058424990),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(523, -0.052573050),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(525, -0.026062480),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(526, -0.118087700),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(528, -0.052631100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(529, -0.041351480),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(531, -0.009199134),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(532, -0.083366440),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(534, -0.012533340),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(535, -0.062903320),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(537, -0.060180180),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(538, -0.103568600),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(540, -0.126116600),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(541, -0.038870120),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(543, -0.056549840),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(544, -0.074448420),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(546, -0.003788664),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(547, -0.092039710),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(549, -0.055173560),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(550, -0.100433700),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(552, -0.169438000),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(553, -0.064141840),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(555, -0.186734800),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(556, -0.090860060),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(558, -0.059187140),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(559, -0.081035100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(561, -0.103477600),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(562, -0.065673940),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(564, -0.182124500),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(565, -0.085712700),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(567, -0.121604100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(568, -0.134269200),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(570, -0.193390800),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(571, -0.117863900),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(573, -0.287109000),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(574, -0.273944700),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(576, -0.186719400),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(577, -0.189195300),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(579, -0.294862500),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(580, -0.371198400),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(582, -0.232675300),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(583, -0.271973600),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(585, -0.275020400),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(586, -0.310527100),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(588, -0.399157200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(589, -0.425672200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(591, -0.519027200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(592, -0.424584400),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(594, -0.398271100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(595, -0.346376700),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(597, -0.440465100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(598, -0.416947400),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(600, -0.366367800),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(601, -0.412190200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(603, -0.525884900),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(604, -0.458107900),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(606, -0.460408100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(607, -0.521879200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(609, -0.566426900),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(610, -0.708995600),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(612, -0.650540200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(613, -0.571982900),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(615, -0.401473600),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(616, -0.525136200),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(618, -0.563555800),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(619, -0.590039200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(621, -0.424141300),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(622, -0.489361900),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(624, -0.542304700),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(625, -0.655504900),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(627, -0.509341000),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(628, -0.483083200),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(630, -0.600755200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(631, -0.683696500),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(633, -0.515332200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(634, -0.485786300),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(636, -0.663813500),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(637, -0.769263200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(639, -0.479689100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(640, -0.772027200),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(642, -0.540661400),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(643, -0.565100900),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(645, -0.456521700),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(646, -0.419902300),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(648, -0.539716900),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(649, -0.923823200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(651, -0.640224000),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(652, -0.825267700),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(654, -0.596618300),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(655, -0.546587100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(657, -0.423674600),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(658, -0.707649500),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(660, -0.455401300),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(661, -0.675938200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(663, -0.658868800),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(664, -0.719863500),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(666, -0.568205500),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(667, -0.639420400),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(669, -0.731023700),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(670, -0.611648100),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(672, -0.617259600),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(673, -0.755963700),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(675, -0.766384800),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(676, -0.712309300),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(678, -0.708644300),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(679, -0.537711200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(681, -0.724290000),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(682, -0.621456400),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(684, -0.632412100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(685, -0.949553500),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(687, -0.675763100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(688, -0.588709700),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(690, -0.911435300),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(691, -0.432679400),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(693, -0.859001700),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(694, -0.798765300),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(696, -0.693147200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(697, -0.886574000),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(699, -0.796826100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(700, -0.502526800),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(702, -0.471670200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(703, -0.780108800),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(705, -0.666843100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(706, -0.578347900),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(708, -0.787452200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(709, -0.615695600),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(711, -0.896760200),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(712, -0.707737900),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(714, -0.672567000),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(715, -0.621841300),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(717, -0.865761100),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(718, -0.557754000),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(720, -0.802668400)
    });
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//Daily caloric intake over the span of 115 days. Data is quite noisy. There appears to be a steady increase in overall intake as time progresses.
</FONT></I><I><FONT COLOR="#B22222">// The data starts at x=-115 and goes until x=0. Some data has been censored. Time period ended March 10th, 2013.
</FONT></I>samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; samples_1D_sample_Calories(<B><FONT COLOR="#228B22">void</FONT></B>){
   samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; out({        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-115,1113),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-114,1688),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-113,1480),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-112,1652),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-111,60),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-110,2777),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-109,1736),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-108,2025),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-107,50),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-106,1493),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-105,2007),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-104,0),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-103,2155),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-102,1891),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-101,1134),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-100,1343),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-99,1953),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-98,2044),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-97,245),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-96,1543),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-95,1908),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-94,1388),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-93,1920),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-92,1445),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-91,1770),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-90,124),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-89,1249),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-88,2024),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-87,1716),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-86,1954),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-85,1678),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-84,2240),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-83,687),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-82,2033),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-81,1733),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-80,1804),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-79,2036),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-78,1800),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-77,2464),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-67,1490),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-66,1532),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-65,701),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-63,60),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-62,1985),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-61,1982),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-60,1726),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-59,1630),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-58,2558),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-57,1950),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-56,2022),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-55,1435),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-54,1563),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-53,1495),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-52,276),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-51,1742),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-50,1313),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-49,1783),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-48,1436),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-47,1336),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-46,1475),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-45,1557),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-44,1615),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-43,2248),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-42,1751),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-41,1514),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-40,1300),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-39,950),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-38,1710),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-37,2615),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-36,2006),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-35,1761),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-34,1589),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-33,1282),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-32,1033),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-31,1221),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-30,2110),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-29,1762),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-28,2126),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-27,2809),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-26,1801),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-25,1228),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-24,2174),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-23,1883),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-22,2105),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-21,1923),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-20,1945),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-19,1826),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-18,1937),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-17,1638),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-16,1966),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-15,1833),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-14,2219),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-13,1993),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-12,1823),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-11,1242),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-10,2087),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-9,1926),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-8,2950),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-7,2082),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-6,462),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-5,2068),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-4,1681),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-3,1981),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-2,2024),
        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-1,2064),        vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(-0,1915)
    });
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

</PRE>
<HR>
<A NAME="file31">
<H1>YgorMisc.cc 31/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file30">prev</A>][<A HREF="#file32">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorMisc.cc - Miscellaneous routines which show up too many places to bother repeating again and again.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
<I><FONT COLOR="#B22222">//#include &lt;ctime&gt;                 //Needed for gen_time_random().
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;fstream&gt;               //Needed for fstream (for file checking.)
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;set&gt;
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stdio.h&gt;</FONT></B>               //Needed for popen, pclose.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;unistd.h&gt;</FONT></B>              //Needed for read.

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">/*
void gen_random(std::string *s, const int len) {
    static const char alphanum[] =
        &quot;0123456789&quot;
        &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
        &quot;abcdefghijklmnopqrstuvwxyz&quot;;
    (*s).clear();
    for(int i=0; i&lt;len; ++i)   (*s) += alphanum[rand()%(sizeof(alphanum)-1)];
    return;
}

void seed_time(void){
    //Seed the rand() function with the current time.
    srand(time(NULL));
    return;
}

void Dump_Set_to_Screen(const std::set&lt;std::string&gt;::iterator &amp;begin, const std::set&lt;std::string&gt;::iterator &amp;end){
    for(auto i = begin; i != end; ++i){
        std::cout &lt;&lt; &quot; &quot; &lt;&lt; *i ;
    }
    std::cout &lt;&lt; std::endl;
    return;
}
*/</FONT></I>


std::string Execute_Command_In_Pipe(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;cmd){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    <B><FONT COLOR="#228B22">auto</FONT></B> pipe = popen(cmd.c_str(), <B><FONT COLOR="#BC8F8F">&quot;r&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(pipe == nullptr) <B><FONT COLOR="#A020F0">return</FONT></B> out;    

    ssize_t nbytes;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> buffsz = 5000;
    <B><FONT COLOR="#228B22">char</FONT></B> buff[buffsz];

    #ifdef EAGAIN
        <B><FONT COLOR="#A020F0">while</FONT></B>( ((nbytes = read(fileno(pipe), buff, buffsz)) != -1)  || (errno == EAGAIN) ){
    #<B><FONT COLOR="#A020F0">else</FONT></B>
        <B><FONT COLOR="#A020F0">while</FONT></B>( ((nbytes = read(fileno(pipe), buff, buffsz)) != -1) ){
    #endif

        <I><FONT COLOR="#B22222">//Check if we have reached the end of the file (ie. &quot;data has run out.&quot;)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( nbytes == 0 ) <B><FONT COLOR="#A020F0">break</FONT></B>;

        <I><FONT COLOR="#B22222">//Otherwise we fill up the buffer to the high-water mark and move on.
</FONT></I>        buff[nbytes] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
        out += std::string(buff,nbytes); <I><FONT COLOR="#B22222">//This is done so that in-buffer '\0's don't confuse = operator.
</FONT></I>    }
    pclose(pipe);
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
</PRE>
<HR>
<A NAME="file32">
<H1>YgorNetworking.cc 32/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file31">prev</A>][<A HREF="#file33">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorNetworking.cc.
</FONT></I>

<I><FONT COLOR="#B22222">//Gross fix for compiling without glibc: Define this constant to avoid getting compilation errors regarding
</FONT></I><I><FONT COLOR="#B22222">// sleep_for not being part of std::this_thread:...
</FONT></I><I><FONT COLOR="#B22222">//#ifndef _GLIBCXX_USE_NANOSLEEP
</FONT></I><I><FONT COLOR="#B22222">//    #pragma message &quot;Defining macro _GLIBCXX_USE_NANOSLEEP. In Jan 2013, this was required on some systems to get around sleep_for/std::this_thread copmile errors.&quot; 
</FONT></I><I><FONT COLOR="#B22222">//    #define _GLIBCXX_USE_NANOSLEEP 1
</FONT></I><I><FONT COLOR="#B22222">//#endif
</FONT></I>


<I><FONT COLOR="#B22222">//#define YGORNETWORKING_NO_CHILD         //No children are spawned, so everything is shared. Useful for stateful things (media playback).
</FONT></I><I><FONT COLOR="#B22222">//#define YGORNETWORKING_USE_THREAD       //Spawns threads instead of forking. Less safe due to sharing *everything* by default.
</FONT></I>#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGORNETWORKING_USE_THREAD_POOL</FONT>  //Spawns up to N threads instead of forking. Queues events for the N threads to handle.
<I><FONT COLOR="#B22222">//#define YGORNETWORKING_USE_CLONE        //Cherry-picked mix of the best of both above methods.          *Still haven't got it to work!*
</FONT></I><I><FONT COLOR="#B22222">//#define YGORNETWORKING_USE_FORK         //Results in no memory sharing. Good for stateless web serving/proxying.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">YGORNETWORKING_RADIO_NO_CHILD</FONT>
<I><FONT COLOR="#B22222">//#define YGORNETWORKING_RADIO_USE_THREAD
</FONT></I><I><FONT COLOR="#B22222">//#define YGORNETWORKING_RADIO_USE_CLONE
</FONT></I><I><FONT COLOR="#B22222">//#define YGORNETWORKING_RADIO_USE_FORK
</FONT></I>
<I><FONT COLOR="#B22222">/*
///////////////////////////////
#ifdef __linux__ 
    //Pull in the header files that define sys_clone and CLONE_IO.
    #include &lt;sys/syscall.h&gt;
    #define _GNU_SOURCE 
        #include &lt;sched.h&gt;
        #include &lt;unistd.h&gt;
    #undef _GNU_SOURCE 
 
    //If either is not present, fall back on the fork behaviour.
    #if ! defined(SYS_clone) || ! defined (CLONE_IO) 
        #define fork_clone_io fork 
    #else 
        //CLONE_IO is available, determine which version of sys_clone to use.
        #include &lt;linux/version.h&gt; 
        #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,49) 
            //Arguments: clone_flags, child_stack, parent_tidptr, child_tidptr.
            #define CLONE_ARGS SIGCHLD|CLONE_IO, 0, NULL, NULL 
        #else   
            #define CLONE_ARGS SIGCHLD|CLONE_IO, 0 
        #endif 
        pid_t fork_clone_io(void);

    #endif 
#else                                
        #define fork_clone_io fork 
#endif 
*/</FONT></I>
<I><FONT COLOR="#B22222">//////////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">//Needed for YGORNETWORKING_USE_THREAD
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORNETWORKING_USE_THREAD</FONT>
    #include &lt;thread&gt;
    #ifndef _GNU_SOURCE
        #define _GNU_SOURCE
        #include &lt;sched.h&gt;
        #undef _GNU_SOURCE
    #<B><FONT COLOR="#A020F0">else</FONT></B>
        #include &lt;sched.h&gt;
    #endif
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>    


#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORNETWORKING_USE_THREAD_POOL</FONT>
    #include &lt;thread&gt;
    #ifndef _GNU_SOURCE
        #define _GNU_SOURCE
        #include &lt;sched.h&gt;
        #undef _GNU_SOURCE
    #<B><FONT COLOR="#A020F0">else</FONT></B>
        #include &lt;sched.h&gt;
    #endif
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;functional&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;chrono&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;unistd.h&gt;</FONT></B>              //Needed for, amongst other things, fcntl().
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;errno.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/ioctl.h&gt;</FONT></B>           //Needed for ioctl() for getting server address from within server code.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;net/if.h&gt;</FONT></B>              //Needed (along with ioctl()).
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/types.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/socket.h&gt;</FONT></B>          //Needed for send()/recv().
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;netinet/in.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;netdb.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;arpa/inet.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/wait.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;signal.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/mman.h&gt;</FONT></B>            //Needed for mmap()
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sched.h&gt;</FONT></B>               //Needed for unshare()
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;fcntl.h&gt;</FONT></B>               //Needed for fcntl()

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">USE_OWN_GETIFADDR</FONT>   //<FONT COLOR="#B8860B">Else</FONT>: <FONT COLOR="#B8860B">see</FONT> <FONT COLOR="#B8860B">below</FONT> <FONT COLOR="#B8860B">for</FONT> <FONT COLOR="#B8860B">a</FONT> <FONT COLOR="#B8860B">homebrew</FONT>...
    #include &lt;ifaddrs.h&gt;
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
    #include <B><FONT COLOR="#BC8F8F">&quot;External/getifaddrs.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>



<I><FONT COLOR="#B22222">//#include &lt;malloc.h&gt;    ///-------\/
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stdlib.h&gt;</FONT></B>  //Clang 4.3 on FreeBSD: '/usr/include/malloc.h:3:2: error: <B><FONT COLOR="#BC8F8F">&quot;&lt;malloc.h&gt; has been replaced by &lt;stdlib.h&gt;&quot;</FONT></B>'

<I><FONT COLOR="#B22222">//For FreeBSD missing IPV6_ADD_MEMBERSHIP.
</FONT></I><I><FONT COLOR="#B22222">//See: http://code.dyne.org/hdsync/plain/src/pgm/sockaddr.c for origin of this blurb.
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> !<B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B"> IPV6_ADD_MEMBERSHIP </FONT>)
    #<B><FONT COLOR="#A020F0">if</FONT></B> defined( IPV6_JOIN_GROUP )
        #define  IPV6_ADD_MEMBERSHIP   IPV6_JOIN_GROUP
        #define  IPV6_DROP_MEMBERSHIP  IPV6_LEAVE_GROUP
    #<B><FONT COLOR="#A020F0">else</FONT></B>
        #error <B><FONT COLOR="#BC8F8F">&quot;Neither IPV6_ADD_MEMBERSHIP or IPV6_JOIN_GROUP defined.&quot;</FONT></B>
    #endif
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

 
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>              //Needed for FUNCINFO, FUNCWARN, FUNCERR macro functions.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B>            //Needed for Xtostring(), some tokenization routines.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorFilesDirs.h&quot;</FONT></B>         //Needed for LoadFileToString(...), Size_of_File(...)
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorAlgorithms.h&quot;</FONT></B>        //Needed for shuffle_list_randomly(...)

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorURITools.h&quot;</FONT></B>            //Needed for Request_URL(...)

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorNetworking.h&quot;</FONT></B>


<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> YGORNETWORKING_VERBOSE;


#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGORNETWORKING_CLONE_STACK_SIZE</FONT>
    <I><FONT COLOR="#B22222">//Define a 128kB stack. Can be modified at compile time.
</FONT></I>    #define YGORNETWORKING_CLONE_STACK_SIZE (128*1024)
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">PLAUSIBLE_USER_AGENT</FONT> std::string(<B><FONT COLOR="#BC8F8F">&quot;Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4&quot;</FONT></B>)


<I><FONT COLOR="#B22222">//Some basic string functions to construct canned requests, responses, etc..
</FONT></I>
std::string Basic_HTTP_Request_Header(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;hostandport){
    <B><FONT COLOR="#A020F0">return</FONT></B> Basic_HTTP_Request_Header(hostandport, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
}
std::string Basic_HTTP_Request_Header(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;hostandport, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;request){
    <I><FONT COLOR="#B22222">//NOTE: hostandport should be in the form of &quot;127.0.0.1:8080&quot;.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//The following is a sample request from Chromium browser with url &quot;http://127.0.0.1:8080&quot;
</FONT></I>    <I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------------------
</FONT></I>    <I><FONT COLOR="#B22222">//GET / HTTP/1.1
</FONT></I>    <I><FONT COLOR="#B22222">//Host: 127.0.0.1:8080
</FONT></I>    <I><FONT COLOR="#B22222">//Connection: keep-alive
</FONT></I>    <I><FONT COLOR="#B22222">//User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.57 Safari/537.1
</FONT></I>    <I><FONT COLOR="#B22222">//Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
</FONT></I>    <I><FONT COLOR="#B22222">//Accept-Encoding: gzip,deflate,sdch
</FONT></I>    <I><FONT COLOR="#B22222">//Accept-Language: en-US,en;q=0.8
</FONT></I>    <I><FONT COLOR="#B22222">//Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------------------
</FONT></I>    <I><FONT COLOR="#B22222">//Other resources are: http://upload.wikimedia.org/wikipedia/commons/c/c6/Http_request_telnet_ubuntu.png ,
</FONT></I>    <I><FONT COLOR="#B22222">// http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Example_session ,
</FONT></I>    <I><FONT COLOR="#B22222">// http://www.jmarshall.com/easy/http/ , etc..
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    out += <B><FONT COLOR="#BC8F8F">&quot;GET /&quot;</FONT></B>;
    out += request;
<I><FONT COLOR="#B22222">//    out += &quot; HTTP/1.1\n&quot;;
</FONT></I>    out += <B><FONT COLOR="#BC8F8F">&quot; HTTP/1.0\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Host: &quot;</FONT></B>;
    out += hostandport + <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;User-Agent: &quot;</FONT></B>_s + PLAUSIBLE_USER_AGENT + <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>_s;
<I><FONT COLOR="#B22222">//    out += &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.57 Safari/537.1\n&quot;;
</FONT></I>    out += <B><FONT COLOR="#BC8F8F">&quot;Accept: text/html,application/xhtml+xml,application/xml\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Accept-Language: en-US,en\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Accept-Charset: ISO-8859-1,utf-8\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;  <I><FONT COLOR="#B22222">//This empty line is required! 
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::string Basic_HTTP_Response_Text_Header(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;thetext){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    <I><FONT COLOR="#B22222">//out += &quot;HTTP/1.1 200 OK\n&quot;;
</FONT></I>    out += <B><FONT COLOR="#BC8F8F">&quot;HTTP/1.0 200 OK\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Server: Apache\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Content-Language: en\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Content-Length: &quot;</FONT></B>;
    out += Xtostring&lt;size_t&gt;(thetext.size()) + <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Content-Type: text/html; charset=utf-8\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Connection: close\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;  <I><FONT COLOR="#B22222">//This empty line is required! 
</FONT></I>    out += thetext + <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::string Basic_HTTP_Response_File_Header(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;

<I><FONT COLOR="#B22222">//    const std::string mimetype = Execute_Command_In_Pipe( std::string(&quot; file -b --mime-type '&quot;) + filename + &quot;'&quot;);
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> std::string mimetype = Guess_Mime_Type(filename); <I><FONT COLOR="#B22222">//Execute_Command_In_Pipe(&quot; file -b --mime-type -- &quot;_s + Quote_Static_for_Bash(filename) + &quot; | tr -d '\\\n' &quot;_s);
</FONT></I><I><FONT COLOR="#B22222">///////////////////
</FONT></I><I><FONT COLOR="#B22222">//    const std::string thetext = LoadFileToString(filename);
</FONT></I><I><FONT COLOR="#B22222">///////////////////
</FONT></I><I><FONT COLOR="#B22222">//    std::string thetext;
</FONT></I><I><FONT COLOR="#B22222">//    const auto filesize = Size_of_File(filename);
</FONT></I><I><FONT COLOR="#B22222">//    const auto mem_ptr  = Get_Piece_of_Binary_File&lt;char&gt;(filename, 0, filesize);
</FONT></I><I><FONT COLOR="#B22222">//    thetext.clear();
</FONT></I><I><FONT COLOR="#B22222">//    thetext.insert(thetext.size(), mem_ptr.get(), filesize);
</FONT></I><I><FONT COLOR="#B22222">////////////////////
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> std::string thetext = LoadBinaryFileToString(filename);

    <I><FONT COLOR="#B22222">//out += &quot;HTTP/1.1 200 OK\r\n&quot;;
</FONT></I>    out += <B><FONT COLOR="#BC8F8F">&quot;HTTP/1.0 200 OK\r\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Server: Apache\r\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Content-Language: en\r\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Content-Length: &quot;</FONT></B>;
    out += Xtostring&lt;size_t&gt;(thetext.size()) + <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>;

    out += <B><FONT COLOR="#BC8F8F">&quot;Content-Type: &quot;</FONT></B>;
    out += mimetype;
    out += <B><FONT COLOR="#BC8F8F">&quot;; charset=utf-8\r\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Connection: close\r\n&quot;</FONT></B>;

    <I><FONT COLOR="#B22222">//Empty line delineating header from content.
</FONT></I>    out += <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>;

    <I><FONT COLOR="#B22222">//Whatever the content is, stuffed into a string.
</FONT></I>    out += thetext;
    out += <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>;  
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::string Basic_HTTP_Response_File_Header_Only(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    <B><FONT COLOR="#228B22">const</FONT></B> std::string mimetype = Guess_Mime_Type(filename); <I><FONT COLOR="#B22222">//Execute_Command_In_Pipe(&quot; file -b --mime-type -- &quot;_s + Quote_Static_for_Bash(filename) + &quot; | tr -d '\\\n' &quot;_s);
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> thesize = Size_of_File(filename);

    out += <B><FONT COLOR="#BC8F8F">&quot;HTTP/1.1 200 OK\r\n&quot;</FONT></B>;
<I><FONT COLOR="#B22222">//    out += &quot;Server: Apache\r\n&quot;;
</FONT></I><I><FONT COLOR="#B22222">//    out += &quot;Content-Language: en\r\n&quot;;
</FONT></I>
    out += <B><FONT COLOR="#BC8F8F">&quot;Content-Type: &quot;</FONT></B>;
    out += mimetype;
<I><FONT COLOR="#B22222">//    out += &quot;; charset=utf-8\r\n&quot;;
</FONT></I>    out += <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>;

    out += <B><FONT COLOR="#BC8F8F">&quot;Accept-Ranges: bytes\r\n&quot;</FONT></B>;  <I><FONT COLOR="#B22222">//Advertise that we can also serve byte-by-byte.
</FONT></I>
    out += <B><FONT COLOR="#BC8F8F">&quot;Content-Length: &quot;</FONT></B>;
    out += Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(thesize) + <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>;

    out += <B><FONT COLOR="#BC8F8F">&quot;Connection: close\r\n&quot;</FONT></B>;   <I><FONT COLOR="#B22222">//*Might* be killing mplayer streaming. Unsure. If everything seems OK, uncomment.  BE WEARY OF THIS LINE...
</FONT></I><I><FONT COLOR="#B22222">//    out += &quot;Connection: keep-alive\r\n&quot;;
</FONT></I>
    <I><FONT COLOR="#B22222">//Empty line delineating header from content.
</FONT></I>    out += <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>;
    <I><FONT COLOR="#B22222">//Don't forget to append the actual file at this point!
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::string Range_HTTP_Response_File_Header_Only(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename, off_t range_l, off_t range_u){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    <B><FONT COLOR="#228B22">const</FONT></B> std::string mimetype = Guess_Mime_Type(filename);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> thesize = Size_of_File(filename);

<I><FONT COLOR="#B22222">/*   Sample from YouTube.
   HTTP/1.1 206 Partial Content^M
   Last-Modified: Tue, 06 Sep 2011 18:47:36 GMT^M
   Content-Type: video/x-flv^M
   Date: Sun, 20 Jan 2013 22:28:09 GMT^M
   Expires: Sun, 20 Jan 2013 22:28:09 GMT^M
   Cache-Control: private, max-age=22409^M
   Content-Range: bytes 500-999/1018965^M
   Accept-Ranges: bytes^M
   Content-Length: 500^M
   Connection: close^M
   X-Content-Type-Options: nosniff^M
   Server: gvs 1.0^M
*/</FONT></I>

    out += <B><FONT COLOR="#BC8F8F">&quot;HTTP/1.1 206 Partial Content\r\n&quot;</FONT></B>;
    out += <B><FONT COLOR="#BC8F8F">&quot;Content-Type: &quot;</FONT></B>_s + mimetype;
<I><FONT COLOR="#B22222">//    out += &quot;; charset=utf-8\r\n&quot;;
</FONT></I>    out += <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>;

    out += <B><FONT COLOR="#BC8F8F">&quot;Content-Range: bytes &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(range_l) + <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(range_u);
    out += <B><FONT COLOR="#BC8F8F">&quot;/&quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(thesize) + <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>_s;

    out += <B><FONT COLOR="#BC8F8F">&quot;Accept-Ranges: bytes\r\n&quot;</FONT></B>;

    out += <B><FONT COLOR="#BC8F8F">&quot;Content-Length: &quot;</FONT></B>;
    out += Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(range_u-range_l+1) + <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>;

    out += <B><FONT COLOR="#BC8F8F">&quot;Connection: close\r\n&quot;</FONT></B>;    <I><FONT COLOR="#B22222">//I think it is somehow more important to close the connection after serving the specified range.  (?) :/ 
</FONT></I><I><FONT COLOR="#B22222">//    out += &quot;Connection: keep-alive\r\n&quot;;
</FONT></I>
    out += <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>;   <I><FONT COLOR="#B22222">//Empty line delineating header from content.
</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> out;  <I><FONT COLOR="#B22222">//Don't forget to append the actual file at this point!
</FONT></I>}



<I><FONT COLOR="#B22222">//Some simple, no-nonsense, low-customizability routines for HTTP requests.
</FONT></I>std::string Simple_HTTP_Request(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;host, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;request){
    <I><FONT COLOR="#B22222">//This function is extremely low-tech, and extremely unreliable. Do not use it for anything important.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//As an example, requesting 'http://icanhazip.com/' would be called like:
</FONT></I>    <I><FONT COLOR="#B22222">//   ... = Simple_HTTP_Request(&quot;icanhazip.com/&quot;, &quot;&quot;);
</FONT></I>
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string result;
    <B><FONT COLOR="#228B22">auto</FONT></B> dialog = [&amp;](<B><FONT COLOR="#228B22">int</FONT></B> fd, <B><FONT COLOR="#228B22">char</FONT></B> *host, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> {
        <B><FONT COLOR="#228B22">int</FONT></B> nbytes;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> buffsz = 5000;
        <B><FONT COLOR="#228B22">char</FONT></B> buff[buffsz];

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string In_msg;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string Out_msg;

        <I><FONT COLOR="#B22222">//Construct a simple GET request. Dump it to screen.
</FONT></I>        Out_msg = Basic_HTTP_Request_Header(std::string(host)+<B><FONT COLOR="#BC8F8F">&quot;:80&quot;</FONT></B>,request);

        <I><FONT COLOR="#B22222">//Send the request to the server.     
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( send(fd,Out_msg.c_str(),Out_msg.size(),MSG_NOSIGNAL) == -1){ <B><FONT COLOR="#A020F0">return</FONT></B> false; }

        <I><FONT COLOR="#B22222">//Collect the (entire) response. Dump it to screen and sepuku.
</FONT></I>        <B><FONT COLOR="#A020F0">while</FONT></B>((nbytes = recv(fd,buff,buffsz-1,0)) != -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(nbytes == 0) <B><FONT COLOR="#A020F0">break</FONT></B>;
            buff[nbytes]=<B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
            In_msg += std::string(buff,nbytes);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>(In_msg.size() == 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;  <I><FONT COLOR="#B22222">//If something did not work and we got zilch!
</FONT></I>
        <I><FONT COLOR="#B22222">//The resulting response includes the HTTP header (&quot;GET ... &quot; etc..). We can split 
</FONT></I>        <I><FONT COLOR="#B22222">// based on an empty line between the header and the content, which is required.
</FONT></I>        <I><FONT COLOR="#B22222">// If the header pops up somewhere it shouldn't be then there is likely an extra
</FONT></I>        <I><FONT COLOR="#B22222">// empty line prior to (or within) the header.
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> tokenized = SplitStringToVector(In_msg, R<B><FONT COLOR="#BC8F8F">&quot;***(^$)***&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">'d'</FONT></B>);
        In_msg.clear();
        <I><FONT COLOR="#B22222">//Skip the first token. This should be the header.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = ++(tokenized.begin()); it != tokenized.end(); ++it) In_msg += *it;
        result = In_msg;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    };

    <I><FONT COLOR="#B22222">//Now we construct a client class.
</FONT></I>    <B><FONT COLOR="#228B22">class</FONT></B> Server_and_Client oneoff;

    <I><FONT COLOR="#B22222">//Initialize the client.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!oneoff.Client_Init(80, dialog)){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to initialize client&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> result;
    }

    <I><FONT COLOR="#B22222">//Attempt to connect to the server and interact with it.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!oneoff.Client_Connect(host)){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to connect&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> result;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> result;
}

std::string Simple_HTTPS_Request(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;host, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;port, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;request){   <I><FONT COLOR="#B22222">//Currently implemented using pipe/wget! FIXME
</FONT></I>    <I><FONT COLOR="#B22222">//Example:   &quot;127.0.0.1&quot;, &quot;443&quot;, &quot;some/resource/or/file.html&quot;.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string req = <B><FONT COLOR="#BC8F8F">&quot;https://&quot;</FONT></B>_s + host;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!port.empty()) req += <B><FONT COLOR="#BC8F8F">&quot;:&quot;</FONT></B>_s + port;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!request.empty()) req += <B><FONT COLOR="#BC8F8F">&quot;/&quot;</FONT></B>_s + request;

    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;REQUESTING: '&quot;</FONT></B> &lt;&lt; req &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> Request_URL(req);
}

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------- IP Address utilities ---------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//The 'local' routines check the local machine for the dhcp/static address.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//The output is in format:   &lt;network name&gt;, &lt;address&gt;
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//An example is 'eth0', '192.168.0.123'.
</FONT></I>std::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Get_All_Local_IP4_Addresses(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//Returns a list of &lt;device names, addresses&gt;.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; out;
    <B><FONT COLOR="#228B22">struct</FONT></B> ifaddrs *ifaddr, *ifa;
    <B><FONT COLOR="#228B22">char</FONT></B> host[NI_MAXHOST];
    <B><FONT COLOR="#A020F0">if</FONT></B>(getifaddrs(&amp;ifaddr) == -1){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to get local IP4 addresses (err 1) - continuing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> out;
    }
    <B><FONT COLOR="#A020F0">for</FONT></B>(ifa = ifaddr; ifa != nullptr; ifa = ifa-&gt;ifa_next){
        <B><FONT COLOR="#A020F0">if</FONT></B>(ifa-&gt;ifa_addr == nullptr) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#228B22">int</FONT></B> family = ifa-&gt;ifa_addr-&gt;sa_family;
        <B><FONT COLOR="#A020F0">if</FONT></B>(family == AF_INET){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> size = <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr_in);
            <B><FONT COLOR="#228B22">int</FONT></B> s = getnameinfo(ifa-&gt;ifa_addr, size, host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
            <B><FONT COLOR="#A020F0">if</FONT></B>(s != 0){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to get local IP4 addresses (err 2) - continuing&quot;</FONT></B>);
                freeifaddrs(ifaddr);
                <B><FONT COLOR="#A020F0">return</FONT></B> out;
            }
            out.push_back(std::pair&lt;std::string, std::string&gt;(ifa-&gt;ifa_name, host));
        }
    }
    freeifaddrs(ifaddr);
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Get_All_Local_IP6_Addresses(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//Returns a list of &lt;device names, addresses&gt;.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; out;
    <B><FONT COLOR="#228B22">struct</FONT></B> ifaddrs *ifaddr, *ifa;
    <B><FONT COLOR="#228B22">char</FONT></B> host[NI_MAXHOST];
    <B><FONT COLOR="#A020F0">if</FONT></B>(getifaddrs(&amp;ifaddr) == -1){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to get local IP6 addresses (err 1) - continuing&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> out;
    }
    <B><FONT COLOR="#A020F0">for</FONT></B>(ifa = ifaddr; ifa != nullptr; ifa = ifa-&gt;ifa_next){
        <B><FONT COLOR="#A020F0">if</FONT></B>(ifa-&gt;ifa_addr == nullptr) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#228B22">int</FONT></B> family = ifa-&gt;ifa_addr-&gt;sa_family;
        <B><FONT COLOR="#A020F0">if</FONT></B>(family == AF_INET6){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> size = <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr_in6);
            <B><FONT COLOR="#228B22">int</FONT></B> s = getnameinfo(ifa-&gt;ifa_addr, size, host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
            <B><FONT COLOR="#A020F0">if</FONT></B>(s != 0){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to get local IP6 addresses (err 2) - continuing&quot;</FONT></B>);
                freeifaddrs(ifaddr);
                <B><FONT COLOR="#A020F0">return</FONT></B> out;
            }
            out.push_back(std::pair&lt;std::string, std::string&gt;(ifa-&gt;ifa_name, host));
        }
    }
    freeifaddrs(ifaddr);
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Get_All_Local_IP_Addresses(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//Returns a list of &lt;device names, addresses&gt;.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> out = Get_All_Local_IP4_Addresses();
    out.splice(out.end(), Get_All_Local_IP6_Addresses());
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Get_All_Distant_IP_Addresses(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt;&gt; out;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;std::string&gt; candidates;

    <I><FONT COLOR="#B22222">//We try a few websites until we get something which looks reasonable. Add as many
</FONT></I>    <I><FONT COLOR="#B22222">// as possible. We will 
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::string&gt; sites({  <B><FONT COLOR="#BC8F8F">&quot;http://icanhazip.com/&quot;</FONT></B>, 
                                    <B><FONT COLOR="#BC8F8F">&quot;http://checkip.dyndns.com/&quot;</FONT></B>,
                                    <B><FONT COLOR="#BC8F8F">&quot;http://automation.whatismyip.com/n09230945.asp&quot;</FONT></B>,
                                    <B><FONT COLOR="#BC8F8F">&quot;http://ifconfig.me/ip&quot;</FONT></B>,
                                    <B><FONT COLOR="#BC8F8F">&quot;http://ip.appspot.com/&quot;</FONT></B>,
                                    <B><FONT COLOR="#BC8F8F">&quot;http://myip.dnsomatic.com/&quot;</FONT></B>,

                                    <I><FONT COLOR="#B22222">//These *appear* to be less reliable. Meh, we'll error check.
</FONT></I>                                    <B><FONT COLOR="#BC8F8F">&quot;http://www.joetesta.com/user.php&quot;</FONT></B>,
                                    <B><FONT COLOR="#BC8F8F">&quot;http://sputnick-area.net/ip&quot;</FONT></B>
                                    
    });

    <I><FONT COLOR="#B22222">//Shuffle the list randomly to spread out the load as much as possible.
</FONT></I>    shuffle_list_randomly(sites); 

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = sites.begin(); s_it != sites.end(); ++s_it){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> page = Request_URL(*s_it);
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> address = GetFirstRegex(page, <B><FONT COLOR="#BC8F8F">&quot;([0-9]{1,3}[.][0-9]{1,3}[.][0-9]{1,3}[.][0-9]{1,3})&quot;</FONT></B>);

        <B><FONT COLOR="#A020F0">if</FONT></B>(!address.empty()){
            <I><FONT COLOR="#B22222">//Check if the address already exists in the set. If so, it is probably correct.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(candidates.find(address) != candidates.end()){
                out.push_back(std::pair&lt;std::string, std::string&gt;(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, address));
                <B><FONT COLOR="#A020F0">return</FONT></B> out;

            <I><FONT COLOR="#B22222">//Otherwise, keep going until we find a match.
</FONT></I>            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                candidates.insert(address);
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------- Server_and_Client: a TCP networking class -----------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//General helper member functions.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> *<B><FONT COLOR="#0000FF">Server_and_Client::Get_in_addr</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr *sa_in){
    <B><FONT COLOR="#A020F0">if</FONT></B>(sa_in-&gt;sa_family == AF_INET) {
        <B><FONT COLOR="#A020F0">return</FONT></B> &amp;(((<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr_in*)sa_in)-&gt;sin_addr);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> &amp;(((<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr_in6*)sa_in)-&gt;sin6_addr);
}

<I><FONT COLOR="#B22222">//Constructors and Destructor.
</FONT></I><B><FONT COLOR="#0000FF">Server_and_Client::Server_and_Client</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) : SERVER_INITIALIZED(false), SERVER_PORT(3490), SERVER_BACKLOG(100), 
                                             SERVER_yes(1), CLIENT_INITIALIZED(false), CLIENT_PORT(3490)  {

    <I><FONT COLOR="#B22222">//Set the default timeouts. The server's accept() timeout needs to be set *prior* to
</FONT></I>    <I><FONT COLOR="#B22222">// initialization. All send() and recv() timeouts can be adjusted before OR after init.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: These times can be modified to suit, even passed in as parameters to this member
</FONT></I>    <I><FONT COLOR="#B22222">// if so desired.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: If the total time is zero, it is interpretted as &quot;wait forever.&quot;
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: They are oddly staggered so we can help diagnose issues by timing things. There
</FONT></I>    <I><FONT COLOR="#B22222">// is no other significance to the stagger.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_accept_timeout_sec   = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_accept_timeout_usec  = 0;

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_recv_timeout_sec     = 60;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_recv_timeout_usec    = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_send_timeout_sec     = 63;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_send_timeout_usec    = 0;

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_recv_timeout_sec     = 67;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_recv_timeout_usec    = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_send_timeout_sec     = 70;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_send_timeout_usec    = 0;
    


    <I><FONT COLOR="#B22222">//Provide some sane default dialog routines. These do not have to be fancy, they just
</FONT></I>    <I><FONT COLOR="#B22222">// need to work and do something basic but non-trivial.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_SERVER_DIALOG_LAMBDA = [&amp;](<B><FONT COLOR="#228B22">int</FONT></B> fd, <B><FONT COLOR="#228B22">char</FONT></B> *host, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> {

        <I><FONT COLOR="#B22222">//Upon connection, we immediately send a message to the client.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(send(fd, <B><FONT COLOR="#BC8F8F">&quot;This is the default dialog response!&quot;</FONT></B>, 39, MSG_NOSIGNAL) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server unable to send() to client&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }

        <I><FONT COLOR="#B22222">//We do not wait around for a response.
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    };

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_CLIENT_DIALOG_LAMBDA = [&amp;](<B><FONT COLOR="#228B22">int</FONT></B> fd, <B><FONT COLOR="#228B22">char</FONT></B> *host, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> {
        <B><FONT COLOR="#228B22">int</FONT></B> numbytes;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> BUFFSIZE = 100;
        <B><FONT COLOR="#228B22">char</FONT></B> buff[BUFFSIZE];

        <I><FONT COLOR="#B22222">//Upon connection, we immediately receive a message from the server.
</FONT></I>        <I><FONT COLOR="#B22222">// Ensure the buffer can easily be null-terminated without loss of any bytes.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>((numbytes = recv(fd, buff, BUFFSIZE-1, 0)) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Client connection issue. Nothing was received&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
        buff[numbytes] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
        <I><FONT COLOR="#B22222">//if(YGORNETWORKING_VERBOSE) FUNCINFO(&quot;Received message from server: '&quot; &lt;&lt; buff &lt;&lt; &quot;'&quot;);
</FONT></I>
        <I><FONT COLOR="#B22222">//We do not send an acknowledgement or response.
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    };

 }

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Server-specific member functions.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Server_Init</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Server_Init( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_PORT, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_SERVER_DIALOG_LAMBDA );
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Server_Init</FONT></B>(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; server_dialog){
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Server_Init( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_PORT, server_dialog );
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Server_Init</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port, std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; server_dialog){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_PORT = port;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_SERVER_DIALOG_LAMBDA = server_dialog;

    <I><FONT COLOR="#B22222">//This member function will initialize the server, preparing it to park and listen for
</FONT></I>    <I><FONT COLOR="#B22222">// incoming connections. 
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Whether or not a previous initialization has occured, this function will 'start from
</FONT></I>    <I><FONT COLOR="#B22222">// scratch' by wiping out the previous initialization. This is desirable in case the 
</FONT></I>    <I><FONT COLOR="#B22222">// network somehow falls out from under our feet after initial initialization.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//This function returns 'true' if everything was OK and 'false' if any error arises.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_INITIALIZED = false;

    memset(&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_hints, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(SERVER_hints));
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_hints.ai_family     = AF_UNSPEC;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_hints.ai_socktype   = SOCK_STREAM;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_hints.ai_flags      = AI_PASSIVE;     <I><FONT COLOR="#B22222">//Use my IP
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> std::string PORT_STRING = Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_PORT);
    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_rv = getaddrinfo(NULL, PORT_STRING.c_str(), &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_hints, &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_servinfo)) != 0) {
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;getaddrinfo returned error &quot;</FONT></B> &lt;&lt; gai_strerror(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_rv) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;. Unable to initialize server&quot;</FONT></B>);
        freeaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_servinfo);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <I><FONT COLOR="#B22222">//Loop through all the results and bind to the first we can. Break on success.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_p = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_servinfo; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_p != nullptr; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_p = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_p-&gt;ai_next){
        <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sockfd = socket(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_p-&gt;ai_family, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_p-&gt;ai_socktype, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_p-&gt;ai_protocol)) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server socket issue. Continuing&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }

        <I><FONT COLOR="#B22222">//Attempt to tell the kernel to reuse addresses (so we can quickly reboot the program and reuse the address 
</FONT></I>        <I><FONT COLOR="#B22222">// if we need to.)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(setsockopt(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sockfd, SOL_SOCKET, SO_REUSEADDR, (<B><FONT COLOR="#228B22">void</FONT></B> *)&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_yes, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B>)) == -1) {
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;setsockopt issue (unable to force address reuse). Unable to initialize server&quot;</FONT></B>);
            freeaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_servinfo);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }

        <I><FONT COLOR="#B22222">//Attempt to set the waiting server's timeouts.
</FONT></I>        <I><FONT COLOR="#B22222">//NOTE: These are NOT the send/recv timeouts, this is the accept() timeout!
</FONT></I>        <B><FONT COLOR="#228B22">struct</FONT></B> timeval timeshuttle;<I><FONT COLOR="#B22222">// = {0};
</FONT></I>        memset(&amp;timeshuttle, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(timeshuttle));
        timeshuttle.tv_sec  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_accept_timeout_sec;
        timeshuttle.tv_usec = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_accept_timeout_usec;
        <B><FONT COLOR="#A020F0">if</FONT></B>(setsockopt(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sockfd, SOL_SOCKET, SO_RCVTIMEO, (<B><FONT COLOR="#228B22">void</FONT></B> *)&amp;timeshuttle, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> timeval)) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;setsockopt issue (unable to specify accept timeout). Unable to initialize server&quot;</FONT></B>);
            freeaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_servinfo);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }

        <B><FONT COLOR="#A020F0">if</FONT></B>(bind(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_p-&gt;ai_addr, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_p-&gt;ai_addrlen) == -1){
            close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sockfd);
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server bind issue. Continuing&quot;</FONT></B>); <I><FONT COLOR="#B22222">//This will commonly occur if the port choice is illegal!
</FONT></I>            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }

        <B><FONT COLOR="#A020F0">break</FONT></B>;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_p == nullptr){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server bind issue. Unable to initialize server&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <I><FONT COLOR="#B22222">//We can free this structure now.
</FONT></I>    freeaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_servinfo);

    <I><FONT COLOR="#B22222">//Set the close-on-exec flag so that server programs can execv and not consume/hold onto the port.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(fcntl(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sockfd, F_SETFD, FD_CLOEXEC) == -1){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempting to set close-on-exec flag failed. This shouldn't happen, so the file descriptor is likely invalid&quot;</FONT></B>);
    }

    <I><FONT COLOR="#B22222">//Ignore SIGPIPE's (as in, if one arises, allow us to handle it locally via the send(...) return error EPIPE.
</FONT></I>    signal(SIGPIPE, SIG_IGN);

    <B><FONT COLOR="#A020F0">if</FONT></B>(listen(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_BACKLOG) == -1){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server listen issue. Unable to initialize server&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <I><FONT COLOR="#B22222">//&quot;Reap&quot; all dead processes.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> handler_lambda = [](<B><FONT COLOR="#228B22">int</FONT></B> s) -&gt; <B><FONT COLOR="#228B22">void</FONT></B> {  <B><FONT COLOR="#A020F0">while</FONT></B>(waitpid(-1, NULL, WNOHANG) &gt; 0){ }; };
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sa.sa_handler = handler_lambda; <I><FONT COLOR="#B22222">//[](int s) -&gt; void {  while(waitpid(-1, NULL, WNOHANG) &gt; 0){
</FONT></I>
    sigemptyset(&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sa.sa_mask);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sa.sa_flags = SA_RESTART;
    <B><FONT COLOR="#A020F0">if</FONT></B>(sigaction(SIGCHLD, &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sa, NULL) == -1){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server sigaction issue. Unable to initialize server&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_INITIALIZED = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}


<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Server_Wait_for_Connection</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//This member function waits for a (single) connection from a client. It forks/clones/threads/etc.. off
</FONT></I>    <I><FONT COLOR="#B22222">// a process to handle the connection in a separate thread.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_INITIALIZED != true){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server initialization has not been performed. Unable to wait for connection&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sin_size = <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_their_addr);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd = accept(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sockfd, (<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr *)&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_their_addr, &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sin_size);
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd == -1) {
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server encountered an accept() issue. Unable to establish connection&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <I><FONT COLOR="#B22222">//Set the close-on-exec flag so that servers can execv and not consume/hold onto the port.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(fcntl(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd, F_SETFD, FD_CLOEXEC) == -1){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempting to set accept()'d close-on-exec flag failed. This shouldn't happen, so the file descriptor is likely invalid&quot;</FONT></B>);
    }

    inet_ntop(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_their_addr.ss_family, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Get_in_addr((<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr *)&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_their_addr), <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s));
    <I><FONT COLOR="#B22222">//Ensure the string is null-terminated. An extra char exists to make this safely able to hold the maximum address size and an '\0'.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s[<B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s)-1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
    <I><FONT COLOR="#B22222">//if(VERBOSE) if(YGORNETWORKING_VERBOSE) FUNCINFO(&quot;Received connection from &quot; &lt;&lt; this-&gt;SERVER_s);
</FONT></I>
    <I><FONT COLOR="#B22222">//Look if the host is in the blocklist. If it is, do not proceed.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist_Mutex.lock();
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist.find(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s) != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist.end()){
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist_Mutex.unlock();
        close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd);
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist_Mutex.unlock();

    <I><FONT COLOR="#B22222">//Attempt to set the timeouts for the new fd.
</FONT></I>    <B><FONT COLOR="#228B22">struct</FONT></B> timeval timeshuttle;<I><FONT COLOR="#B22222">// = {0};
</FONT></I>    memset(&amp;timeshuttle, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(timeshuttle));
    timeshuttle.tv_sec  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_recv_timeout_sec;
    timeshuttle.tv_usec = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_recv_timeout_usec;
    <B><FONT COLOR="#A020F0">if</FONT></B>(setsockopt(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeshuttle, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> timeval)) == -1){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;setsockopt issue. Unable to specify recv timeout&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    timeshuttle.tv_sec  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_send_timeout_sec;
    timeshuttle.tv_usec = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_send_timeout_usec;
    <B><FONT COLOR="#A020F0">if</FONT></B>(setsockopt(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeshuttle, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> timeval)) == -1){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;setsockopt issue. Unable to specify send timeout&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

<I><FONT COLOR="#B22222">/*
//This code is used to try to determine the server's own address (the one being used to talk to the client.)
// I'm pretty sure it doesn't work, and I don't know if I need it right now anyways...
//----------------------
{
//See http://stackoverflow.com/questions/4937529/polling-interface-names-via-siocgifconf-in-linux
//
//and maybe also:
//
//http://linux.die.net/man/7/netdevice
//http://stackoverflow.com/questions/212528/get-the-ip-address-of-the-machine
//http://stackoverflow.com/questions/4046616/sockets-how-to-find-out-what-port-and-address-im-assigned
//  in this order.

//TODO: Convert this shit into a separate routine which takes file descriptors (from streams) and returns 
// the list of possible addresses.

//BUT FIRST CHECK: Does this even do what I think it does? How could I test it?? Will it only
// return addresses which could be used to connect to the server?

    struct ifconf conf;
    char data[4096];
    
    struct ifreq *ifr;
    char addrbuf[1024];
    
    conf.ifc_len = sizeof(data);
    conf.ifc_buf = (caddr_t)data;
    if(ioctl(this-&gt;SERVER_new_fd,SIOCGIFCONF,&amp;conf) != -1){
//    if(ioctl(this-&gt;SERVER_sockfd,SIOCGIFCONF,&amp;conf) != -1){
        int i = 0;
        ifr = (struct ifreq *)data;
        while((char*)ifr &lt; (data + conf.ifc_len)){
            switch(ifr-&gt;ifr_addr.sa_family){
                case AF_INET:
                    ++i;
                    printf(&quot;%d. %s : %s\n&quot;, i, ifr-&gt;ifr_name, inet_ntop(ifr-&gt;ifr_addr.sa_family, &amp;((struct sockaddr_in*)&amp;ifr-&gt;ifr_addr)-&gt;sin_addr, addrbuf, sizeof(addrbuf)));
                    break;
                case AF_INET6:
                    ++i;
                    printf(&quot;%d. %s : %s\n&quot;, i, ifr-&gt;ifr_name, inet_ntop(ifr-&gt;ifr_addr.sa_family, &amp;((struct sockaddr_in6*)&amp;ifr-&gt;ifr_addr)-&gt;sin6_addr, addrbuf, sizeof(addrbuf)));
                    break;
            }
            ifr = (struct ifreq*)((char*)ifr + sizeof(*ifr));
        }
    
    }

    //return list of pairs of device names, addresses...
}
//-----------------------
*/</FONT></I>



#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">defined</FONT> <FONT COLOR="#B8860B">YGORNETWORKING_USE_FORK</FONT>
    <I><FONT COLOR="#B22222">//Just fork and execute the lambda!
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!fork()){
        <I><FONT COLOR="#B22222">//----------------------------- Child Process Fence ---------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Stop listening for connections. Let the parent do so!
</FONT></I>        close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sockfd);

        <I><FONT COLOR="#B22222">//Ignore SIGPIPE's (as in, if one arises, allow us to handle it locally via the send(...) return error EPIPE.
</FONT></I>        signal(SIGPIPE, SIG_IGN);

        <I><FONT COLOR="#B22222">//Call the user's dialog lambda if it exists. Call the default otherwise.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_SERVER_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_SERVER_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_PORT )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server dialog provided by user failed&quot;</FONT></B>);
                <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>            }
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_SERVER_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_SERVER_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_PORT )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server default dialog failed&quot;</FONT></B>);
                <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>            }
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server could not dialog because no valid dialog routine is known&quot;</FONT></B>);
        }

        <I><FONT COLOR="#B22222">//Now we close up the connection to the client and terminate execution of the child.
</FONT></I>        close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd);

        <I><FONT COLOR="#B22222">//Finally, terminate execution of this process.
</FONT></I>        exit(0);
        <I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------
</FONT></I>    }

    <I><FONT COLOR="#B22222">//Only the parent will reach this point! Since the child will deal with the connection, we
</FONT></I>    <I><FONT COLOR="#B22222">// close the connection fd.
</FONT></I>    close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd);

#<B><FONT COLOR="#5F9EA0">elif</FONT></B> <FONT COLOR="#B8860B">defined</FONT> <FONT COLOR="#B8860B">YGORNETWORKING_USE_CLONE</FONT>

    #pragma message <B><FONT COLOR="#BC8F8F">&quot;############################################&quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot;Clone usage is not yet complete. DO NOT USE!&quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot;############################################&quot;</FONT></B>
    #error

    <I><FONT COLOR="#B22222">//Notes:
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">// -I found a nice, simple example of clone(2) online at http://www.linuxjournal.com/article/5211.
</FONT></I>    <I><FONT COLOR="#B22222">//  and http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/052/5211/5211l2.html.
</FONT></I>    <I><FONT COLOR="#B22222">//  Here it is:
</FONT></I>    <I><FONT COLOR="#B22222">//----------------------------------------
</FONT></I>    <I><FONT COLOR="#B22222">//#include         &lt;--- (Note that these are blank in the example.)
</FONT></I>    <I><FONT COLOR="#B22222">//#include 
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//int variable, fd;
</FONT></I>    <I><FONT COLOR="#B22222">//int do_something() {
</FONT></I>    <I><FONT COLOR="#B22222">//   variable = 42;
</FONT></I>    <I><FONT COLOR="#B22222">//   close(fd);
</FONT></I>    <I><FONT COLOR="#B22222">//   _exit(0);
</FONT></I>    <I><FONT COLOR="#B22222">//}
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//int main(int argc, char *argv[]) {
</FONT></I>    <I><FONT COLOR="#B22222">//   void **child_stack;
</FONT></I>    <I><FONT COLOR="#B22222">//   char tempch;
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//   variable = 9;
</FONT></I>    <I><FONT COLOR="#B22222">//   fd = open(&quot;test.file&quot;, O_RDONLY);
</FONT></I>    <I><FONT COLOR="#B22222">//   child_stack = (void **) malloc(16384);
</FONT></I>    <I><FONT COLOR="#B22222">//   printf(&quot;The variable was %d\n&quot;, variable);
</FONT></I>    <I><FONT COLOR="#B22222">//   
</FONT></I>    <I><FONT COLOR="#B22222">//   clone(do_something, child_stack, CLONE_VM|CLONE_FILES, NULL);
</FONT></I>    <I><FONT COLOR="#B22222">//   sleep(1);
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//   printf(&quot;The variable is now %d\n&quot;, variable);
</FONT></I>    <I><FONT COLOR="#B22222">//   if (read(fd, &amp;tempch, 1) &lt; 1) {
</FONT></I>    <I><FONT COLOR="#B22222">//      perror(&quot;File Read Error&quot;);
</FONT></I>    <I><FONT COLOR="#B22222">//      exit(1);
</FONT></I>    <I><FONT COLOR="#B22222">//   }
</FONT></I>    <I><FONT COLOR="#B22222">//   printf(&quot;We could read from the file\n&quot;);
</FONT></I>    <I><FONT COLOR="#B22222">//   return 0;
</FONT></I>    <I><FONT COLOR="#B22222">//}
</FONT></I>    <I><FONT COLOR="#B22222">//---------------------------------------
</FONT></I>    <I><FONT COLOR="#B22222">// -Upon getting the threads option to work, I can no longer remember *why* I wanted to use clone(2)
</FONT></I>    <I><FONT COLOR="#B22222">//  instead. Something about not sharing the file descriptors or something, but this is (in practice)
</FONT></I>    <I><FONT COLOR="#B22222">//  not an issue. Nonetheless, maybe I should finish it so I can both refer to it and maybe gain some
</FONT></I>    <I><FONT COLOR="#B22222">//  traction providing a middle-ground between fork() and thread().
</FONT></I>
<B><FONT COLOR="#0000FF">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Mapping the stack now&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">void</FONT></B> *Stack = mmap(nullptr, YGORNETWORKING_CLONE_STACK_SIZE, PROT_READ | PROT_WRITE, \
                                MAP_PRIVATE | MAP_ANON | MAP_GROWSDOWN, -1, 0);
<B><FONT COLOR="#0000FF">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;   ...mapping done&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">auto</FONT></B> Childs_Lambda = [](<B><FONT COLOR="#228B22">void</FONT></B> *arg) -&gt; <B><FONT COLOR="#228B22">int</FONT></B> {

<B><FONT COLOR="#0000FF">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Executing the child's lambda now&quot;</FONT></B>);

        <I><FONT COLOR="#B22222">//----------------------------- Child Process Fence ---------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Ignore SIGPIPE's (as in, if one arises, allow us to handle it locally via the send(...) return error EPIPE.
</FONT></I>        signal(SIGPIPE, SIG_IGN);

        <I><FONT COLOR="#B22222">//Cast the input (void *) to a struct so we can pull out all the parts we need.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(arg == nullptr){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Child lambda was passed a nullptr. Unable to cast to struct. Aborting&quot;</FONT></B>);
            exit(-1);
        }
        <B><FONT COLOR="#228B22">struct</FONT></B> YgorNetworking_Server_and_Client_Clone_Shuttle *in = reinterpret_cast&lt;<B><FONT COLOR="#228B22">struct</FONT></B> YgorNetworking_Server_and_Client_Clone_Shuttle *&gt;( arg );

        <I><FONT COLOR="#B22222">//Stop listening for connections. Let the parent do so!
</FONT></I>        close(in-&gt;SERVER_sockfd);

        <I><FONT COLOR="#B22222">//Call the user's dialog lambda if it exists. Call the default otherwise.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( in-&gt;USERS_SERVER_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!in-&gt;USERS_SERVER_DIALOG_LAMBDA( in-&gt;SERVER_new_fd, in-&gt;SERVER_s, in-&gt;SERVER_PORT )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server dialog provided by user failed&quot;</FONT></B>);
                <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>            }
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( in-&gt;DEFAULT_SERVER_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!in-&gt;DEFAULT_SERVER_DIALOG_LAMBDA( in-&gt;SERVER_new_fd, in-&gt;SERVER_s, in-&gt;SERVER_PORT )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server default dialog failed&quot;</FONT></B>);
                <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>            }
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server could not dialog because no valid dialog routine is known&quot;</FONT></B>);
        }

        <I><FONT COLOR="#B22222">//Now we close up the connection to the client and terminate execution of the child.
</FONT></I>        close(in-&gt;SERVER_new_fd);

        <I><FONT COLOR="#B22222">//Cleanup. Unmap the Stack, delete the struct pointed to by in.
</FONT></I>        munmap(in-&gt;Stack, YGORNETWORKING_CLONE_STACK_SIZE);
        <B><FONT COLOR="#A020F0">delete</FONT></B> in;  <I><FONT COLOR="#B22222">//delete arg; ??
</FONT></I>
<B><FONT COLOR="#0000FF">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;   ...lambda done&quot;</FONT></B>);


        <I><FONT COLOR="#B22222">//Finally, terminate execution of this process.
</FONT></I><I><FONT COLOR="#B22222">//        return 0;
</FONT></I>        exit(0);
        <I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------
</FONT></I>    };

<B><FONT COLOR="#0000FF">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Shuttling the object's data now&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">struct</FONT></B> YgorNetworking_Server_and_Client_Clone_Shuttle *out = <B><FONT COLOR="#A020F0">new</FONT></B> YgorNetworking_Server_and_Client_Clone_Shuttle;
    out-&gt;SERVER_sockfd                 = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_sockfd;
    out-&gt;USERS_SERVER_DIALOG_LAMBDA    = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_SERVER_DIALOG_LAMBDA;
    out-&gt;DEFAULT_SERVER_DIALOG_LAMBDA  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_SERVER_DIALOG_LAMBDA;
    out-&gt;SERVER_new_fd                 = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd;
    out-&gt;SERVER_s[INET6_ADDRSTRLEN]    = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s[INET6_ADDRSTRLEN];
    out-&gt;SERVER_PORT                   = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_PORT;
    out-&gt;Stack                         = Stack;
<B><FONT COLOR="#0000FF">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;   ...shuttling done&quot;</FONT></B>);

    <B><FONT COLOR="#A020F0">if</FONT></B>(Stack != nullptr){

<B><FONT COLOR="#0000FF">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Attempting to clone now&quot;</FONT></B>);
        pid_t pid = clone(Childs_Lambda, Stack, CLONE_VM | SIGCHLD , (<B><FONT COLOR="#228B22">void</FONT></B> *)(out));
<B><FONT COLOR="#0000FF">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;   ...cloning done&quot;</FONT></B>);

    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to clone process. Cleaning up and ignoring connection&quot;</FONT></B>);
        munmap(Stack, YGORNETWORKING_CLONE_STACK_SIZE);
    }

    <I><FONT COLOR="#B22222">//Only the parent will reach this point! Since the child will deal with the connection, we
</FONT></I>    <I><FONT COLOR="#B22222">// close the connection fd.
</FONT></I>    close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd);


<I><FONT COLOR="#B22222">/*
    void *stack = malloc( YGORNETWORKING_CLONE_STACK_SIZE );
    if(stack == nullptr){
        if(YGORNETWORKING_VERBOSE) FUNCWARN(&quot;Unable to allocate stack space for the child process to handle connection&quot;);
        return false;
    }

    pid_t pid = clone( &amp;threadFunction, (char*) stack + FIBER_STACK,
                 SIGCHLD | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_VM, 0 );
         if ( pid == -1 ){
                 perror( &quot;clone&quot; );
                 exit( 2 );
         }
*/</FONT></I>        

#<B><FONT COLOR="#5F9EA0">elif</FONT></B> <FONT COLOR="#B8860B">defined</FONT> <FONT COLOR="#B8860B">YGORNETWORKING_USE_THREAD</FONT>
    
    <I><FONT COLOR="#B22222">//Because we are sharing memory, we copy some things to avoid having them disappear mid-execution.
</FONT></I>    <I><FONT COLOR="#B22222">// These are copies which are passed in by value to the child's lambda. Seems to work fairly well.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> std::string hostcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> fdcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> portcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_PORT);

    <B><FONT COLOR="#228B22">auto</FONT></B> Childs_Lambda = [&amp;](std::string thehost, <B><FONT COLOR="#228B22">int</FONT></B> thefd, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> theport) -&gt; <B><FONT COLOR="#228B22">void</FONT></B> {
        <I><FONT COLOR="#B22222">//----------------------------- Child Process Fence ---------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Ensure the SIGPIPE signal is ignored. Is this necessary? Should the parent call it?   FIXME.
</FONT></I>        <I><FONT COLOR="#B22222">//Ignore SIGPIPE's (as in, if one arises, allow us to handle it locally via the send(...) return error EPIPE.
</FONT></I>        signal(SIGPIPE, SIG_IGN);

        <I><FONT COLOR="#B22222">//The following functions expect a raw (char *) array. This may need to change if re-writing 
</FONT></I>        <I><FONT COLOR="#B22222">// is necessary.
</FONT></I>        <B><FONT COLOR="#228B22">char</FONT></B> *thehostcopy = const_cast&lt;<B><FONT COLOR="#228B22">char</FONT></B> *&gt;(thehost.c_str());

        <I><FONT COLOR="#B22222">//Call the user's dialog lambda if it exists. Call the default otherwise.
</FONT></I>        <I><FONT COLOR="#B22222">//NOTE: I'm unsure of how to properly deal with the lambda functions. Should I copy
</FONT></I>        <I><FONT COLOR="#B22222">// them too? Should I slap a mutex around them? Wouldn't copying everything be too
</FONT></I>        <I><FONT COLOR="#B22222">// far of a departure from the 'use threads' mentality?    FIXME.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_SERVER_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_SERVER_DIALOG_LAMBDA( thefd, thehostcopy, theport )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server dialog provided by user failed&quot;</FONT></B>);
                <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>            }
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_SERVER_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_SERVER_DIALOG_LAMBDA( thefd, thehostcopy, theport )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server default dialog failed&quot;</FONT></B>);
                <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>            }
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server could not dialog because no valid dialog routine is known&quot;</FONT></B>);
        }

        <I><FONT COLOR="#B22222">//Now we close up the connection to the client and terminate execution of the child.
</FONT></I>        close(thefd);

        <I><FONT COLOR="#B22222">//Finally, terminate execution of this thread.
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B>;
        <I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------
</FONT></I>    };

    <I><FONT COLOR="#B22222">//Launch the thread.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::thread tolaunch;
    tolaunch = std::thread( Childs_Lambda, hostcopy, fdcopy, portcopy );
    tolaunch.detach();

    <I><FONT COLOR="#B22222">//Note: The child takes ownership of the new fd. We can safely leave it in the child's hands.
</FONT></I>

#<B><FONT COLOR="#5F9EA0">elif</FONT></B> <FONT COLOR="#B8860B">defined</FONT> <FONT COLOR="#B8860B">YGORNETWORKING_USE_THREAD_POOL</FONT>

    <I><FONT COLOR="#B22222">//Because we are sharing memory, we copy some things to avoid having them disappear mid-execution.
</FONT></I>    <I><FONT COLOR="#B22222">// These are copies which are passed in by value to the child's lambda. Seems to work fairly well.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> std::string hostcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> fdcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> portcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_PORT);

    <B><FONT COLOR="#228B22">auto</FONT></B> Childs_Lambda = [&amp;,hostcopy,fdcopy,portcopy](<B><FONT COLOR="#228B22">void</FONT></B>) -&gt; <B><FONT COLOR="#228B22">void</FONT></B> {
<I><FONT COLOR="#B22222">//std::string thehost, int thefd, long int theport
</FONT></I>        <I><FONT COLOR="#B22222">//----------------------------- Child Process Fence ---------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">//Ensure the SIGPIPE signal is ignored. Is this necessary? Should the parent call it?   FIXME.
</FONT></I>        <I><FONT COLOR="#B22222">//Ignore SIGPIPE's (as in, if one arises, allow us to handle it locally via the send(...) return error EPIPE.
</FONT></I>        signal(SIGPIPE, SIG_IGN);

        <I><FONT COLOR="#B22222">//The following functions expect a raw (char *) array. This may need to change if re-writing 
</FONT></I>        <I><FONT COLOR="#B22222">// is necessary.
</FONT></I>        <B><FONT COLOR="#228B22">char</FONT></B> *thehostcopy = const_cast&lt;<B><FONT COLOR="#228B22">char</FONT></B> *&gt;(hostcopy.c_str());

        <I><FONT COLOR="#B22222">//Call the user's dialog lambda if it exists. Call the default otherwise.
</FONT></I>        <I><FONT COLOR="#B22222">//NOTE: I'm unsure of how to properly deal with the lambda functions. Should I copy
</FONT></I>        <I><FONT COLOR="#B22222">// them too? Should I slap a mutex around them? Wouldn't copying everything be too
</FONT></I>        <I><FONT COLOR="#B22222">// far of a departure from the 'use threads' mentality?    FIXME.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_SERVER_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_SERVER_DIALOG_LAMBDA( fdcopy, thehostcopy, portcopy )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server dialog provided by user failed&quot;</FONT></B>);
                <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>            }
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_SERVER_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_SERVER_DIALOG_LAMBDA( fdcopy, thehostcopy, portcopy )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server default dialog failed&quot;</FONT></B>);
                <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>            }
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server could not dialog because no valid dialog routine is known&quot;</FONT></B>);
        }

        <I><FONT COLOR="#B22222">//Now we close up the connection to the client and terminate execution of the child.
</FONT></I>        close(fdcopy);

        <I><FONT COLOR="#B22222">//Finally, terminate execution of this thread.
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B>;
        <I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------
</FONT></I>    };

    <I><FONT COLOR="#B22222">//Pass the task to the thread pool.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;threadpool.Queue(Childs_Lambda);

    <I><FONT COLOR="#B22222">//Note: The child takes ownership of the new fd. We can safely leave it in the child's hands.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">elif</FONT></B> <FONT COLOR="#B8860B">defined</FONT> <FONT COLOR="#B8860B">YGORNETWORKING_NO_CHILD</FONT>

    <I><FONT COLOR="#B22222">//Call the user's dialog lambda if it exists. Call the default otherwise.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_SERVER_DIALOG_LAMBDA ){
        <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_SERVER_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_PORT )){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server dialog provided by user failed&quot;</FONT></B>);
            <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>        }
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_SERVER_DIALOG_LAMBDA ){
        <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_SERVER_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_PORT )){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server default dialog failed&quot;</FONT></B>);
            <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>        }
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server could not dialog because no valid dialog routine is known&quot;</FONT></B>);
    }

    <I><FONT COLOR="#B22222">//Now we close up the connection to the client.
</FONT></I>    close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_new_fd);

#<B><FONT COLOR="#5F9EA0">else</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot; #########################################################################################&quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot; You must define one of:                                                                  &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot;     YGORNETWORKING_USE_FORK     - (No memory sharing, fast, safest.)                       &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot;     YGORNETWORKING_USE_CLONE    - (Memory sharing only, fairly safe.)                      &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot;     YGORNETWORKING_USE_THREAD   - (Memory sharing, fairly safe.)                           &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot;     YGORNETWORKING_NO_CHILD     - (Total memory sharing, (sequentially) fast, least safe.) &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot; in order to specify how connections are handled by the server!                           &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot; Alternatively, use clone(2) to write your own connection handling scheme.                &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot; #########################################################################################&quot;</FONT></B>
    #error
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Client-specific member functions.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Client_Init</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Client_Init( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_PORT, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_CLIENT_DIALOG_LAMBDA );
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Client_Init</FONT></B>(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; client_dialog){
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Client_Init( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_PORT, client_dialog );
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Client_Init</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port, std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; client_dialog){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_PORT    = port;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_CLIENT_DIALOG_LAMBDA = client_dialog;

    <I><FONT COLOR="#B22222">//This member function will initialize the client, preparing it to establish a connection.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Whether or not a previous initialization has occured, this function will 'start from
</FONT></I>    <I><FONT COLOR="#B22222">// scratch' by wiping out the previous initialization. This is desirable in case the 
</FONT></I>    <I><FONT COLOR="#B22222">// network somehow falls out from under our feet after initial initialization.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//This function returns 'true' if everything was OK and 'false' if any error arises.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_INITIALIZED = false;

    <I><FONT COLOR="#B22222">//Ignore SIGPIPE's (as in, if one arises, allow us to handle it locally via the send(...) return error EPIPE.
</FONT></I>    signal(SIGPIPE, SIG_IGN);

    memset(&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_hints, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_hints));
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_hints.ai_family   = AF_UNSPEC;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_hints.ai_socktype = SOCK_STREAM;
<I><FONT COLOR="#B22222">//    this-&gt;CLIENT_hints.ai_socktype = SOCK_STREAM | SOCK_CLOEXEC; //Included so that we can execv a client without holding the port.
</FONT></I>
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_INITIALIZED = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Client_Connect</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;address){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_ADDRESS = address;

    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_INITIALIZED != true){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Client initialization has not been performed. Unable to establish connection&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <B><FONT COLOR="#228B22">const</FONT></B> std::string PORT_STRING = Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_PORT);
    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_rv = getaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_ADDRESS.c_str(), PORT_STRING.c_str(), &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_hints, &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_servinfo)) != 0) {
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;getaddrinfo returned error &quot;</FONT></B> &lt;&lt; gai_strerror(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_rv) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;. Unable to initialize client&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <I><FONT COLOR="#B22222">//Loop through all the results and connect to the first we can.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_servinfo; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p != nullptr; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p-&gt;ai_next){
        <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_sockfd = socket(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p-&gt;ai_family, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p-&gt;ai_socktype, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p-&gt;ai_protocol)) == -1) {
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Server socket issue. Continuing&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }

        <I><FONT COLOR="#B22222">//Attempt to set the timeouts.
</FONT></I>        <B><FONT COLOR="#228B22">struct</FONT></B> timeval timeshuttle;<I><FONT COLOR="#B22222">// = {0};
</FONT></I>        memset(&amp;timeshuttle, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(timeshuttle));
        timeshuttle.tv_sec  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_recv_timeout_sec;
        timeshuttle.tv_usec = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_recv_timeout_usec;
        <B><FONT COLOR="#A020F0">if</FONT></B> (setsockopt(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeshuttle, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> timeval)) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;setsockopt issue. Unable to specify recv timeout&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
        timeshuttle.tv_sec  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_send_timeout_sec;
        timeshuttle.tv_usec = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_send_timeout_usec;
        <B><FONT COLOR="#A020F0">if</FONT></B> (setsockopt(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeshuttle, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> timeval)) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;setsockopt issue. Unable to specify recv timeout&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }

<I><FONT COLOR="#B22222">//------------
</FONT></I>        <I><FONT COLOR="#B22222">//Set the close-on-exec flag so that clients can execv and not consume/hold onto the port.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(fcntl(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_sockfd, F_SETFD, FD_CLOEXEC) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempting to set client close-on-exec flag failed. This shouldn't happen, so the file descriptor is likely invalid&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
<I><FONT COLOR="#B22222">//fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC); ???
</FONT></I><I><FONT COLOR="#B22222">//-------------
</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B>(connect(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p-&gt;ai_addr, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p-&gt;ai_addrlen) == -1){
            close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_sockfd);
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Client connection issue. Continuing&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
        <B><FONT COLOR="#A020F0">break</FONT></B>;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p == nullptr){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Client is unable to connect&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }  

    inet_ntop(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p-&gt;ai_family, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Get_in_addr((<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr *)<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_p-&gt;ai_addr), <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_s, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_s));
    <I><FONT COLOR="#B22222">//if(YGORNETWORKING_VERBOSE) FUNCINFO(&quot;Connected to &quot; &lt;&lt; this-&gt;CLIENT_s);
</FONT></I>
    <I><FONT COLOR="#B22222">//Cleanup stuff we no longer need before talking with the server.
</FONT></I>    freeaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_servinfo); 

    <I><FONT COLOR="#B22222">//Call the user's dialog lambda if it exists. Call the default otherwise.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_CLIENT_DIALOG_LAMBDA ){
        <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_CLIENT_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_PORT )){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Client dialog provided by user failed&quot;</FONT></B>);
            <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>        }
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_CLIENT_DIALOG_LAMBDA ){
        <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_CLIENT_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_PORT )){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Client default dialog failed&quot;</FONT></B>);
            <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>        }
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Client could not dialog because no valid dialog routine is known&quot;</FONT></B>);
    }

    <I><FONT COLOR="#B22222">//End dialog with server by closing the connection.
</FONT></I>    close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_sockfd);
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//General member functions.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Set_No_Timeouts</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//This member will remove all server and client timeouts by setting them all to 'infinite' timeout.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: This function will return 'false' if it is too late to set all of the timeouts, 'true' else.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_INITIALIZED || <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_INITIALIZED){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Too late to set all timeouts - must be done prior to initialization&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_accept_timeout_sec   = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_accept_timeout_usec  = 0;

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_recv_timeout_sec     = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_recv_timeout_usec    = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_send_timeout_sec     = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;SERVER_send_timeout_usec    = 0;

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_recv_timeout_sec     = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_recv_timeout_usec    = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_send_timeout_sec     = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;CLIENT_send_timeout_usec    = 0;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}


<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Add_To_Blocklist</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;host){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist_Mutex.lock();
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist.insert(host);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist_Mutex.unlock();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Remove_From_Blocklist</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;host){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist_Mutex.lock();
    <B><FONT COLOR="#228B22">auto</FONT></B> it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist.find(host);
    <B><FONT COLOR="#A020F0">if</FONT></B>(it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist.end()) <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist.erase(it);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist_Mutex.unlock();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Server_and_Client::Is_In_Blocklist</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;host){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist_Mutex.lock();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> out = (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist.find(host) != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist.end());
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Blocklist_Mutex.unlock();
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}



<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------- Beacon_and_Radio: a UDP multicasting class -----------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//General helper member functions.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> *<B><FONT COLOR="#0000FF">Beacon_and_Radio::Get_in_addr</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr *sa_in){
    <B><FONT COLOR="#A020F0">if</FONT></B>(sa_in-&gt;sa_family == AF_INET) {
        <B><FONT COLOR="#A020F0">return</FONT></B> &amp;(((<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr_in*)sa_in)-&gt;sin_addr);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> &amp;(((<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr_in6*)sa_in)-&gt;sin6_addr);
}

<I><FONT COLOR="#B22222">//Constructors and Destructor.
</FONT></I><B><FONT COLOR="#0000FF">Beacon_and_Radio::Beacon_and_Radio</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) : RADIO_INITIALIZED(false), RADIO_PORT(3490), <I><FONT COLOR="#B22222">/*RADIO_BACKLOG(100), */</FONT></I>
                                           RADIO_LOOP(true), RADIO_yes(1), BEACON_INITIALIZED(false), 
                                           BEACON_PORT(3490), BEACON_LOOP(true), BEACON_TTL_HOPS(1) {

    <I><FONT COLOR="#B22222">//Set the default timeouts. All send() and recv() timeouts can be adjusted before OR 
</FONT></I>    <I><FONT COLOR="#B22222">// after init.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: These times can be modified to suit, even passed in as parameters to this member
</FONT></I>    <I><FONT COLOR="#B22222">// if so desired.
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: If the total time is zero, it is interpretted as &quot;wait forever.&quot;
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: They are oddly staggered so we can help diagnose issues by timing things. There
</FONT></I>    <I><FONT COLOR="#B22222">// is no other significance to the stagger.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_send_timeout_sec    = 10;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_send_timeout_usec   = 0;

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_recv_timeout_sec     = 0; <I><FONT COLOR="#B22222">//Wait forever. This is probably most desirable.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_recv_timeout_usec    = 0;

    <I><FONT COLOR="#B22222">//Provide some sane default dialog routines. These do not have to be fancy, they just
</FONT></I>    <I><FONT COLOR="#B22222">// need to work and do something basic but non-trivial.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_BEACON_DIALOG_LAMBDA = [](<B><FONT COLOR="#228B22">int</FONT></B> fd, <B><FONT COLOR="#228B22">char</FONT></B> *host, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> {
        <I><FONT COLOR="#B22222">//Send a simple message to all radios. This entire lambda will be looped over forever.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(send(fd, <B><FONT COLOR="#BC8F8F">&quot;This is the default beacon message!&quot;</FONT></B>, 38, MSG_NOSIGNAL) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Beacon unable to send()&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Sent a message over multicast&quot;</FONT></B>);
        }

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::this_thread::sleep_for( std::chrono::seconds( 1 ) );
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    };

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_RADIO_DIALOG_LAMBDA = [](<B><FONT COLOR="#228B22">int</FONT></B> fd, <B><FONT COLOR="#228B22">char</FONT></B> *host, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port) -&gt; <B><FONT COLOR="#228B22">bool</FONT></B> {
        <B><FONT COLOR="#228B22">int</FONT></B> numbytes;
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> BUFFSIZE = 100;
        <B><FONT COLOR="#228B22">char</FONT></B> buff[BUFFSIZE];

        <I><FONT COLOR="#B22222">//Wait until we timeout (or otherwise error) or we get a message from a broadcasting beacon.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>((numbytes = recv(fd, buff, BUFFSIZE-1, 0)) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Beacon connection issue. Nothing was received&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
        buff[numbytes] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCINFO(<B><FONT COLOR="#BC8F8F">&quot;Received multicast message from beacon: '&quot;</FONT></B> &lt;&lt; buff &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    };

}

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Radio-specific member functions.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Radio_Init</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Radio_Init( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_PORT, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_RADIO_DIALOG_LAMBDA );
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Radio_Init</FONT></B>(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; radio_dialog){
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Radio_Init( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_PORT, radio_dialog );
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Radio_Init</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port, std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; radio_dialog){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_PORT = port;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_RADIO_DIALOG_LAMBDA = radio_dialog;

    <I><FONT COLOR="#B22222">//This member function will initialize the radio, preparing it to begin transmitting 
</FONT></I>    <I><FONT COLOR="#B22222">// messages.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Whether or not a previous initialization has occured, this function will 'start from
</FONT></I>    <I><FONT COLOR="#B22222">// scratch' by wiping out the previous initialization. This is desirable in case the 
</FONT></I>    <I><FONT COLOR="#B22222">// network somehow falls out from under our feet after initial initialization.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//This function returns 'true' if everything was OK and 'false' if any error arises.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_INITIALIZED = false;

    memset(&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_hints, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(RADIO_hints));
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_hints.ai_family     = AF_UNSPEC;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_hints.ai_socktype   = SOCK_DGRAM;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_hints.ai_flags      = AI_PASSIVE;

    <B><FONT COLOR="#228B22">const</FONT></B> std::string PORT_STRING = Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_PORT);
    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_rv = getaddrinfo(NULL, PORT_STRING.c_str(), &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_hints, &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo)) != 0) {
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;getaddrinfo returned error &quot;</FONT></B> &lt;&lt; gai_strerror(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_rv) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;. Unable to initialize radio&quot;</FONT></B>);
        freeaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <I><FONT COLOR="#B22222">//Loop through all the results and bind to the first we can. Break on success.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_p = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_p != nullptr; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_p = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_p-&gt;ai_next){
        <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd = socket(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_p-&gt;ai_family, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_p-&gt;ai_socktype, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_p-&gt;ai_protocol)) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio socket issue. Continuing&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }

        <I><FONT COLOR="#B22222">//Attempt to tell the kernel to reuse addresses (so we can quickly reboot the program and reuse the address 
</FONT></I>        <I><FONT COLOR="#B22222">// if we need to.)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(setsockopt(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd, SOL_SOCKET, SO_REUSEADDR, (<B><FONT COLOR="#228B22">void</FONT></B> *)&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_yes, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B>)) == -1) {
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;setsockopt issue (unable to force address reuse). Unable to initialize radio&quot;</FONT></B>);
            freeaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }

        <I><FONT COLOR="#B22222">//Try to bind the socket to the suggested address/port. 
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(bind(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_p-&gt;ai_addr, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_p-&gt;ai_addrlen) == -1){
            close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd);
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio bind issue. Continuing&quot;</FONT></B>);            
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
        <B><FONT COLOR="#A020F0">break</FONT></B>;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_p == nullptr){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio bind issue. Unable to initialize radio&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <I><FONT COLOR="#B22222">//We can free this structure now.
</FONT></I>    freeaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo);

    <I><FONT COLOR="#B22222">//Set the close-on-exec flag so that radio programs can execv and not consume/hold onto the port.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(fcntl(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd, F_SETFD, FD_CLOEXEC) == -1){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempting to set close-on-exec flag failed. This shouldn't happen, so the file descriptor is likely invalid&quot;</FONT></B>);
    }

    <I><FONT COLOR="#B22222">//Ignore SIGPIPE's (as in, if one arises, allow us to handle it locally via the send(...) return error EPIPE.
</FONT></I>    signal(SIGPIPE, SIG_IGN);

    <I><FONT COLOR="#B22222">//&quot;Reap&quot; all dead processes.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> handler_lambda = [](<B><FONT COLOR="#228B22">int</FONT></B> s) -&gt; <B><FONT COLOR="#228B22">void</FONT></B> { <B><FONT COLOR="#A020F0">while</FONT></B>(waitpid(-1, NULL, WNOHANG) &gt; 0){ }; };
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sa.sa_handler = handler_lambda;

    sigemptyset(&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sa.sa_mask);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sa.sa_flags = SA_RESTART;
    <B><FONT COLOR="#A020F0">if</FONT></B>(sigaction(SIGCHLD, &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sa, NULL) == -1){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio sigaction issue. Unable to initialize radio&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_INITIALIZED = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Radio_Tune_In</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;address){
    <I><FONT COLOR="#B22222">//This member function begins listening for broadcasts on the given multicast address.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//When something is received, it is packed into a fork()/exec()/thread and we continue.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_INITIALIZED != true){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio initialization has not been performed. Unable to wait for broadcasts&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <I><FONT COLOR="#B22222">//Try to resolve the multicast IP address into something more machine-readable.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_rv = getaddrinfo(address.c_str(), nullptr, &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_hints, &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo)) != 0){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;getaddrinfo returned error &quot;</FONT></B> &lt;&lt; gai_strerror(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_rv) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;. Unable to resolve multicast address&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <I><FONT COLOR="#B22222">//Send a request to the kernel to join the multicast group. We handle IPv4/v6 separately.
</FONT></I>    <I><FONT COLOR="#B22222">//For IPv4.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo-&gt;ai_family == AF_INET &amp;&amp; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo-&gt;ai_addrlen == <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr_in)){
        <B><FONT COLOR="#228B22">struct</FONT></B> ip_mreq multicastRequest;
        memset(&amp;multicastRequest, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(multicastRequest));

        <I><FONT COLOR="#B22222">//The multicast group we want to join.
</FONT></I>        memcpy(&amp;multicastRequest.imr_multiaddr, &amp;((<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr_in*)(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo-&gt;ai_addr))-&gt;sin_addr,
               <B><FONT COLOR="#A020F0">sizeof</FONT></B>(multicastRequest.imr_multiaddr));

        <I><FONT COLOR="#B22222">//Allow any interface present to accept multicasts. Maybe we should specify a specific card here?
</FONT></I>        multicastRequest.imr_interface.s_addr = htonl(INADDR_ANY);

        <I><FONT COLOR="#B22222">//Join it.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(setsockopt(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;multicastRequest, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(multicastRequest)) != 0){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio initialization has not been performed. Unable to join multicast group&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }

    <I><FONT COLOR="#B22222">//For IPv6.
</FONT></I>    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo-&gt;ai_family == AF_INET6 &amp;&amp; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo-&gt;ai_addrlen == <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr_in6)){
        <B><FONT COLOR="#228B22">struct</FONT></B> ipv6_mreq multicastRequest;
        memset(&amp;multicastRequest, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(multicastRequest));

        <I><FONT COLOR="#B22222">//The multicast group we want to join.
</FONT></I>        memcpy(&amp;multicastRequest.ipv6mr_multiaddr, &amp;((<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr_in6*)(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo-&gt;ai_addr))-&gt;sin6_addr,
               <B><FONT COLOR="#A020F0">sizeof</FONT></B>(multicastRequest.ipv6mr_multiaddr));

        <I><FONT COLOR="#B22222">//Allow any interface present to accept multicasts. Maybe we should specify a specific card here?
</FONT></I>        multicastRequest.ipv6mr_interface = 0;

        <I><FONT COLOR="#B22222">//Join it.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(setsockopt(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &amp;multicastRequest, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(multicastRequest)) != 0){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio initialization has not been performed. Unable to join multicast group&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio initialization has not been performed. Multicast info is not understandable&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    freeaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_servinfo);


    <I><FONT COLOR="#B22222">//Now, loop over messages. If looping is turned off, we will perform one such recv() and then terminate.
</FONT></I>    <B><FONT COLOR="#A020F0">do</FONT></B>{
        <I><FONT COLOR="#B22222">//Now fish until we get something. To ensure nothing is lost, we only peek at the message.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> smallbuff_size = 10;
        <B><FONT COLOR="#228B22">char</FONT></B> smallbuff[smallbuff_size+1];
        <B><FONT COLOR="#228B22">struct</FONT></B> sockaddr beacon_addr;
        socklen_t beacon_addr_sz = <B><FONT COLOR="#A020F0">sizeof</FONT></B>(beacon_addr);
        memset(&amp;beacon_addr, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(beacon_addr));
        <B><FONT COLOR="#228B22">auto</FONT></B> peekret = recvfrom(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd, smallbuff, smallbuff_size, MSG_PEEK, &amp;beacon_addr, &amp;beacon_addr_sz);
  
        <B><FONT COLOR="#A020F0">if</FONT></B>(peekret &lt; 0){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> errsv = errno;
            <B><FONT COLOR="#A020F0">if</FONT></B>(errsv == ETIMEDOUT){
                <I><FONT COLOR="#B22222">//if(VERBOSE) if(YGORNETWORKING_VERBOSE) FUNCINFO(&quot;Timed out while waiting to receive multicast message. Consider increasing timeout threshold&quot;);
</FONT></I>                <B><FONT COLOR="#A020F0">return</FONT></B> false;
            }<B><FONT COLOR="#A020F0">else</FONT></B>{ 
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Failed to receive multicast message. Encountered error: &quot;</FONT></B> &lt;&lt; strerror(errsv));
                <B><FONT COLOR="#A020F0">return</FONT></B> false;
            }
    
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(peekret == 0){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;recv() returned a message of length 0. Not sure what this means!&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
        smallbuff[peekret] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

        <B><FONT COLOR="#A020F0">if</FONT></B>(inet_ntop(beacon_addr.sa_family, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Get_in_addr(&amp;beacon_addr), <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_s, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_s)) == nullptr){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Unable to determine beacon's address. Sending a nullptr hostname instead&quot;</FONT></B>);
        }
    
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">defined</FONT> <FONT COLOR="#B8860B">YGORNETWORKING_RADIO_USE_FORK</FONT>

<B><FONT COLOR="#0000FF">FUNCINFO</FONT></B>(<B><FONT COLOR="#BC8F8F">&quot;Note: This routine has not been tested. After testing, remove this notice&quot;</FONT></B>);
        <I><FONT COLOR="#B22222">//Just fork and execute the lambda!
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(!fork()){
            <I><FONT COLOR="#B22222">//----------------------------- Child Process Fence ---------------------------------
</FONT></I>            <I><FONT COLOR="#B22222">//Ignore SIGPIPE's (as in, if one arises, allow us to handle it locally via the send(...) return error EPIPE.
</FONT></I>            signal(SIGPIPE, SIG_IGN);
    
            <I><FONT COLOR="#B22222">//Call the user's dialog lambda if it exists. Call the default otherwise.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_RADIO_DIALOG_LAMBDA ){
                <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_RADIO_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_PORT )){
                    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio dialog provided by user failed&quot;</FONT></B>);
                    <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>                }
            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_RADIO_DIALOG_LAMBDA ){
                <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_RADIO_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_PORT )){
                    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio default dialog failed&quot;</FONT></B>);
                    <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>                }
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio could not dialog because no valid dialog routine is known&quot;</FONT></B>);
            }
    
            <I><FONT COLOR="#B22222">//Now we close up the socket and terminate execution of the child.
</FONT></I>            close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd);
    
            <I><FONT COLOR="#B22222">//Finally, terminate execution of this process.
</FONT></I>            exit(0);
            <I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------
</FONT></I>        }

        <I><FONT COLOR="#B22222">//Read in the data to clear it off the stack.
</FONT></I>        {
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> smallbuff_size = 10;
            <B><FONT COLOR="#228B22">char</FONT></B> smallbuff[smallbuff_size+1];
            <B><FONT COLOR="#A020F0">if</FONT></B>(recv(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd, smallbuff, smallbuff_size, 0) == -1){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Encountered an error while clearing data out of UDP stack. This data is not used for anything&quot;</FONT></B>);
            }
        }

        <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_LOOP) close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd);
 
#<B><FONT COLOR="#5F9EA0">elif</FONT></B> <FONT COLOR="#B8860B">defined</FONT> <FONT COLOR="#B8860B">YGORNETWORKING_RADIO_USE_CLONE</FONT>
    
        #pragma message <B><FONT COLOR="#BC8F8F">&quot;############################################&quot;</FONT></B>
        #pragma message <B><FONT COLOR="#BC8F8F">&quot;Clone usage is not yet complete. DO NOT USE!&quot;</FONT></B>
        #pragma message <B><FONT COLOR="#BC8F8F">&quot;############################################&quot;</FONT></B>
        #error
    
        <I><FONT COLOR="#B22222">//Because we are sharing memory, we copy some things to avoid having them disappear mid-execution.
</FONT></I>        <I><FONT COLOR="#B22222">// These are copies which are passed in by value to the child's lambda. Seems to work fairly well.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> std::string hostcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_s);
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> fdcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd);
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> portcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_PORT);

        <B><FONT COLOR="#228B22">auto</FONT></B> Childs_Lambda = [=]<I><FONT COLOR="#B22222">/*,hostcopy,fdcopy,portcopy]*/</FONT></I>(<B><FONT COLOR="#228B22">void</FONT></B>) -&gt; <B><FONT COLOR="#228B22">int</FONT></B> {
            <I><FONT COLOR="#B22222">//----------------------------- Child Process Fence ---------------------------------
</FONT></I>            <I><FONT COLOR="#B22222">//Ensure the SIGPIPE signal is ignored. Is this necessary? Should the parent call it?   FIXME.
</FONT></I>            <I><FONT COLOR="#B22222">//Ignore SIGPIPE's (as in, if one arises, allow us to handle it locally via the send(...) return error EPIPE.
</FONT></I>            signal(SIGPIPE, SIG_IGN);

            <I><FONT COLOR="#B22222">//The following functions expect a raw (char *) array. This may need to change if re-writing 
</FONT></I>            <I><FONT COLOR="#B22222">// is necessary.
</FONT></I>            <B><FONT COLOR="#228B22">char</FONT></B> *thehostcopy = const_cast&lt;<B><FONT COLOR="#228B22">char</FONT></B> *&gt;(hostcopy.c_str());

            <I><FONT COLOR="#B22222">//Call the user's dialog lambda if it exists. Call the default otherwise.
</FONT></I>            <I><FONT COLOR="#B22222">//NOTE: I'm unsure of how to properly deal with the lambda functions. Should I copy
</FONT></I>            <I><FONT COLOR="#B22222">// them too? Should I slap a mutex around them? Wouldn't copying everything be too
</FONT></I>            <I><FONT COLOR="#B22222">// far of a departure from the 'use threads' mentality?    FIXME.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_RADIO_DIALOG_LAMBDA ){
                <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_RADIO_DIALOG_LAMBDA( fdcopy, thehostcopy, portcopy )){
                    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio dialog provided by user failed&quot;</FONT></B>);
                    <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>                }
            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_RADIO_DIALOG_LAMBDA ){
                <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_RADIO_DIALOG_LAMBDA( fdcopy, thehostcopy, portcopy )){
                    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio default dialog failed&quot;</FONT></B>);
                    <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>                }
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio could not dialog because no valid dialog routine is known&quot;</FONT></B>);
            }

            <I><FONT COLOR="#B22222">//Now we close up the connection to the beacon and terminate execution of the child.
</FONT></I><I><FONT COLOR="#B22222">//            if(closethefd) close(thefd);
</FONT></I>            close(fdcopy);

            <I><FONT COLOR="#B22222">//Finally, terminate execution of this thread.
</FONT></I>            _exit(0);
            <I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------
</FONT></I>        };
  
        <B><FONT COLOR="#228B22">void</FONT></B> **child_stack;
        child_stack = (<B><FONT COLOR="#228B22">void</FONT></B> **)malloc(16384);   <I><FONT COLOR="#B22222">//How to free this? FIXME FIXME FIXME!
</FONT></I>       
        <B><FONT COLOR="#A020F0">if</FONT></B>(clone(Childs_Lambda, child_stack, CLONE_VM <I><FONT COLOR="#B22222">/*|CLONE_FILES*/</FONT></I>, NULL) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Failed to clone - unable to recv message. Continuing&quot;</FONT></B>);
        }
   
        <I><FONT COLOR="#B22222">//Now we close up the connection to the beacon.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_LOOP) close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd);
  
#<B><FONT COLOR="#5F9EA0">elif</FONT></B> <FONT COLOR="#B8860B">defined</FONT> <FONT COLOR="#B8860B">YGORNETWORKING_RADIO_USE_THREAD</FONT>
        
        <I><FONT COLOR="#B22222">//Because we are sharing memory, we copy some things to avoid having them disappear mid-execution.
</FONT></I>        <I><FONT COLOR="#B22222">// These are copies which are passed in by value to the child's lambda. Seems to work fairly well.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> std::string hostcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_s);
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> fdcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd);
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> portcopy(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_PORT);

        <B><FONT COLOR="#228B22">auto</FONT></B> Childs_Lambda = [&amp;](std::string thehost, <B><FONT COLOR="#228B22">int</FONT></B> thefd, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> theport, <B><FONT COLOR="#228B22">bool</FONT></B> closethefd) -&gt; <B><FONT COLOR="#228B22">void</FONT></B> {
            <I><FONT COLOR="#B22222">//----------------------------- Child Process Fence ---------------------------------
</FONT></I>            <I><FONT COLOR="#B22222">//Ensure the SIGPIPE signal is ignored. Is this necessary? Should the parent call it?   FIXME.
</FONT></I>            <I><FONT COLOR="#B22222">//Ignore SIGPIPE's (as in, if one arises, allow us to handle it locally via the send(...) return error EPIPE.
</FONT></I>            signal(SIGPIPE, SIG_IGN);
    
            <I><FONT COLOR="#B22222">//The following functions expect a raw (char *) array. This may need to change if re-writing 
</FONT></I>            <I><FONT COLOR="#B22222">// is necessary.
</FONT></I>            <B><FONT COLOR="#228B22">char</FONT></B> *thehostcopy = const_cast&lt;<B><FONT COLOR="#228B22">char</FONT></B> *&gt;(thehost.c_str());
    
            <I><FONT COLOR="#B22222">//Call the user's dialog lambda if it exists. Call the default otherwise.
</FONT></I>            <I><FONT COLOR="#B22222">//NOTE: I'm unsure of how to properly deal with the lambda functions. Should I copy
</FONT></I>            <I><FONT COLOR="#B22222">// them too? Should I slap a mutex around them? Wouldn't copying everything be too
</FONT></I>            <I><FONT COLOR="#B22222">// far of a departure from the 'use threads' mentality?    FIXME.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_RADIO_DIALOG_LAMBDA ){
                <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_RADIO_DIALOG_LAMBDA( thefd, thehostcopy, theport )){
                    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio dialog provided by user failed&quot;</FONT></B>);
                    <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>                }
            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_RADIO_DIALOG_LAMBDA ){
                <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_RADIO_DIALOG_LAMBDA( thefd, thehostcopy, theport )){
                    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio default dialog failed&quot;</FONT></B>);
                    <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>                }
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio could not dialog because no valid dialog routine is known&quot;</FONT></B>);
            }
    
            <I><FONT COLOR="#B22222">//Now we close up the connection to the beacon and terminate execution of the child.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(closethefd) close(thefd);
    
            <I><FONT COLOR="#B22222">//Finally, terminate execution of this thread.
</FONT></I>            <B><FONT COLOR="#A020F0">return</FONT></B>;
            <I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------
</FONT></I>        };
    
        <I><FONT COLOR="#B22222">//Launch the thread.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::thread tolaunch;
        tolaunch = std::thread( Childs_Lambda, hostcopy, fdcopy, portcopy, !<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_LOOP );
        tolaunch.detach();

        <I><FONT COLOR="#B22222">//Child will close this as/when/iff needed.
</FONT></I>        <I><FONT COLOR="#B22222">//if(!this-&gt;RADIO_LOOP) close(this-&gt;RADIO_sockfd);
</FONT></I>
#<B><FONT COLOR="#5F9EA0">elif</FONT></B> <FONT COLOR="#B8860B">defined</FONT> <FONT COLOR="#B8860B">YGORNETWORKING_RADIO_NO_CHILD</FONT>
 
        <I><FONT COLOR="#B22222">//Call the user's dialog lambda if it exists. Call the default otherwise.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_RADIO_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_RADIO_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_PORT )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio dialog provided by user failed&quot;</FONT></B>);
            }
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_RADIO_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_RADIO_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_PORT )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio default dialog failed&quot;</FONT></B>);
            }
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio could not dialog because no valid dialog routine is known&quot;</FONT></B>);
        }
    
        <I><FONT COLOR="#B22222">//Now we close up the connection to the beacon.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_LOOP) close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_sockfd);
    
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot; #########################################################################################&quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot; You must define one of:                                                                  &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot;     YGORNETWORKING_USE_FORK     - (No memory sharing, fast, safest.)                       &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot;     YGORNETWORKING_USE_CLONE    - (Memory sharing only, fairly safe.)                      &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot;     YGORNETWORKING_USE_THREAD   - (Memory sharing, fairly safe.)                           &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot;     YGORNETWORKING_NO_CHILD     - (Total memory sharing, (sequentially) fast, least safe.) &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot; in order to specify how connections are handled by the radio!                           &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot; Alternatively, use clone(2) to write your own connection handling scheme.                &quot;</FONT></B>
    #pragma message <B><FONT COLOR="#BC8F8F">&quot; #########################################################################################&quot;</FONT></B>
    #error
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    }<B><FONT COLOR="#A020F0">while</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_LOOP);

    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Beacon-specific member functions.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Beacon_Init</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Beacon_Init( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_PORT, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_BEACON_DIALOG_LAMBDA );
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Beacon_Init</FONT></B>(std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; beacon_dialog){
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Beacon_Init( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_PORT, beacon_dialog );
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Beacon_Init</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> port, std::function&lt;<B><FONT COLOR="#228B22">bool</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">char</FONT></B> *, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)&gt; beacon_dialog){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_PORT    = port;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_BEACON_DIALOG_LAMBDA = beacon_dialog;

    <I><FONT COLOR="#B22222">//This member function will initialize the beacon, preparing it to establish a connection.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Whether or not a previous initialization has occured, this function will 'start from
</FONT></I>    <I><FONT COLOR="#B22222">// scratch' by wiping out the previous initialization. This is desirable in case the 
</FONT></I>    <I><FONT COLOR="#B22222">// network somehow falls out from under our feet after initial initialization.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//This function returns 'true' if everything was OK and 'false' if any error arises.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_INITIALIZED = false;

    <I><FONT COLOR="#B22222">//Ignore SIGPIPE's (as in, if one arises, allow us to handle it locally via the send(...) return error EPIPE.
</FONT></I>    signal(SIGPIPE, SIG_IGN);

    memset(&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_hints, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_hints));
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_hints.ai_family   = AF_UNSPEC;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_hints.ai_socktype = SOCK_DGRAM;

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_INITIALIZED = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Beacon_Transmit</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;address){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_ADDRESS = address; <I><FONT COLOR="#B22222">//Holds the multicast address.
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_INITIALIZED != true){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Beacon initialization has not been performed. Unable to establish connection&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <B><FONT COLOR="#228B22">const</FONT></B> std::string PORT_STRING = Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_PORT);
    <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_rv = getaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_ADDRESS.c_str(), PORT_STRING.c_str(), &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_hints, &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_servinfo)) != 0){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;getaddrinfo returned error &quot;</FONT></B> &lt;&lt; gai_strerror(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_rv) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;. Unable to initialize beacon&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <I><FONT COLOR="#B22222">//Loop through all the results and connect to the first we can.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_servinfo; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p != nullptr; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p-&gt;ai_next){
        <B><FONT COLOR="#A020F0">if</FONT></B>((<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_sockfd = socket(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p-&gt;ai_family, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p-&gt;ai_socktype, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p-&gt;ai_protocol)) == -1) {
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Radio socket issue. Continuing&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }

        <I><FONT COLOR="#B22222">//Attempt to set the timeouts.
</FONT></I>        <B><FONT COLOR="#228B22">struct</FONT></B> timeval timeshuttle;<I><FONT COLOR="#B22222">// = {0};
</FONT></I>        memset(&amp;timeshuttle, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(timeshuttle));
        timeshuttle.tv_sec  = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_send_timeout_sec;
        timeshuttle.tv_usec = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_send_timeout_usec;
        <B><FONT COLOR="#A020F0">if</FONT></B>(setsockopt(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeshuttle, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> timeval)) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;setsockopt issue. Unable to specify recv timeout&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }

        <I><FONT COLOR="#B22222">//Attempt to set the TTL of the messages.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(setsockopt(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_sockfd, IPPROTO_IP, IP_MULTICAST_TTL, &amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_TTL_HOPS, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_TTL_HOPS)) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;setsockopt issue. Unable to specify max TTL (aka number of hops)&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }

        <I><FONT COLOR="#B22222">//Set the close-on-exec flag so that beacons can execv and not consume/hold onto the port.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(fcntl(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_sockfd, F_SETFD, FD_CLOEXEC) == -1){
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Attempting to set beacon close-on-exec flag failed. This shouldn't happen, so the file descriptor is likely invalid&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }

        <B><FONT COLOR="#A020F0">if</FONT></B>(connect(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p-&gt;ai_addr, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p-&gt;ai_addrlen) == -1){
            close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_sockfd);
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Beacon connection issue. Continuing&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
        <B><FONT COLOR="#A020F0">break</FONT></B>;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p == nullptr){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Beacon is unable to connect&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }  

    inet_ntop(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p-&gt;ai_family, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Get_in_addr((<B><FONT COLOR="#228B22">struct</FONT></B> sockaddr *)<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_p-&gt;ai_addr), <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_s, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_s));
    <I><FONT COLOR="#B22222">//if(YGORNETWORKING_VERBOSE) FUNCINFO(&quot;Connected to &quot; &lt;&lt; this-&gt;BEACON_s);
</FONT></I>
    <I><FONT COLOR="#B22222">//Cleanup stuff we no longer need before talking with the radio.
</FONT></I>    freeaddrinfo(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_servinfo); 

    <I><FONT COLOR="#B22222">//Loop forever, attempting to send messages. If looping is disabled, send out one message and terminate.
</FONT></I>    <I><FONT COLOR="#B22222">// The user must handle the beacon frequency in the dialog function.
</FONT></I>    <B><FONT COLOR="#A020F0">do</FONT></B>{
        <I><FONT COLOR="#B22222">//Call the user's dialog lambda if it exists. Call the default otherwise.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_BEACON_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;USERS_BEACON_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_PORT )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Beacon dialog provided by user failed&quot;</FONT></B>);
                <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>            }
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_BEACON_DIALOG_LAMBDA ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;DEFAULT_BEACON_DIALOG_LAMBDA( <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_sockfd, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_s, <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_PORT )){
                <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Beacon default dialog failed&quot;</FONT></B>);
                <I><FONT COLOR="#B22222">//This child SHOULD NOT return here. Let it continue to the exit(0);
</FONT></I>            }
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Beacon could not dialog because no valid dialog routine is known&quot;</FONT></B>);
        }

    }<B><FONT COLOR="#A020F0">while</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_LOOP);

    <I><FONT COLOR="#B22222">//End dialog with radio by closing the connection.
</FONT></I>    close(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_sockfd);
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">//----------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//General member functions.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Set_No_Timeouts</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//This member will remove all radio and beacon timeouts by setting them all to 'infinite' timeout.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: This function will return 'false' if it is too late to set all of the timeouts, 'true' else.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_INITIALIZED || <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_INITIALIZED){
        <B><FONT COLOR="#A020F0">if</FONT></B>(YGORNETWORKING_VERBOSE) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Too late to set all timeouts - must be done prior to initialization&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_recv_timeout_sec      = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_recv_timeout_usec     = 0;

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_send_timeout_sec     = 0;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_send_timeout_usec    = 0;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Set_No_Loop_Radio</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;RADIO_LOOP = false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Set_No_Loop_Beacon</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_LOOP = false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Beacon_and_Radio::Set_TTL_Hops_Beacon</FONT></B>(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> hops){
    <I><FONT COLOR="#B22222">//This will set the maximum number of hops a message can undergo before expiring. It controls how far a 
</FONT></I>    <I><FONT COLOR="#B22222">// broadcast will ultimately travel. From
</FONT></I>    <I><FONT COLOR="#B22222">// http://www.ibiblio.org/pub/linux/docs/howto/other-formats/html_single/Multicast-HOWTO.html :
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">// TTL (hops)                      Scope
</FONT></I>    <I><FONT COLOR="#B22222">// ------------------------------------------------------------------------
</FONT></I>    <I><FONT COLOR="#B22222">//      0    Restricted to the same host. Won't be output by any interface.
</FONT></I>    <I><FONT COLOR="#B22222">//      1    Restricted to the same subnet. Won't be forwarded by a router.
</FONT></I>    <I><FONT COLOR="#B22222">//    &lt;32    Restricted to the same site, organization or department.
</FONT></I>    <I><FONT COLOR="#B22222">//    &lt;64    Restricted to the same region.
</FONT></I>    <I><FONT COLOR="#B22222">//   &lt;128    Restricted to the same continent.
</FONT></I>    <I><FONT COLOR="#B22222">//   &lt;255    Unrestricted in scope. Global.
</FONT></I>
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;BEACON_TTL_HOPS = hops;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
</PRE>
<HR>
<A NAME="file33">
<H1>YgorNoise.cc 33/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file32">prev</A>][<A HREF="#file34">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorNoise.cc - Routines for providing smooth, deterministic random noise functions over some space. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;inttypes.h&gt;</FONT></B>  //For uint64_t - is this still needed??

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>    //Used for some bitwise operations.


<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------- Simple Perlin Noise. -----------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Found this in a book &quot;Texturing &amp; Modelling - A Procedural Approach&quot; by Ebert et al. (Third Edition.)
</FONT></I><I><FONT COLOR="#B22222">// Code itself begins on page 344. (I haven't seen such ugly code in a LONG time!! Little attempt was
</FONT></I><I><FONT COLOR="#B22222">// made to sanitize the code due to impending deadline.) Constants and definitions from the original
</FONT></I><I><FONT COLOR="#B22222">// source have been renamed to be slightly more safe for embedding into other code.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The code as seen in the original text will not compile due to errors (undefined variables)
</FONT></I><I><FONT COLOR="#B22222">// and typos. Also, C++ will take issue with the use of the 'restrict' used. These have been corrected
</FONT></I><I><FONT COLOR="#B22222">// here.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This function is (I think) NOT threadsafe. Encapsulating this code in a class would probably
</FONT></I><I><FONT COLOR="#B22222">// help. As such, feel free to revamp this code into a more safe, more convenient structure.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//This file provides a simple (as in, not full-featured) Perlin noise generator. Specifically it is
</FONT></I><I><FONT COLOR="#B22222">// a noise function over R3-implemented by a pseudorandom tricubic spline. The scale of the noise is 
</FONT></I><I><FONT COLOR="#B22222">// not adjustable. Assume a basic feature scale of size ~1.0. This means that stepping ~1.0 in any
</FONT></I><I><FONT COLOR="#B22222">// direction will result in moving from the current feature to another. Smooth stepping should be 
</FONT></I><I><FONT COLOR="#B22222">// around ~0.1.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I>
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> PERLIN_HAS_NOT_BEEN_INITIALIZED = 1;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PERLIN_DOT</FONT></B>(a,b)       (a[0] * b[0] + a[1] * b[1] + a[2] * b[2])
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">PERLIN_B</FONT>              256
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PERLIN_AT</FONT></B>(rx,ry,rz)   ( rx * q[0] + ry * q[1] + rz * q[2] )
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PERLIN_S_CURVE</FONT></B>(t)     ( t * t * (3.0f - 2.0f * t) )
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PERLIN_LERP</FONT></B>(t, a, b)  ( a + t * (b - a) )

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>  PERLIN_P[PERLIN_B + PERLIN_B + 2];
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> PERLIN_G[PERLIN_B + PERLIN_B + 2][3];

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PERLIN_SETUP</FONT></B>(i,b0,b1,r0,r1) \
            t = vec[i] + 10000.0f;\
            b0 = static_cast&lt;int&gt;(t) &amp; (PERLIN_B-1); \
            b1 = (b0+1) &amp; (PERLIN_B-1); \
            r0 = t - static_cast&lt;float&gt;(static_cast&lt;int&gt;(t)); \
            r1 = r0 - 1.0f;

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">PERLIN_INIT</FONT></B>(){
    <B><FONT COLOR="#228B22">int</FONT></B> i, j, k;
    <B><FONT COLOR="#228B22">float</FONT></B> v[3], s;

    <I><FONT COLOR="#B22222">/* Create an array of random gradient vectors uniformly on the unit sphere */</FONT></I>
    srandom(1);
    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0 ; i &lt; PERLIN_B ; i++){
        <B><FONT COLOR="#A020F0">do</FONT></B>{
            <I><FONT COLOR="#B22222">/* Choose uniformly in a cube */</FONT></I>
            <B><FONT COLOR="#A020F0">for</FONT></B>(j=0 ; j&lt;3 ; j++)  v[j] = (<B><FONT COLOR="#228B22">float</FONT></B>)((random() % (PERLIN_B + PERLIN_B)) - PERLIN_B)/PERLIN_B;
            s = PERLIN_DOT(v,v);
        }<B><FONT COLOR="#A020F0">while</FONT></B>(s &gt; 1.0); <I><FONT COLOR="#B22222">/* If not in sphere try again */</FONT></I>
        s = ::sqrtf(s);

        <I><FONT COLOR="#B22222">/* Else normalize */</FONT></I>
        <B><FONT COLOR="#A020F0">for</FONT></B>(j = 0 ; j &lt; 3 ; j++)  PERLIN_G[i][j] = v[j] / s;
    }

    <I><FONT COLOR="#B22222">/* Create a pseudorandom permutation of [1 .. PERLIN_B] */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0 ; i &lt; PERLIN_B ; i++)  PERLIN_P[i] = i;
    <B><FONT COLOR="#A020F0">for</FONT></B>(i = PERLIN_B ; i &gt; 0 ; i -= 2){
        k = static_cast&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(PERLIN_P[i]);
        PERLIN_P[i] = PERLIN_P[j = static_cast&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(random() % PERLIN_B)];
        PERLIN_P[j] = k;
    }

    <I><FONT COLOR="#B22222">/* Extend g and p arrays to allow for faster indexing, */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0 ; i &lt; PERLIN_B + 2 ; i++){
        PERLIN_P[PERLIN_B + i] = PERLIN_P[i];
        <B><FONT COLOR="#A020F0">for</FONT></B>(j = 0 ; j &lt; 3 ; j++)  PERLIN_G[PERLIN_B + i][j] = PERLIN_G[i][j];
    }
}

<B><FONT COLOR="#228B22">float</FONT></B> <B><FONT COLOR="#0000FF">Perlin_Noise_3D</FONT></B>(<B><FONT COLOR="#228B22">float</FONT></B> vec[3]){
    <B><FONT COLOR="#228B22">int</FONT></B> bx0, bx1, by0, by1, bz0, bz1, b00, b10, b01, b11;
    <B><FONT COLOR="#228B22">float</FONT></B> rx0, rx1, ry0, ry1, rz0, rz1, *q, sx, sy, sz, a, b, c, d, t, u, v;
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i, j;
    <B><FONT COLOR="#A020F0">if</FONT></B>(PERLIN_HAS_NOT_BEEN_INITIALIZED){
        PERLIN_HAS_NOT_BEEN_INITIALIZED = 0;
        PERLIN_INIT();
    }
    PERLIN_SETUP(0, bx0,bx1, rx0,rx1);
    PERLIN_SETUP(1, by0,by1, ry0,ry1);
    PERLIN_SETUP(2, bz0,bz1, rz0,rz1);
    i = PERLIN_P[ bx0 ];
    j = PERLIN_P[ bx1 ];

    b00 = static_cast&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(PERLIN_P[ static_cast&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(i) + by0 ]);
    b10 = static_cast&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(PERLIN_P[ static_cast&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(j) + by0 ]);
    b01 = static_cast&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(PERLIN_P[ static_cast&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(i) + by1 ]);
    b11 = static_cast&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(PERLIN_P[ static_cast&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(j) + by1 ]);
    sx = PERLIN_S_CURVE(rx0);
    sy = PERLIN_S_CURVE(ry0);
    sz = PERLIN_S_CURVE(rz0);
    q = PERLIN_G[ b00 + bz0 ] ; u = PERLIN_AT(rx0,ry0,rz0);
    q = PERLIN_G[ b10 + bz0 ] ; v = PERLIN_AT(rx1,ry0,rz0);
    a = PERLIN_LERP(sx, u, v);
    q = PERLIN_G[ b01 + bz0 ] ; u = PERLIN_AT(rx0,ry1,rz0);
    q = PERLIN_G[ b11 + bz0 ] ; v = PERLIN_AT(rx1,ry1,rz0);
    b = PERLIN_LERP(sx, u, v);
    c = PERLIN_LERP(sy, a, b);  <I><FONT COLOR="#B22222">/* interpolate in y @ low x */</FONT></I>
    q = PERLIN_G[ b00 + bz1 ] ; u = PERLIN_AT(rx0,ry0,rz1);
    q = PERLIN_G[ b10 + bz1 ] ; v = PERLIN_AT(rx1,ry0,rz1);
    a = PERLIN_LERP(sx, u, v);
    q = PERLIN_G[ b01 + bz1 ] ; u = PERLIN_AT(rx0,ry1,rz1);
    q = PERLIN_G[ b11 + bz1 ] ; v = PERLIN_AT(rx1,ry1,rz1);
    b = PERLIN_LERP(sx, u, v);
    d = PERLIN_LERP(sy, a, b);  <I><FONT COLOR="#B22222">/* interpolate in y @ high x */</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> 1.5f * PERLIN_LERP(sz, c, d); <I><FONT COLOR="#B22222">/* interpolate in z */</FONT></I>
}


<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------ Generic, Integer, Non-Smooth Noise --------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------
</FONT></I>uint64_t <B><FONT COLOR="#0000FF">Number_Jumbler_A</FONT></B>(uint64_t x){
    <B><FONT COLOR="#228B22">const</FONT></B> uint64_t y(x);

    x ^= 11677963410487775812ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 10779949498039803730ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 13404407400705181556ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 6541918881795066415ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 12551287238561482835ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 13047779125789609768ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 2994432632735958836ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 2467000861203750187ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= y;
    x ^= 8292845813995609071ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 775761688528965408ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 14708771606945328297ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 3090858773646032064ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 15333197229523756226ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 5994519175887787353ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 12097003938552935211ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 7751136499891663970ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 14423678012146200904ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 2088033743662153764ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 18327480670582234338ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= y;
    x ^= 3349430276977723711ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 14073600593881942861ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 4905370251551242997ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 4503556080391512727ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 1858297172315272890ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 6351728996150245976ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 5195107484978264032ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 17868261105793408449ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 3943411000588836329ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 11177402618153334904ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 4179134216513746350ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 3503138189720758389ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 7407686287186576649ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 7623866492108957448ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= y;
    x ^= 3138755539887089379ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 5516532306583212975ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 11740772793032145975ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 2796049708711171099ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 14190032055658373991ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 16306342547769868559ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 17694515465111101149ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 333263863792085603ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 10751618092494927052ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 14145961057407284533ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 6046801482689936766ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 2380850499900011064ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 5385725864950539947ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 15626414895563875691ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 4256851693433675165ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 9259793020680978138ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 29476127137113175ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= y;
    x ^= 231300097139420897ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 5286589245567266574ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 1820675968860990365ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 7097480834010725142ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 6555026374276644673ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 13281119593223140774ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 1207248359956480450ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 9479028900846873149ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 7821019804152727552ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 12724587293365216909ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 4684423490755983466ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 7406728549200833893ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 4878731261823934568ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 17233881466973206632ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 8716552197633958503ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 11269414689932863789ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= y;
    x ^= 9009424592425750034ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 9491210774050506105ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 4519807378737332680ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 6142862450555105085ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 9266950187596804657ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 10995328152914833518ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 5721368315548020081ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 17764168814980580855ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 4287029865632944307ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 13777950742951437576ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 5949682953073125528ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 5870346862516060030ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= y;
    x ^= 17570007847167798916ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 9863862280500131296ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 16081966532759700561ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 17240375893298921448ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 12306082758509910019ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 5343826326170324117ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 1208712974382018330ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 4277589956321002543ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 12999858112414469389ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 3599096295913788669ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 7788554561380934621ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 17267168206154539859ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 2623444373074140248ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= y;
    x ^= 11864595387004505704ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 8720368792257066745ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 8059989578706851368ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 4506901874962675126ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 9332565974672983007ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 16730165574228657939ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 1411249219504144069ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 13169202915281416743ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    x ^= 11385421140405288959ULL; x = PER_BYTE_BITWISE_ROT_L(x, 1);
    <B><FONT COLOR="#A020F0">return</FONT></B> x;
}

</PRE>
<HR>
<A NAME="file34">
<H1>YgorPerformance.cc 34/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file33">prev</A>][<A HREF="#file35">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorPerformance.cc - Simple routines to help estimate performance.  
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  NOTE: These are (currently) not high-quality. They simply help DRY principle.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/time.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ctime&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorPerformance.h&quot;</FONT></B>


<I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------- Timing Routines ------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">YgorPerformance_Get_Time</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//Returns the number of seconds from an arbitrary point in the past (~Linux Epoch?)
</FONT></I>    <I><FONT COLOR="#B22222">// For all purposes, it should be subtracted from another call at a later time to get a dt.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Granularity of dt's should be around 10 microsecs AT BEST.
</FONT></I>    <B><FONT COLOR="#228B22">struct</FONT></B> timeval tv;
    gettimeofday(&amp;tv, nullptr);
    <B><FONT COLOR="#A020F0">return</FONT></B> tv.tv_sec + (tv.tv_usec * 1E-6);
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">YgorPerformance_dt_from_last</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//This routine is a simple, one-function interface. Call once to set the time. Call additional
</FONT></I>    <I><FONT COLOR="#B22222">// times to get the dt since the last call.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: This call is NOT threadsafe!
</FONT></I>    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> YgorPerformance_dt_from_last_t = 0.0; <I><FONT COLOR="#B22222">//Will only be set to 0.0 the first time!
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>(YgorPerformance_dt_from_last_t == 0.0){
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Initialized timing marker.&quot;</FONT></B> &lt;&lt; std::endl;
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> t2 = YgorPerformance_Get_Time();
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Time since last call: &quot;</FONT></B> &lt;&lt; t2 - YgorPerformance_dt_from_last_t &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; seconds &quot;</FONT></B> &lt;&lt; std::endl;
    }
    YgorPerformance_dt_from_last_t = YgorPerformance_Get_Time();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<I><FONT COLOR="#B22222">/*
void NOT_TO_BE_CALLED_BY_USER_YgorPerformance_dt_from_last(void){
    static double NOT_TO_BE_CALLED_BY_USER_YgorPerformance_dt_from_last_t = 0.0; //Will only be set to 0.0 the first time!

    if(YgorPerformance_dt_from_last_t == 0.0){
        YgorPerformance_dt_from_last_t = YgorPerformance_Get_Time();
    }else{
        const auto t2 = YgorPerformance_Get_Time();
        std::cout &lt;&lt; &quot;Time since last call: &quot; &lt;&lt; t2 - NOT_TO_BE_CALLED_BY_USER_YgorPerformance_dt_from_last_t &lt;&lt; &quot; seconds &quot; &lt;&lt; std::endl;
        YgorPerformance_dt_from_last_t = YgorPerformance_Get_Time();
    }
    return;
}
*/</FONT></I>

</PRE>
<HR>
<A NAME="file35">
<H1>YgorPlot.cc 35/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file34">prev</A>][<A HREF="#file36">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorPlot.cc - Simple plotting routines which wrap around Gnuplot, (GNU)plotutils, a postscript plotting library, or good-ol'-fashioned 
</FONT></I><I><FONT COLOR="#B22222">// roll-your-own plotting routines.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//The idea behind this file is to easily have some plotting facilities within a program without having to deal directly with pipes and
</FONT></I><I><FONT COLOR="#B22222">// plotting formats in situ. 
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>    //Used for popen.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>    //Used for FILE.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>    //Used for the macros FUNCINFO, FUNCWARN, FUNCERR.
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorPlot.h&quot;</FONT></B>


<I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------- Plotter - A Plotutils-based class ---------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I>
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Plotter::Plot</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//First, check if there is any data in the stream and/or in the string.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string from_the_stream = ss.str();
    <B><FONT COLOR="#228B22">bool</FONT></B> stream_empty = from_the_stream.empty();
    <B><FONT COLOR="#228B22">bool</FONT></B> string_empty = plotting_data.empty();

    <B><FONT COLOR="#A020F0">if</FONT></B>( stream_empty &amp;&amp; string_empty ){
        <I><FONT COLOR="#B22222">//Then we do nothing. There is no data to send off.
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B> false;    
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>( (!stream_empty &amp;&amp; string_empty) || ( !stream_empty &amp;&amp; !string_empty ) ){
        <I><FONT COLOR="#B22222">//Then we have to place the stream contents into the string. We make sure to append the data.
</FONT></I>        plotting_data += <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> + from_the_stream;
        ss.str(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>); <I><FONT COLOR="#B22222">// (empty the stringstream)
</FONT></I>
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>( stream_empty &amp;&amp; !string_empty ){
        <I><FONT COLOR="#B22222">//Then the data is already in the string. No need to adjust anything.
</FONT></I>
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>( fp != NULL ){
        <I><FONT COLOR="#B22222">//Now we plot the string.
</FONT></I>        fprintf(fp, <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, plotting_data.c_str());
        plotting_data.clear();
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }

    <I><FONT COLOR="#B22222">//If we could not plot, we simply hold onto the data (in the string) so that we might be able to plot it later after resolving the pipe issue.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter::Iterate_Linestyle</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//  From the plotutils documentation:
</FONT></I>    <I><FONT COLOR="#B22222">// ...&quot;For colored datasets, the line can be drawn in one of 25 distinct styles. Linemodes #1 through #5 signify red, green, blue, magenta, 
</FONT></I>    <I><FONT COLOR="#B22222">//     and cyan; all are solid. Linemodes #6 through #10 signify the same five colors, but dotted rather than solid. Linemodes #11 through 
</FONT></I>    <I><FONT COLOR="#B22222">//     #16 signify the same five colors, but dotdashed, and so forth. After linemode #25, the sequence repeats. Linemode #0, irrespective 
</FONT></I>    <I><FONT COLOR="#B22222">//     of whether the rendering is in monochrome or color, means that the line is not drawn.&quot; ...
</FONT></I>    ++linestyle_m;  <I><FONT COLOR="#B22222">//The line mode (solid, dashed, etc..) 
</FONT></I>    ++linestyle_s;  <I><FONT COLOR="#B22222">//The line (point) style (dot, star, triangle, etc..) There are 31 distinct, native styles.
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>(linestyle_m == 0) linestyle_m = 1;
    <B><FONT COLOR="#A020F0">if</FONT></B>(linestyle_s &gt; 31) linestyle_s = 1;

    <I><FONT COLOR="#B22222">//Although this looks like a comment, we can direct plotutils with specially-formated comments like this.
</FONT></I>    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;#m=&quot;</FONT></B> &lt;&lt; linestyle_m &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,S=&quot;</FONT></B> &lt;&lt; linestyle_s &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------- Plotter2 - A GNUplot-based class ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//Constructor/Destructor.
</FONT></I><B><FONT COLOR="#0000FF">Plotter2::Plotter2</FONT></B>(){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Apply_Basic_Header_Customizations();
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Apply_Basic_Footer_Customizations();
}
<B><FONT COLOR="#0000FF">Plotter2::~Plotter2</FONT></B>(){}

<I><FONT COLOR="#B22222">//Internal methods. Do not use unless you know what you are doing.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Apply_Basic_Header_Customizations</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;# set term pdfcairo enhanced color solid font 'cmr10,12' size 7.5in,5.5in&quot;</FONT></B>); <I><FONT COLOR="#B22222">//Helpful comment.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;# set output ''&quot;</FONT></B>); <I><FONT COLOR="#B22222">//Helpful comment.
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> std::string linewidth(<B><FONT COLOR="#BC8F8F">&quot;1.1&quot;</FONT></B>), pointsize(<B><FONT COLOR="#BC8F8F">&quot;0.6&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">const</FONT></B> std::string pt_circ_solid(<B><FONT COLOR="#BC8F8F">&quot;5&quot;</FONT></B>), pt_box_solid(<B><FONT COLOR="#BC8F8F">&quot;9&quot;</FONT></B>), pt_tri_solid(<B><FONT COLOR="#BC8F8F">&quot;13&quot;</FONT></B>), pt_dimnd_solid(<B><FONT COLOR="#BC8F8F">&quot;11&quot;</FONT></B>), pt_invtri_solid(<B><FONT COLOR="#BC8F8F">&quot;7&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N(0);
    <I><FONT COLOR="#B22222">//These are tweakable. Try to favour dark colours (why in the fuck does GNUplot use light teal and light yellow?!)
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set pointsize &quot;</FONT></B>_s + pointsize);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#000000' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_circ_solid  );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#1D4599' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_circ_solid  );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#11AD34' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_circ_solid  );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#E62B17' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_circ_solid  );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#E69F17' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_box_solid   );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#2F3F60' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_box_solid   );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#2F6C3D' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_box_solid   );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#8F463F' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_box_solid   );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#8F743F' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_dimnd_solid );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#031A49' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_dimnd_solid );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#025214' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_dimnd_solid );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#6D0D03' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_dimnd_solid );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#6D4903' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_tri_solid   );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#224499' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_tri_solid   );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#00FF00' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_tri_solid   );
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#00BBBB' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_invtri_solid);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#000000' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_invtri_solid);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style line &quot;</FONT></B>_s + Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(++N) + <B><FONT COLOR="#BC8F8F">&quot; lc rgb '#000000' lw &quot;</FONT></B>_s + linewidth + <B><FONT COLOR="#BC8F8F">&quot; pt &quot;</FONT></B>_s + pt_invtri_solid);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set style increment user&quot;</FONT></B>_s);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set grid lc rgb '#000000'&quot;</FONT></B>_s);

    <I><FONT COLOR="#B22222">//These colours were tweaked by hand. They are 6 orthogonal colours which remain orthogonal when flattened to greyscale.
</FONT></I>    <I><FONT COLOR="#B22222">// They are good for histograms or filled curves.
</FONT></I>    <I><FONT COLOR="#B22222">//black
</FONT></I>    <I><FONT COLOR="#B22222">//#126B12 - darkened forest-green
</FONT></I>    <I><FONT COLOR="#B22222">//#FFE730 - light yellow (not suitable for thin lines)
</FONT></I>    <I><FONT COLOR="#B22222">//#382D5B - dark violet
</FONT></I>    <I><FONT COLOR="#B22222">//#008B8B - turquise
</FONT></I>    <I><FONT COLOR="#B22222">//#FFB540 - peachy
</FONT></I>
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set zero 1e-50&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Apply_Basic_Footer_Customizations</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;footer.push_back(<B><FONT COLOR="#BC8F8F">&quot;# set output&quot;</FONT></B>); <I><FONT COLOR="#B22222">//Helpful comment.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;footer.push_back(<B><FONT COLOR="#BC8F8F">&quot;# set term pop&quot;</FONT></B>); <I><FONT COLOR="#B22222">//Helpful comment.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Append_Header</FONT></B>(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(ss == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed an invalid reference&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.begin(); s_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.end(); ++s_it) *ss &lt;&lt; *s_it &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Append_StrDat</FONT></B>(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(ss == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed an invalid reference&quot;</FONT></B>);

    <I><FONT COLOR="#B22222">//To avoid writing everything twice, we copy everything at runtime. Ouch! This is the cost of 
</FONT></I>    <I><FONT COLOR="#B22222">// a minor decrease in maintenance burden...
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;Plotter2_Helper&gt; combined(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;working.data.samples.empty())) combined.push_back(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;working);

    <I><FONT COLOR="#B22222">//All the data we have cached.
</FONT></I>    *ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;plot 1/0 title '' &quot;</FONT></B>;  <I><FONT COLOR="#B22222">//Undefined first plot is ignored and most convenient. 
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p2h_it = combined.begin(); p2h_it != combined.end(); ++p2h_it){
        *ss &lt;&lt; R<B><FONT COLOR="#BC8F8F">&quot;***( , \)***&quot;</FONT></B> &lt;&lt; std::endl &lt;&lt; R<B><FONT COLOR="#BC8F8F">&quot;***(    &quot;</FONT></B>&lt; echo -e ')***<B><FONT COLOR="#BC8F8F">&quot;;     //&quot;</FONT></B><I><FONT COLOR="#B22222">//Incorrect parsing of raw literals :/.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> v2_it = p2h_it-&gt;data.samples.begin(); v2_it != p2h_it-&gt;data.samples.end(); ++v2_it){
            *ss &lt;&lt; v2_it-&gt;x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; v2_it-&gt;y &lt;&lt; R<B><FONT COLOR="#BC8F8F">&quot;***(\n)***&quot;</FONT></B>;
        }
        *ss &lt;&lt; R<B><FONT COLOR="#BC8F8F">&quot;***('&quot;</FONT></B> )***<B><FONT COLOR="#BC8F8F">&quot;;                //&quot;</FONT></B><I><FONT COLOR="#B22222">//Incorrect parsing of raw literals :/.
</FONT></I>        *ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;with  &quot;</FONT></B> &lt;&lt; (p2h_it-&gt;type.empty() ? <B><FONT COLOR="#BC8F8F">&quot;lp&quot;</FONT></B> : p2h_it-&gt;type) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        <I><FONT COLOR="#B22222">/*if(!p2h_it-&gt;title.empty())*/</FONT></I> *ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;title \&quot;&quot;</FONT></B> &lt;&lt; p2h_it-&gt;title &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\&quot; &quot;</FONT></B>;
    }
    *ss &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Append_Footer</FONT></B>(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(ss == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed an invalid reference&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;footer.begin(); s_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;footer.end(); ++s_it) *ss &lt;&lt; *s_it &lt;&lt; std::endl;

    <I><FONT COLOR="#B22222">//Also dump stringified samples_1D data so we can more easily read/manipulate the data, if needed.
</FONT></I>    *ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;# Stringified samples_1D raw data (in corresponding order as plotted)&quot;</FONT></B> &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p2h_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data.begin(); p2h_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data.end(); ++p2h_it){
         *ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;# &quot;</FONT></B> &lt;&lt; p2h_it-&gt;data &lt;&lt; std::endl;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(!(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;working.data.samples.empty())){
         *ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;# &quot;</FONT></B> &lt;&lt; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;working.data &lt;&lt; std::endl;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<I><FONT COLOR="#B22222">//Methods.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Set_Global_Title</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <I><FONT COLOR="#B22222">//this-&gt;header.push_back(&quot;set title '&quot;_s + in + &quot;'&quot;_s);  //Using '' instead of &quot;&quot; will annoyingly forgo expansion of \n.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;set title \&quot;&quot;</FONT></B>_s + in + <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B>_s); 
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<I><FONT COLOR="#B22222">//Routines which use the working buffer and have internal state.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Set_Current_Line_Title</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;working.title = in;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Set_Current_Line_Type</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){  <I><FONT COLOR="#B22222">//'lines', 'points', or 'linespoints'
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;working.type = in;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Insert</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;working.data.samples.push_back(vec2&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(x,y));
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Next_Line</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data.push_back(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;working);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;working = Plotter2_Helper();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<I><FONT COLOR="#B22222">//Routines which have minimal internal state.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Insert_samples_1D</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;title<I><FONT COLOR="#B22222">/*=&quot;&quot;*/</FONT></I>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;linetype<I><FONT COLOR="#B22222">/*=&quot;&quot;*/</FONT></I>){
    Plotter2_Helper shtl;
    shtl.data = in;
    shtl.title = title;
    shtl.type = linetype;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;data.push_back(shtl);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Insert_map_of_string_and_samples_1D</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::map&lt;std::string, samples_1D&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;linetype<I><FONT COLOR="#B22222">/*=&quot;&quot;*/</FONT></I>){
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> m_it = in.begin(); m_it != in.end(); ++m_it){
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Insert_samples_1D(m_it-&gt;second, m_it-&gt;first, linetype);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<I><FONT COLOR="#B22222">//Various plotting options.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Plot</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//We now gather all the pieces to produce a single string which is piped to GNUplot.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Header(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_StrDat(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Footer(&amp;ss);

    <I><FONT COLOR="#B22222">//Pipe it.
</FONT></I>    FILE *fp = nullptr;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!(fp = popen(<B><FONT COLOR="#BC8F8F">&quot;gnuplot -persist &amp;&gt;/dev/null&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>))) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!ss.good()) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    fprintf(fp, <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, ss.str().c_str());
    <B><FONT COLOR="#A020F0">if</FONT></B>(pclose(fp) == -1) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//FUNCERR(&quot;Unable to close pipe. Is the process still active?&quot;);
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Plotter2::Plot_as_PDF</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;Filename) <B><FONT COLOR="#228B22">const</FONT></B> { <I><FONT COLOR="#B22222">//May overwrite existing files!
</FONT></I>    <I><FONT COLOR="#B22222">//We now gather all the pieces to produce a single string which is piped to GNUplot.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Header(&amp;ss);
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set term pdfcairo enhanced color solid font 'cmr10,12' size 7.5in,5.5in&quot;</FONT></B> &lt;&lt; std::endl; <I><FONT COLOR="#B22222">//Hopefully font 'cmr10' is around
</FONT></I>    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set output '&quot;</FONT></B> &lt;&lt; Filename &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B> &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_StrDat(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Footer(&amp;ss);
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set output&quot;</FONT></B> &lt;&lt; std::endl;
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set term pop&quot;</FONT></B> &lt;&lt; std::endl;

    <I><FONT COLOR="#B22222">//Pipe it.
</FONT></I>    FILE *fp = nullptr;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!(fp = popen(<B><FONT COLOR="#BC8F8F">&quot;gnuplot -persist &amp;&gt;/dev/null&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>))) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!ss.good()) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    fprintf(fp, <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, ss.str().c_str());
    <B><FONT COLOR="#A020F0">if</FONT></B>(pclose(fp) == -1) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//FUNCERR(&quot;Unable to close pipe. Is the process still active?&quot;);
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
std::string Plotter2::Dump_as_String(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {  <I><FONT COLOR="#B22222">//aka 'plot to string'
</FONT></I>    <I><FONT COLOR="#B22222">//We now gather all the pieces to produce a single string which is piped to GNUplot.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Header(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_StrDat(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Footer(&amp;ss);
    <B><FONT COLOR="#A020F0">return</FONT></B> ss.str();
}


<I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This is a sort of 'tiling plotter'. It wraps individual (unconnected) plots in the most basic way.
</FONT></I><I><FONT COLOR="#B22222">// This class does not (currently) provide a working space like Plotter2 does. Add it if needed.
</FONT></I>
<I><FONT COLOR="#B22222">//Constructor/Destructor.
</FONT></I><B><FONT COLOR="#0000FF">MultiPlotter2::MultiPlotter2</FONT></B>(){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Apply_Basic_Header_Customizations();
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Apply_Basic_Footer_Customizations();
}
<B><FONT COLOR="#0000FF">MultiPlotter2::~MultiPlotter2</FONT></B>(){}

<I><FONT COLOR="#B22222">//Internal methods. Do not use unless you know what you are doing.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MultiPlotter2::Apply_Basic_Header_Customizations</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//NOTE: We will set multiplot at plot time.
</FONT></I>    <I><FONT COLOR="#B22222">//this-&gt;header.push_back(R&quot;***(set multiplot layout 4,1 title 'Auto-layout of stacked plots\n')***&quot;);
</FONT></I><I><FONT COLOR="#B22222">//    this-&gt;header.push_back(&quot;set tmargin 2&quot;);
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;# set term pdfcairo enhanced color solid font 'cmr10,12' size 7.5in,5.5in&quot;</FONT></B>); <I><FONT COLOR="#B22222">//Helpful comment.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.push_back(<B><FONT COLOR="#BC8F8F">&quot;# set output ''&quot;</FONT></B>); <I><FONT COLOR="#B22222">//Helpful comment.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MultiPlotter2::Apply_Basic_Footer_Customizations</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <I><FONT COLOR="#B22222">//NOTE: We will unset multiplot at plot time.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;footer.push_back(<B><FONT COLOR="#BC8F8F">&quot;# set output&quot;</FONT></B>); <I><FONT COLOR="#B22222">//Helpful comment.
</FONT></I>    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;footer.push_back(<B><FONT COLOR="#BC8F8F">&quot;# set term pop&quot;</FONT></B>); <I><FONT COLOR="#B22222">//Helpful comment.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MultiPlotter2::Append_Header</FONT></B>(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(ss == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed an invalid reference&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.begin(); s_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;header.end(); ++s_it) *ss &lt;&lt; *s_it &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MultiPlotter2::Append_SubPlots</FONT></B>(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(ss == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed an invalid reference&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;subplots.begin(); s_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;subplots.end(); ++s_it){
        *ss &lt;&lt; s_it-&gt;Dump_as_String() &lt;&lt; std::endl;
        *ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;#&quot;</FONT></B> &lt;&lt; std::endl; <I><FONT COLOR="#B22222">//Easier for poor human to read...
</FONT></I>    }
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MultiPlotter2::Append_Footer</FONT></B>(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(ss == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed an invalid reference&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;footer.begin(); s_it != <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;footer.end(); ++s_it) *ss &lt;&lt; *s_it &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MultiPlotter2::Open_Multiplot_Environ</FONT></B>(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(ss == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed an invalid reference&quot;</FONT></B>);
    <I><FONT COLOR="#B22222">//Do to some little quirks in GNUplot, we have to choose both the layout
</FONT></I>    <I><FONT COLOR="#B22222">// and commit the global title when we open up the multiplot environment.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Therefore, this routine should apply some 'smart' heuristics to layout
</FONT></I>    <I><FONT COLOR="#B22222">// plots in a sane way. Feel free to add/tweak as needed.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> N = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;subplots.size());

    <I><FONT COLOR="#B22222">//One-row layout.
</FONT></I>    <I><FONT COLOR="#B22222">//*ss &lt;&lt; &quot;set multiplot layout 1, &quot; &lt;&lt; N &lt;&lt; &quot; title \&quot;&quot; &lt;&lt; this-&gt;global_title &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
</FONT></I>
    <I><FONT COLOR="#B22222">//One-col layout.
</FONT></I>    <I><FONT COLOR="#B22222">//*ss &lt;&lt; &quot;set multiplot layout &quot; &lt;&lt; N &lt;&lt; &quot;, 1 title \&quot;&quot; &lt;&lt; this-&gt;global_title &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
</FONT></I>
    <I><FONT COLOR="#B22222">// ...
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>(N &lt;= 2){
        *ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set multiplot layout 1, &quot;</FONT></B> &lt;&lt; N &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; title \&quot;&quot;</FONT></B> &lt;&lt; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;global_title &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B> &lt;&lt; std::endl;
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(N &lt;= 4){
        *ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set multiplot layout 2, &quot;</FONT></B> &lt;&lt; 2 &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; title \&quot;&quot;</FONT></B> &lt;&lt; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;global_title &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B> &lt;&lt; std::endl;
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> M = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B>(2*M &lt; N) ++M; 
        *ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set multiplot layout 2, &quot;</FONT></B> &lt;&lt; M &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; title \&quot;&quot;</FONT></B> &lt;&lt; <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;global_title &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B> &lt;&lt; std::endl;
    }

    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MultiPlotter2::Close_Multiplot_Environ</FONT></B>(std::stringstream *ss) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(ss == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed an invalid reference&quot;</FONT></B>);
    *ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;unset multiplot&quot;</FONT></B> &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<I><FONT COLOR="#B22222">//Methods.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MultiPlotter2::Set_Global_Title</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;global_title = in;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<I><FONT COLOR="#B22222">//Routines which have minimal internal state.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MultiPlotter2::Insert_Plotter2</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> Plotter2 &amp;in){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;subplots.push_back(in);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<I><FONT COLOR="#B22222">//Various plotting options.
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">MultiPlotter2::Plot</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//We now gather all the pieces to produce a single string which is piped to GNUplot.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;

    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set term x11&quot;</FONT></B> &lt;&lt; std::endl;  <I><FONT COLOR="#B22222">//This is done to handle multiplot refreshing (wxt cannot do properly).
</FONT></I>
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Open_Multiplot_Environ(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Header(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_SubPlots(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Footer(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Close_Multiplot_Environ(&amp;ss);

    <I><FONT COLOR="#B22222">//Pipe it.
</FONT></I>    FILE *fp = nullptr;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!(fp = popen(<B><FONT COLOR="#BC8F8F">&quot;gnuplot -persist &amp;&gt;/dev/null&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>))) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!ss.good()) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    fprintf(fp, <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, ss.str().c_str());
    <B><FONT COLOR="#A020F0">if</FONT></B>(pclose(fp) == -1) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//FUNCERR(&quot;Unable to close pipe. Is the process still active?&quot;);
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">MultiPlotter2::Plot_as_PDF</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;Filename) <B><FONT COLOR="#228B22">const</FONT></B> { <I><FONT COLOR="#B22222">//May overwrite existing files!
</FONT></I>    <I><FONT COLOR="#B22222">//We now gather all the pieces to produce a single string which is piped to GNUplot.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;

    <I><FONT COLOR="#B22222">//NOTE: Here we can use multiplot (probably best for publications and what-not) or
</FONT></I>    <I><FONT COLOR="#B22222">// we can simply issue multiple plot commands and get several-page pdfs. See
</FONT></I>    <I><FONT COLOR="#B22222">// http://stackoverflow.com/questions/4334301/how-to-create-a-multi-page-pdf-file-with-gnuplot
</FONT></I>
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set term pdfcairo enhanced color solid font 'cmr10,12' size 7.5in,5.5in&quot;</FONT></B> &lt;&lt; std::endl; <I><FONT COLOR="#B22222">//Hopefully font 'cmr10' is around
</FONT></I>    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set output '&quot;</FONT></B> &lt;&lt; Filename &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B> &lt;&lt; std::endl;

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Open_Multiplot_Environ(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Header(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_SubPlots(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Footer(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Close_Multiplot_Environ(&amp;ss);

    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set output&quot;</FONT></B> &lt;&lt; std::endl;
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;set term pop&quot;</FONT></B> &lt;&lt; std::endl;

    <I><FONT COLOR="#B22222">//Pipe it.
</FONT></I>    FILE *fp = nullptr;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!(fp = popen(<B><FONT COLOR="#BC8F8F">&quot;gnuplot -persist &amp;&gt;/dev/null&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>))) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!ss.good()) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    fprintf(fp, <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, ss.str().c_str());
    <B><FONT COLOR="#A020F0">if</FONT></B>(pclose(fp) == -1) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//FUNCERR(&quot;Unable to close pipe. Is the process still active?&quot;);
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
std::string MultiPlotter2::Dump_as_String(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {  <I><FONT COLOR="#B22222">//aka 'plot to string'
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Open_Multiplot_Environ(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Header(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_SubPlots(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Append_Footer(&amp;ss);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Close_Multiplot_Environ(&amp;ss);

    <B><FONT COLOR="#A020F0">if</FONT></B>(!ss.good()) <B><FONT COLOR="#A020F0">return</FONT></B> out;
    <B><FONT COLOR="#A020F0">return</FONT></B> ss.str();
}

<I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------- Plotter3 - A GNUplot-based class ----------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter3::Set_Current_Line_Title</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    current_line_title = in;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter3::Set_Global_Title</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    global_title = in;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter3::Set_Current_Line_Use</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){   <I><FONT COLOR="#B22222">//'lines', 'points', or 'linespoints'
</FONT></I>    current_line_use = in;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter3::Insert</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;x, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;y, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> &amp;z){
    ss &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; z &lt;&lt; R<B><FONT COLOR="#BC8F8F">&quot;***(\n)***&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter3::Next_Line</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    ss &lt;&lt; YGORPLOT3_H_PIPE_FINISH_SENDING_DATA;
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; w &quot;</FONT></B> &lt;&lt; current_line_use &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; lt &quot;</FONT></B> &lt;&lt; current_line_style &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; title '&quot;</FONT></B> &lt;&lt; current_line_title &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;' &quot;</FONT></B>;

    ss &lt;&lt; YGORPLOT3_H_PIPE_NEXT_SERIES;
    ss &lt;&lt; YGORPLOT3_H_PIPE_BEGIN_SENDING_DATA;

    <I><FONT COLOR="#B22222">//--------------- Iterate current settings for new line -------------------
</FONT></I>    ++current_line_style;       <I><FONT COLOR="#B22222">//Update line type for next line.
</FONT></I>    current_line_title.clear(); <I><FONT COLOR="#B22222">//Clear the title.
</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">Plotter3::Next_Line_Same_Style</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    ss &lt;&lt; YGORPLOT3_H_PIPE_FINISH_SENDING_DATA;
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; w &quot;</FONT></B>  &lt;&lt; current_line_use   &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; lt &quot;</FONT></B> &lt;&lt; current_line_style &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; title '&quot;</FONT></B> &lt;&lt; current_line_title &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;' &quot;</FONT></B>;

    ss &lt;&lt; YGORPLOT3_H_PIPE_NEXT_SERIES;
    ss &lt;&lt; YGORPLOT3_H_PIPE_BEGIN_SENDING_DATA;

    <I><FONT COLOR="#B22222">//Do not iterate current settings for next line.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Plotter3::Plot</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    ss &lt;&lt; YGORPLOT3_H_PIPE_FINISH_SENDING_DATA;
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; w &quot;</FONT></B>  &lt;&lt; current_line_use   &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; lt &quot;</FONT></B> &lt;&lt; current_line_style &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; title '&quot;</FONT></B> &lt;&lt; current_line_title &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;' &quot;</FONT></B>;

    <I><FONT COLOR="#B22222">//----------------------------------
</FONT></I>    <I><FONT COLOR="#B22222">//Ensure the global settings are applied.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(! global_title.empty()){
        <B><FONT COLOR="#228B22">const</FONT></B> std::string old(ss.str());
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string pre(<B><FONT COLOR="#BC8F8F">&quot; set title '&quot;</FONT></B>);  pre += global_title + <B><FONT COLOR="#BC8F8F">&quot;' ; &quot;</FONT></B>;
        <B><FONT COLOR="#228B22">const</FONT></B> std::streamsize pos = ss.tellp();
        ss.str(pre + ss.str());
        ss.seekp(pos + pre.length());
        global_title.clear();
    }

    ss &lt;&lt; std::endl;
    <B><FONT COLOR="#A020F0">if</FONT></B>((fp != nullptr) &amp;&amp; (ss.good())){
        fprintf(fp, <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, ss.str().c_str());
        <I><FONT COLOR="#B22222">//Prepare it again.
</FONT></I>        ss.str(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>); <I><FONT COLOR="#B22222">//.clear();
</FONT></I>        ss &lt;&lt; YGORPLOT3_H_PIPE_PREP;
        ss &lt;&lt; YGORPLOT3_H_PIPE_BEGIN_SENDING_DATA;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <I><FONT COLOR="#B22222">//If we could not plot, we simply hold onto the data so that we might be able to plot it later after resolving the pipe issue.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}



</PRE>
<HR>
<A NAME="file36">
<H1>YgorSerialize.cc 36/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file35">prev</A>][<A HREF="#file37">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorSerialize.cc - Helper routines for serializing data types to and from 
</FONT></I><I><FONT COLOR="#B22222">//  string or uint8_t memory blocks.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: These routines are ignorant of machine-specific encodings, including the
</FONT></I><I><FONT COLOR="#B22222">// floating-point layout, endianness, and any differences in basic types between
</FONT></I><I><FONT COLOR="#B22222">// platforms. THEREFORE, the user of these routines must be aware of these issues.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// See existing software for some ideas to work around this. Here are some briefs:
</FONT></I><I><FONT COLOR="#B22222">// ---------------------------
</FONT></I><I><FONT COLOR="#B22222">//  - version consistency - Encode a version number in the serialized data. Use it
</FONT></I><I><FONT COLOR="#B22222">//                          to properly handle updated/outdated serialization 
</FONT></I><I><FONT COLOR="#B22222">//                          schemes.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  - floating-point layout - Choose a specific double/float encoding scheme. 
</FONT></I><I><FONT COLOR="#B22222">//                            Using &lt;limits&gt; header, check that the platform uses
</FONT></I><I><FONT COLOR="#B22222">//                            the scheme whenever serialization/deserialization
</FONT></I><I><FONT COLOR="#B22222">//                            occurs. If needed, provide a translation routine to
</FONT></I><I><FONT COLOR="#B22222">//                            and from the chosen scheme.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  - endianness - Choose a 'network endianness' scheme. Convert all necessary data 
</FONT></I><I><FONT COLOR="#B22222">//                 to and from the scheme. BSD socket implementations can help here.
</FONT></I><I><FONT COLOR="#B22222">// ---------------------------
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstring&gt;</FONT></B>  //For memcpy().  
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
<I><FONT COLOR="#B22222">//#include &lt;ctime&gt;    //For std::time_t.
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;memory&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;limits&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdint&gt;</FONT></B>   //For uint8_t, uint32_t, etc..

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorSerialize.h&quot;</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGORSERIALIZE_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    #define YGORSERIALIZE_INCLUDE_ALL_SPECIALIZATIONS
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<I><FONT COLOR="#B22222">//Error reporting function used internally.
</FONT></I><B><FONT COLOR="#228B22">static</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; 
<B><FONT COLOR="#0000FF">FailWarn_or_Die</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;fail, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;die){
    <I><FONT COLOR="#B22222">//If the user has not provided any extra channel or means of indicating an error, kill everything.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(OK == nullptr) FUNCERR(die);

    <I><FONT COLOR="#B22222">//Otherwise, issue a warning message, ensure the fail bit is set, and return.
</FONT></I>    *OK = false;
    FUNCWARN(fail);
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
<B><FONT COLOR="#0000FF">SERIALIZE::Put</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, T val){
    <I><FONT COLOR="#B22222">//Parameters:
</FONT></I>    <I><FONT COLOR="#B22222">//  - OK     - Indicates success or failure. Do not use output if false.
</FONT></I>    <I><FONT COLOR="#B22222">//  - in     - The block of memory holding the serialized data.
</FONT></I>    <I><FONT COLOR="#B22222">//  - offset - The offset from in[0] in sizeof(uint8_t) = 1 = BYTES indicating the data. Will be incremented after read.
</FONT></I>    <I><FONT COLOR="#B22222">//  - max    - The size of the memory block &quot;in&quot;. Offset cannot legally exceed this number, or be less than 0.
</FONT></I>    <I><FONT COLOR="#B22222">//  - val    - The value to place into memory.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//TODO: 
</FONT></I>    <I><FONT COLOR="#B22222">//  - Pick an endianness. Enforce it during serialization/deserialization. (Use 'network endianness' ?)
</FONT></I>    <I><FONT COLOR="#B22222">//  - 
</FONT></I>    
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Indicating failure and continuing&quot;</FONT></B>, 
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + <B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)) &gt; max){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Desired value is beyond the bounds of the memory passed in. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Desired value is beyond the bounds of the memory passed in. Unable to continue&quot;</FONT></B>);
    }

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> ptrtomem = reinterpret_cast&lt;T *&gt;(in.get() + *offset);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!ptrtomem){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Region of memory indicated failed a reinterpret_cast. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Region of memory indicated failed a reinterpret_cast. Unable to continue&quot;</FONT></B>);
    }

    <I><FONT COLOR="#B22222">//Copy the value to the specified location.
</FONT></I>    *offset += <B><FONT COLOR="#A020F0">sizeof</FONT></B>(T);
    *ptrtomem = val;
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORSERIALIZE_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, uint8_t);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, uint16_t);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, uint32_t);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, uint64_t);

    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, int8_t);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, int16_t);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, int32_t);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, int64_t);

    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">char</FONT></B>);

<I><FONT COLOR="#B22222">//On my 32bit machine, this is unique from the the others.  Need to figure out how to conditionally compile this...
</FONT></I><I><FONT COLOR="#B22222">// Alternatively - do not bother. Serializing std::time_t is going to lead to *many* more issues....
</FONT></I><I><FONT COLOR="#B22222">//    template std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(bool *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::time_t);
</FONT></I>
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">float</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">double</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
namespace SERIALIZE {
    <B><FONT COLOR="#228B22">template</FONT></B> &lt;&gt; std::unique_ptr&lt;uint8_t[]&gt;
    Put(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, std::string val){
        <B><FONT COLOR="#A020F0">return</FONT></B> SERIALIZE::Put_String(OK,std::move(in),offset,max,val);
    }
}

namespace SERIALIZE {
    <B><FONT COLOR="#228B22">template</FONT></B> &lt;&gt; std::unique_ptr&lt;uint8_t[]&gt;
    Put(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;val){
        <B><FONT COLOR="#A020F0">return</FONT></B> SERIALIZE::Put_String(OK,std::move(in),offset,max,val);
    }
}

namespace SERIALIZE {
    <B><FONT COLOR="#228B22">template</FONT></B> &lt;&gt; std::unique_ptr&lt;uint8_t[]&gt;
    Put(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::string&gt; &amp;val){
        <B><FONT COLOR="#A020F0">return</FONT></B> SERIALIZE::Put_Sequence_Container(OK,std::move(in),offset,max,val);
    }
}

namespace SERIALIZE {
    <B><FONT COLOR="#228B22">template</FONT></B> &lt;&gt; std::unique_ptr&lt;uint8_t[]&gt;
    Put(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, std::list&lt;std::string&gt; val){
        <B><FONT COLOR="#A020F0">return</FONT></B> SERIALIZE::Put_Sequence_Container(OK,std::move(in),offset,max,val);
    }
}




<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
<B><FONT COLOR="#0000FF">SERIALIZE::Get</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, T *val){
    <I><FONT COLOR="#B22222">//Parameters:
</FONT></I>    <I><FONT COLOR="#B22222">//  - OK     - Indicates success or failure. Do not use output if false.
</FONT></I>    <I><FONT COLOR="#B22222">//  - in     - The block of memory holding the serialized data.
</FONT></I>    <I><FONT COLOR="#B22222">//  - offset - The offset from in[0] in sizeof(uint8_t) = 1 = BYTES indicating the data. Will be incremented after read.
</FONT></I>    <I><FONT COLOR="#B22222">//  - max    - The size of the memory block &quot;in&quot;. Offset cannot legally exceed this number, or be less than 0.
</FONT></I>    <I><FONT COLOR="#B22222">//  - val    - The location to store the variable.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//TODO: 
</FONT></I>    <I><FONT COLOR="#B22222">//  - Pick an endianness. Enforce it during serialization/deserialization. (Use 'network endianness' ?)
</FONT></I>    <I><FONT COLOR="#B22222">//  - 
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + <B><FONT COLOR="#A020F0">sizeof</FONT></B>(T)) &gt; max){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Desired value is beyond the bounds of the memory passed in. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Desired value is beyond the bounds of the memory passed in. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(val == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr instead of a location for storing the variable. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr instead of a location for storing the variable. Unable to continue&quot;</FONT></B>);
    }

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> ptrtovar = reinterpret_cast&lt;T *&gt;(in.get() + *offset);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!ptrtovar){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Region of memory indicated failed a reinterpret_cast. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Region of memory indicated failed a reinterpret_cast. Unable to continue&quot;</FONT></B>);
    }

    <I><FONT COLOR="#B22222">//Copy the value to the specified location.
</FONT></I>    *offset += <B><FONT COLOR="#A020F0">sizeof</FONT></B>(T);
    *val = *ptrtovar;
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORSERIALIZE_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, uint8_t *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, uint16_t *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, uint32_t *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, uint64_t *);
    
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, int8_t *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, int16_t *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, int32_t *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, int64_t *);
   
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">char</FONT></B> *);

<I><FONT COLOR="#B22222">//On my 32bit machine, this is unique from the the others.  Need to figure out how to conditionally compile this...
</FONT></I><I><FONT COLOR="#B22222">// Alternatively - do not bother. Serializing std::time_t is going to lead to *many* more issues....
</FONT></I><I><FONT COLOR="#B22222">//    template std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(bool *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::time_t *);
</FONT></I>
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">float</FONT></B> *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">double</FONT></B> *);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
namespace SERIALIZE {
    <B><FONT COLOR="#228B22">template</FONT></B> &lt;&gt; std::unique_ptr&lt;uint8_t[]&gt;
    Get(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, std::string *val){
        <B><FONT COLOR="#A020F0">return</FONT></B> SERIALIZE::Get_String(OK,std::move(in),offset,max,val);
    }
}

namespace SERIALIZE {
    <B><FONT COLOR="#228B22">template</FONT></B> &lt;&gt; std::unique_ptr&lt;uint8_t[]&gt;
    Get(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, std::list&lt;std::string&gt; *val){
        <B><FONT COLOR="#A020F0">return</FONT></B> SERIALIZE::Get_Sequence_Container(OK,std::move(in),offset,max,val);
    }
}


<B><FONT COLOR="#228B22">const</FONT></B> uint64_t SERIALIZE::max_vw_size = (1+2+8); <I><FONT COLOR="#B22222">//Theoretical maximum variable-width size.
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> uint64_t SERIALIZE::max_fw_size = (1+2+8); <I><FONT COLOR="#B22222">//Theoretical maximum fixed-width size.
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> uint64_t SERIALIZE::max_string_head_size = max_vw_size; <I><FONT COLOR="#B22222">//Theoretical maximum.
</FONT></I>

std::unique_ptr&lt;uint8_t[]&gt; 
<B><FONT COLOR="#0000FF">SERIALIZE::Put_Size</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, uint64_t val){
    <I><FONT COLOR="#B22222">//This routine is used by the container serialization routines to write a number denoting
</FONT></I>    <I><FONT COLOR="#B22222">// number of following bytes (ie. ~the number of things in the container).
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//To keep memory footprint down, we use a type-escalation procedure. If `val' exceeds 
</FONT></I>    <I><FONT COLOR="#B22222">// the maximum size of the smallest unsigned, fixed-width type, write the maximum size
</FONT></I>    <I><FONT COLOR="#B22222">// and then iterate for the next type. If the number of items written exceeds 
</FONT></I>    <I><FONT COLOR="#B22222">// std::numeric_limits&lt;uint64_t&gt;::max(), then we refuse to write anything (failure).
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }

    <B><FONT COLOR="#228B22">bool</FONT></B> l_OK;
    
    <I><FONT COLOR="#B22222">//Try writing the size into a single byte.
</FONT></I>    {
      uint8_t shtl;
      <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + <B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint8_t)) &gt; max){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Unable to continue&quot;</FONT></B>);
      }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(val &gt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;uint8_t&gt;::max())){
          shtl = std::numeric_limits&lt;uint8_t&gt;::max();
      }<B><FONT COLOR="#A020F0">else</FONT></B>{
          shtl = static_cast&lt;uint8_t&gt;(val);
      }
      in = SERIALIZE::Put&lt;uint8_t&gt;(&amp;l_OK,std::move(in),offset,max,shtl);
      <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Could not write size value assuming uint8_t. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Could not write size value assuming uint8_t. Unable to continue&quot;</FONT></B>);
      }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(shtl != std::numeric_limits&lt;uint8_t&gt;::max()){ <I><FONT COLOR="#B22222">//Success.
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
          <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
      }
    }

    <I><FONT COLOR="#B22222">//And then with two bytes.
</FONT></I>    {
      uint16_t shtl;
      <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + <B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint16_t)) &gt; max){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Unable to continue&quot;</FONT></B>);
      }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(val &gt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;uint16_t&gt;::max())){
          shtl = std::numeric_limits&lt;uint16_t&gt;::max();
      }<B><FONT COLOR="#A020F0">else</FONT></B>{
          shtl = static_cast&lt;uint16_t&gt;(val);
      }
      in = SERIALIZE::Put&lt;uint16_t&gt;(&amp;l_OK,std::move(in),offset,max,shtl);
      <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Could not write size value assuming uint16_t. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Could not write size value assuming uint16_t. Unable to continue&quot;</FONT></B>);
      }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(shtl != std::numeric_limits&lt;uint16_t&gt;::max()){ <I><FONT COLOR="#B22222">//Success.
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
          <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
      }
    }

    <I><FONT COLOR="#B22222">//And then with 8 bytes, because size is probably not an issue.
</FONT></I>    {
      uint64_t shtl;
      <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + <B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint64_t)) &gt; max){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Unable to continue&quot;</FONT></B>);
      }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(val &gt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;uint64_t&gt;::max())){
          shtl = std::numeric_limits&lt;uint64_t&gt;::max();
      }<B><FONT COLOR="#A020F0">else</FONT></B>{
          shtl = static_cast&lt;uint64_t&gt;(val);
      }
      in = SERIALIZE::Put&lt;uint64_t&gt;(&amp;l_OK,std::move(in),offset,max,shtl);
      <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Could not write size value assuming uint64_t. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Could not write size value assuming uint64_t. Unable to continue&quot;</FONT></B>);
      }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(shtl != std::numeric_limits&lt;uint64_t&gt;::max()){ <I><FONT COLOR="#B22222">//Success.
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
          <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
      }
    }


    <I><FONT COLOR="#B22222">//If we get here, there are more than std::numeric_limits&lt;uint64_t&gt;::max() items...
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Perhaps we could implement a uint128_t, but this is most likely overkill for many reasons.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Unable to determine size. Indicating failure and continuing&quot;</FONT></B>,
                                              <B><FONT COLOR="#BC8F8F">&quot;Unable to determine size. Unable to continue&quot;</FONT></B>);
}

std::unique_ptr&lt;uint8_t[]&gt;
<B><FONT COLOR="#0000FF">SERIALIZE::Put_Fixed_Width_Size</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, uint64_t val){
    <I><FONT COLOR="#B22222">//This routine is used to lay down a fixed-width size, often because it is being used
</FONT></I>    <I><FONT COLOR="#B22222">// in several passes, perhaps when the ultimate width is not yet known but will be 
</FONT></I>    <I><FONT COLOR="#B22222">// adjusted afterward.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//This routine is compatible with the variable-width routine. Get_Size(), can be 
</FONT></I>    <I><FONT COLOR="#B22222">// used to get sizes produced by both Put_Size() and Put_Fixed_Width_Size().
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }

    <B><FONT COLOR="#228B22">bool</FONT></B> l_OK;

    <I><FONT COLOR="#B22222">//To ensure fixed width, and that we will be able to accomodate all sizes of the
</FONT></I>    <I><FONT COLOR="#B22222">// variable-width routine, we will 'fake' that the size is large.
</FONT></I>    uint8_t first = std::numeric_limits&lt;uint8_t&gt;::max();
    in = SERIALIZE::Put&lt;uint8_t&gt;(&amp;l_OK,std::move(in),offset,max,first);

    uint16_t secnd = std::numeric_limits&lt;uint16_t&gt;::max();
    in = SERIALIZE::Put&lt;uint16_t&gt;(&amp;l_OK,std::move(in),offset,max,secnd);


    <I><FONT COLOR="#B22222">//And then with 8 bytes we write the total size.
</FONT></I>    {
      uint64_t shtl;
      <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + <B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint64_t)) &gt; max){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Unable to continue&quot;</FONT></B>);
      }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(val &gt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;uint64_t&gt;::max())){
          shtl = std::numeric_limits&lt;uint64_t&gt;::max();
      }<B><FONT COLOR="#A020F0">else</FONT></B>{
          shtl = static_cast&lt;uint64_t&gt;(val);
      }
      in = SERIALIZE::Put&lt;uint64_t&gt;(&amp;l_OK,std::move(in),offset,max,shtl);
      <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Could not write size value assuming uint64_t. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Could not write size value assuming uint64_t. Unable to continue&quot;</FONT></B>);
      }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(shtl != std::numeric_limits&lt;uint64_t&gt;::max()){ <I><FONT COLOR="#B22222">//Success.
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
          <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
      }
    }

    <I><FONT COLOR="#B22222">//If we get here, there are more than std::numeric_limits&lt;uint64_t&gt;::max() items...
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Perhaps we could implement a uint128_t, but this is most likely overkill for many reasons.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Unable to determine size. Indicating failure and continuing&quot;</FONT></B>,
                                              <B><FONT COLOR="#BC8F8F">&quot;Unable to determine size. Unable to continue&quot;</FONT></B>);
}

std::unique_ptr&lt;uint8_t[]&gt; 
<B><FONT COLOR="#0000FF">SERIALIZE::Get_Size</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, uint64_t *val){
    <I><FONT COLOR="#B22222">//This routine is used by the container serialization routines to retrieve a number denoting
</FONT></I>    <I><FONT COLOR="#B22222">// number of following bytes (ie. ~the number of things in the container).
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//It is necessary to allow the possibility of holding many items - perhaps more than the type
</FONT></I>    <I><FONT COLOR="#B22222">// can handle. (We will refuse to Put in such case, but we cannot refuse to Get - we can only 
</FONT></I>    <I><FONT COLOR="#B22222">// safely fail!)
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//We will generally refuse to Put when there are too many items, but often cannot guarantee 
</FONT></I>    <I><FONT COLOR="#B22222">// the input on a Get. These functions implement a size escalation procedure to bloat the
</FONT></I>    <I><FONT COLOR="#B22222">// size storage type in such a case. This helps reduce the storage size required when many
</FONT></I>    <I><FONT COLOR="#B22222">// items are stored, but keeps costs down when few are stored.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(val == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr instead of a location for storing the variable. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr instead of a location for storing the variable. Unable to continue&quot;</FONT></B>);
    }

    <B><FONT COLOR="#228B22">bool</FONT></B> l_OK;

    <I><FONT COLOR="#B22222">//Try reading the size into a single byte.
</FONT></I>    {
      uint8_t shtl;
      <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + <B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint8_t)) &gt; max){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Unable to continue&quot;</FONT></B>);
      }
      in = SERIALIZE::Get&lt;uint8_t&gt;(&amp;l_OK,std::move(in),offset,max,&amp;shtl);
      <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Could not retrieve size value assuming uint8_t. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Could not retrieve size value assuming uint8_t. Unable to continue&quot;</FONT></B>);
      }
      <B><FONT COLOR="#A020F0">if</FONT></B>(shtl != std::numeric_limits&lt;uint8_t&gt;::max()){ <I><FONT COLOR="#B22222">//Success.
</FONT></I>          <I><FONT COLOR="#B22222">// *offset += sizeof(T); //Get() has already advanced the offset.
</FONT></I>          *val = static_cast&lt;uint64_t&gt;(shtl);
          <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
          <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
      }
    }

    <I><FONT COLOR="#B22222">//Try again with two bytes.
</FONT></I>    {
      uint16_t shtl;
      <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + <B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint16_t)) &gt; max){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Unable to continue&quot;</FONT></B>);
      }
      in = SERIALIZE::Get&lt;uint16_t&gt;(&amp;l_OK,std::move(in),offset,max,&amp;shtl);
      <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Could not retrieve size value assuming uint16_t. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Could not retrieve size value assuming uint16_t. Unable to continue&quot;</FONT></B>);
      }
      <B><FONT COLOR="#A020F0">if</FONT></B>(shtl != std::numeric_limits&lt;uint16_t&gt;::max()){ <I><FONT COLOR="#B22222">//Success.
</FONT></I>          <I><FONT COLOR="#B22222">// *offset += sizeof(T); //Get() has already advanced the offset.
</FONT></I>          *val = static_cast&lt;uint64_t&gt;(shtl);
          <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
          <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
      }
    }

    <I><FONT COLOR="#B22222">//Try again with eight bytes. Storage cost clearly doesn't matter anymore...
</FONT></I>    {
      uint64_t shtl;
      <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + <B><FONT COLOR="#A020F0">sizeof</FONT></B>(uint64_t)) &gt; max){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Size value is beyond the bounds of the memory passed in. Unable to continue&quot;</FONT></B>);
      }
      in = SERIALIZE::Get&lt;uint64_t&gt;(&amp;l_OK,std::move(in),offset,max,&amp;shtl);
      <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
          <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Could not retrieve size value assuming uint64_t. Indicating failure and continuing&quot;</FONT></B>,
                                                    <B><FONT COLOR="#BC8F8F">&quot;Could not retrieve size value assuming uint64_t. Unable to continue&quot;</FONT></B>);
      }
      <B><FONT COLOR="#A020F0">if</FONT></B>(shtl != std::numeric_limits&lt;uint64_t&gt;::max()){ <I><FONT COLOR="#B22222">//Success.
</FONT></I>          <I><FONT COLOR="#B22222">// *offset += sizeof(T); //Get() has already advanced the offset.
</FONT></I>          *val = static_cast&lt;uint64_t&gt;(shtl);
          <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
          <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
      }
    }

    <I><FONT COLOR="#B22222">//If we get here, we are being signalled that an error has somehow occurred (or there are
</FONT></I>    <I><FONT COLOR="#B22222">// indeed more than std::numeric_limits&lt;uint64_t&gt;::max() items...
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Perhaps we could implement a uint128_t, but this is most likely overkill for many reasons.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Unable to determine size. Indicating failure and continuing&quot;</FONT></B>,
                                              <B><FONT COLOR="#BC8F8F">&quot;Unable to determine size. Unable to continue&quot;</FONT></B>);
}

<I><FONT COLOR="#B22222">//For writing buffers ala memcpy. This is a thin wrapper around memcpy
</FONT></I><I><FONT COLOR="#B22222">// that acts more like the other functions.
</FONT></I>std::unique_ptr&lt;uint8_t[]&gt;
<B><FONT COLOR="#0000FF">SERIALIZE::Put_Raw</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, <B><FONT COLOR="#228B22">void</FONT></B> *raw, uint64_t num_bytes){
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when buffer was expected. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when buffer was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(raw == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr raw. No data to copy. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr raw. No data to copy. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + num_bytes) &gt; max){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Not enough memory available for copy. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Not enough memory available for copy. Unable to continue&quot;</FONT></B>);
    }

    memcpy((<B><FONT COLOR="#228B22">void</FONT></B> *)(in.get() + *offset), raw, num_bytes);
    *offset += num_bytes;

    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}

std::unique_ptr&lt;uint8_t[]&gt;
<B><FONT COLOR="#0000FF">SERIALIZE::Get_Raw</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, <B><FONT COLOR="#228B22">void</FONT></B> *raw, uint64_t num_bytes){
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(raw == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr raw. No data to copy. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr raw. No data to copy. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + num_bytes) &gt; max){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Not enough memory available for copy. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Not enough memory available for copy. Unable to continue&quot;</FONT></B>);
    }

    memcpy(raw, (<B><FONT COLOR="#228B22">void</FONT></B> *)(in.get() + *offset), num_bytes);
    *offset += num_bytes;

    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}



<I><FONT COLOR="#B22222">//Used for verifying segments of (raw, buffer) data with a plain string.
</FONT></I>std::unique_ptr&lt;uint8_t[]&gt;
<B><FONT COLOR="#0000FF">SERIALIZE::Matches_At</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;seq){
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(seq.empty()){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed an empty plain string. 'Matching' undefined. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed an empty plain string. 'Matching' undefined. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + seq.size()) &gt; max){
        <I><FONT COLOR="#B22222">//This may not be an error, but we cannot properly advance offset beyond max, so we are forced to fail.
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Not enough data for meaningful comparison. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Not enough data for meaningful comparison. Unable to continue&quot;</FONT></B>);
    }

<B><FONT COLOR="#0000FF">FUNCWARN</FONT></B>(<B><FONT COLOR="#BC8F8F">&quot;*********** This function has not been tested yet. Please verify it ********************&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">const</FONT></B> std::string test(reinterpret_cast&lt;<B><FONT COLOR="#228B22">char</FONT></B> *&gt;(in.get() + *offset), seq.size());

    <I><FONT COLOR="#B22222">//If they do not match, then *OK stays false.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(test != seq) <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);

    <I><FONT COLOR="#B22222">//Otherwise, it is a match. Advance offset and return.
</FONT></I>    *offset += seq.size();
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}



<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
<B><FONT COLOR="#0000FF">SERIALIZE::Get_String</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, std::basic_string&lt;T&gt; *val){
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(val == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr instead of a location for storing the variable. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr instead of a location for storing the variable. Unable to continue&quot;</FONT></B>);
    }

    <B><FONT COLOR="#228B22">bool</FONT></B> l_OK;

    uint64_t str_size; <I><FONT COLOR="#B22222">//In bytes!
</FONT></I>    in = SERIALIZE::Get_Size(&amp;l_OK, std::move(in), offset, max, &amp;str_size);
    <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Could not get string size. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Could not get string size. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + str_size) &gt; max){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;String size indicates more elements than we have available. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;String size indicates more elements than we have available. Unable to continue&quot;</FONT></B>);
    }

    <I><FONT COLOR="#B22222">//Copy the data using the string assign() member. (Note: It takes 
</FONT></I>    <I><FONT COLOR="#B22222">// the COUNT of T, not the size in bytes of T.)
</FONT></I>    val-&gt;assign(reinterpret_cast&lt;T *&gt;(in.get() + *offset), str_size/<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T));
    *offset += str_size;
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORSERIALIZE_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;uint8_t&gt; *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;uint16_t&gt; *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;uint32_t&gt; *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;uint64_t&gt; *);

    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;int8_t&gt; *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;int16_t&gt; *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;int32_t&gt; *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;int64_t&gt; *);

    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;<B><FONT COLOR="#228B22">char</FONT></B>&gt; *);
<I><FONT COLOR="#B22222">//    template std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(bool *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;unsigned char&gt; *);
</FONT></I>
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt; *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; *);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
<B><FONT COLOR="#0000FF">SERIALIZE::Put_String</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, std::basic_string&lt;T&gt; val){
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }

    <B><FONT COLOR="#228B22">bool</FONT></B> l_OK;
    uint64_t str_size = val.size()*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(T); <I><FONT COLOR="#B22222">//In bytes!
</FONT></I>    in = SERIALIZE::Put_Size(&amp;l_OK, std::move(in), offset, max, str_size);
    <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Could not put string size. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Could not put string size. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + str_size) &gt; max){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;String size indicates more elements than we have space for. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;String size indicates more elements than we have space for. Unable to continue&quot;</FONT></B>);
    }

    <I><FONT COLOR="#B22222">//Copy the data. (Ditch the '\0' because we carry around a proper size.)
</FONT></I>    in = SERIALIZE::Put_Raw(&amp;l_OK, std::move(in), offset, max, (<B><FONT COLOR="#228B22">void</FONT></B> *)(val.data()), str_size);
<I><FONT COLOR="#B22222">//    memcpy((void *)(in.get() + *offset), (void *)(val.data()), str_size);
</FONT></I><I><FONT COLOR="#B22222">//    *offset += str_size;
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORSERIALIZE_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;uint8_t&gt;);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;uint16_t&gt;);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;uint32_t&gt;);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;uint64_t&gt;);

    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;int8_t&gt;);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;int16_t&gt;);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;int32_t&gt;);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;int64_t&gt;);

    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;<B><FONT COLOR="#228B22">char</FONT></B>&gt;);
<I><FONT COLOR="#B22222">//    template std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(bool *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;unsigned char&gt;);
</FONT></I>
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_String(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::basic_string&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
<B><FONT COLOR="#0000FF">SERIALIZE::Get_Sequence_Container</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, T *val){
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(val == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr instead of a location for storing the variable. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr instead of a location for storing the variable. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(!val-&gt;empty()){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Passed a non-empty container. Assuming this is intentional. Appending data&quot;</FONT></B>);
    }

    <B><FONT COLOR="#228B22">bool</FONT></B> l_OK;
    uint64_t str_size; <I><FONT COLOR="#B22222">//In bytes!
</FONT></I>    in = SERIALIZE::Get_Size(&amp;l_OK, std::move(in), offset, max, &amp;str_size);
    <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Could not get string size. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Could not get string size. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + str_size) &gt; max){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;String size indicates more elements than we have available. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;String size indicates more elements than we have available. Unable to continue&quot;</FONT></B>);
    }

    typename T::value_type shtl;
    <B><FONT COLOR="#A020F0">for</FONT></B>(uint64_t i = 0; i &lt; str_size; i+=<B><FONT COLOR="#A020F0">sizeof</FONT></B>(shtl)){
        in = SERIALIZE::Get&lt;typename T::value_type&gt;(&amp;l_OK, std::move(in), offset, max, &amp;shtl);
        <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
            <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in),<B><FONT COLOR="#BC8F8F">&quot;Could not get intrinsic for container. Indicating failure and continuing&quot;</FONT></B>,
                                                     <B><FONT COLOR="#BC8F8F">&quot;Could not get intrinsic for container. Unable to continue&quot;</FONT></B>);
        }
        val-&gt;push_back(shtl);
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORSERIALIZE_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <I><FONT COLOR="#B22222">//Fill this in with anything which is needed.
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::list&lt;uint8_t&gt; *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::list&lt;std::string&gt; *);

    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::vector&lt;uint8_t&gt; *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; *);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Get_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, std::vector&lt;std::string&gt; *);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; std::unique_ptr&lt;uint8_t[]&gt; 
<B><FONT COLOR="#0000FF">SERIALIZE::Put_Sequence_Container</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t max, <B><FONT COLOR="#228B22">const</FONT></B> T &amp;val){
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr when data was expected. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(offset == nullptr){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Passed nullptr offset. No way to advance offset. Unable to continue&quot;</FONT></B>);
    }

    <B><FONT COLOR="#228B22">bool</FONT></B> l_OK;
    uint64_t str_size = val.size()*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(typename T::value_type); <I><FONT COLOR="#B22222">//In bytes!
</FONT></I>    in = SERIALIZE::Put_Size(&amp;l_OK, std::move(in), offset, max, str_size);
    <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Could not put container size. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Could not put container size. Unable to continue&quot;</FONT></B>);
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((*offset + str_size) &gt; max){
        <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in), <B><FONT COLOR="#BC8F8F">&quot;Container size indicates more elements than we have space for. Indicating failure and continuing&quot;</FONT></B>,
                                                  <B><FONT COLOR="#BC8F8F">&quot;Container size indicates more elements than we have space for. Unable to continue&quot;</FONT></B>);
    }

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = val.begin(); it != val.end(); ++it){
        in = SERIALIZE::Put&lt;typename T::value_type&gt;(&amp;l_OK, std::move(in), offset, max, *it);
        <B><FONT COLOR="#A020F0">if</FONT></B>(l_OK == false){
            <B><FONT COLOR="#A020F0">return</FONT></B> FailWarn_or_Die(OK, std::move(in),<B><FONT COLOR="#BC8F8F">&quot;Could not put intrinsic within container. Indicating failure and continuing&quot;</FONT></B>,
                                                     <B><FONT COLOR="#BC8F8F">&quot;Could not put intrinsic within container. Unable to continue&quot;</FONT></B>);
        }
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORSERIALIZE_INCLUDE_ALL_SPECIALIZATIONS</FONT>
    <I><FONT COLOR="#B22222">//Fill this in with anything which is needed.
</FONT></I>    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;uint8_t&gt; &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::string&gt; &amp;);
    
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;uint8_t&gt; &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> std::unique_ptr&lt;uint8_t[]&gt; SERIALIZE::Put_Sequence_Container(<B><FONT COLOR="#228B22">bool</FONT></B> *, std::unique_ptr&lt;uint8_t[]&gt;, uint64_t *, uint64_t, <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::string&gt; &amp;);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

</PRE>
<HR>
<A NAME="file37">
<H1>YgorStats.cc 37/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file36">prev</A>][<A HREF="#file38">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorStats.cc.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>       //Needed for fabs, signbit, sqrt, etc...
<I><FONT COLOR="#B22222">//#include &lt;iostream&gt;
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;sstream&gt;
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;fstream&gt;
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;algorithm&gt;   //Needed for std::reverse.
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;map&gt;
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;unordered_map&gt;
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
<I><FONT COLOR="#B22222">//#include &lt;iterator&gt;
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;functional&gt;  //Needed for passing kernel functions to integration schemes.
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;string&gt;      //Needed for stringification routines.
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;tuple&gt;       //Needed for Spearman's Rank Correlation Coeff, other statistical routines.
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;limits&gt;      //Needed for std::numeric_limits::max().
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;vector&gt;
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;gsl/gsl_math.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;gsl/gsl_sf_gamma.h&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMath.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorStats.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>    //For the FUNC* and PERCENT_ERR macro functions.



<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Stats::P_From_StudT_1Tail</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> tval, <B><FONT COLOR="#228B22">double</FONT></B> dof){
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> y = std::sqrt(tval*tval + dof);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> x = 0.5*(y - tval)/y;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> a = dof/2.0;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> b = dof/2.0;

    <I><FONT COLOR="#B22222">//Regularized beta ratio function (I_x(a,b) = B_x(a,b)/B(a,b)).
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> reg_beta_incom = gsl_sf_beta_inc(a,b,x); 
    <B><FONT COLOR="#A020F0">return</FONT></B> reg_beta_incom;
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Stats::P_From_StudT_2Tail</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> tval, <B><FONT COLOR="#228B22">double</FONT></B> dof){
    <B><FONT COLOR="#A020F0">if</FONT></B>(tval &gt;= 0.0) <B><FONT COLOR="#A020F0">return</FONT></B> 2.0*Stats::P_From_StudT_1Tail(tval,dof);
    <B><FONT COLOR="#A020F0">return</FONT></B> 2.0*Stats::P_From_StudT_1Tail(-tval,dof);
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Stats::P_From_StudT_Diff_Means_From_Uneq_Vars</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> M1, <B><FONT COLOR="#228B22">double</FONT></B> S1, <B><FONT COLOR="#228B22">double</FONT></B> N1, <B><FONT COLOR="#228B22">double</FONT></B> M2, <B><FONT COLOR="#228B22">double</FONT></B> S2, <B><FONT COLOR="#228B22">double</FONT></B> N2){
    <I><FONT COLOR="#B22222">//Given two means (M1 and M2) with associated (possibly non-equal) variances, compute the significance
</FONT></I>    <I><FONT COLOR="#B22222">// that the means are different. In other words, given the means, what is the probability that they 
</FONT></I>    <I><FONT COLOR="#B22222">// are drawn from the same population? Are the means significantly different?
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Input:
</FONT></I>    <I><FONT COLOR="#B22222">//  - M1 and M2 - the means of either distribution. I don't believe this routine is applicable to 
</FONT></I>    <I><FONT COLOR="#B22222">//      other quantities. See numerical recipes for a nice discussion.
</FONT></I>    <I><FONT COLOR="#B22222">//  - S1 and S2 - the sigma (ie. one std.dev. or `variance') of either distribution.
</FONT></I>    <I><FONT COLOR="#B22222">//  - N1 and N2 - the number of points in either distribution. *NOT* the DOF!
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//This routine is often used to determine if some quantity has changed significantly. Examples could be
</FONT></I>    <I><FONT COLOR="#B22222">// a quantity changing at two points in time, or comparison of non-linear fitting parameters obtained
</FONT></I>    <I><FONT COLOR="#B22222">// with two different techniques (ie. least-sum of squares vs. least-median of squares).
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Logically, it is similar to the area of overlap of the two distributions. Obviously, if the 
</FONT></I>    <I><FONT COLOR="#B22222">// distributions have wildly different means or variances, this routine may not appropriate. 
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: This tests significance in the difference of means. Do not conflate significance of means
</FONT></I>    <I><FONT COLOR="#B22222">//      with significance in difference of the distributions themselves! 
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>((N1 &lt; 2.0) || (N2 &lt; 2.0)) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Not enough points available for computation&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> t_num = M1 - M2;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> t_den = std::sqrt((S1/N1)+(S2/N2));
    <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isnormal(t_den)) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Encountered difficulty computing Student's t-value. Cannot continue&quot;</FONT></B>);
 
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> dof_num = std::pow((S1/N1)+(S2/N2),2.0);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> dof_den = ((S1*S1)/(N1*N1*(N1-1.0))) + ((S2*S2)/(N2*N2*(N2-1.0)));
    <B><FONT COLOR="#A020F0">if</FONT></B>(!std::isnormal(dof_den)) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Encountered difficulty computing dof. Cannot continue&quot;</FONT></B>);

    <B><FONT COLOR="#A020F0">return</FONT></B> Stats::P_From_StudT_2Tail(t_num/t_den, dof_num/dof_den);
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Stats::Q_From_ChiSq_Fit</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> chi_square, <B><FONT COLOR="#228B22">double</FONT></B> dof){
    <I><FONT COLOR="#B22222">//See Numerical Recipes, C, Section 6.2 (pp 221) or section on nonlinear fitting.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: This function should use the chi-square which includes uncertainties.
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: This function should not use the reduced chi-square!
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">// A ~decent fit has Q &gt; 0.001 (although a little low).
</FONT></I>    <I><FONT COLOR="#B22222">// If Q is too near 1.0, the errors are probably overestimated.
</FONT></I>    <I><FONT COLOR="#B22222">// If Q is a little lower then 0.001, errors are probably underestimated.
</FONT></I>    <I><FONT COLOR="#B22222">// If Q is very low (&lt;1E-6) the model is a terrible fit.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> gsl_sf_gamma_inc_Q(dof/2.0, chi_square/2.0);
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">Stats::Unbiased_Var_Est</FONT></B>(std::list&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; in){
    <I><FONT COLOR="#B22222">//This is an unbiased estimate of a population's variance, as computed from a
</FONT></I>    <I><FONT COLOR="#B22222">// finite sample size. If you have the *entire* population (ie. every entity)
</FONT></I>    <I><FONT COLOR="#B22222">// then this will produce a slightly incorrect value. See 
</FONT></I>    <I><FONT COLOR="#B22222">// http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance for more
</FONT></I>    <I><FONT COLOR="#B22222">// info.
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//This computes the variance (sigma^2). Take a sqrt to get sigma (the std err).
</FONT></I>    <I><FONT COLOR="#B22222">// (The std err should be used for, eg, error bars on plots [but 2*sigma will 
</FONT></I>    <I><FONT COLOR="#B22222">//  give 95% confidence interval error bars].)
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(in.empty()) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Cannot compute variance of empty set. Unable to continue&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(in.size() == 1) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Cannot estimate variance from single point. Unable to continue&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(in.size() &lt;= 5) FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Very few points were used to estimate variance. Be weary of result&quot;</FONT></B>);

    in.sort(); <I><FONT COLOR="#B22222">//Sort it now and avoid having to do so again (twice) from scratch.
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> n = static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(in.size());
    <B><FONT COLOR="#A020F0">return</FONT></B> (Ygor_Sum_Squares(in) - pow(Ygor_Sum(in),2.0)/n)/(n-1);
}


</PRE>
<HR>
<A NAME="file38">
<H1>YgorString.cc 38/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file37">prev</A>][<A HREF="#file39">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorString.cc.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">YGORSTRING_CC_COMMON_TEMPLATE_INSTANTIATIONS</FONT>
    #define YGORSTRING_CC_COMMON_TEMPLATE_INSTANTIATIONS
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;map&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;utility&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;memory&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;set&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iomanip&gt;</FONT></B>    //Needed for std::setprecision(...)
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>  //Needed for set_intersection(..), reverse().
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;random&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iterator&gt;</FONT></B>

<I><FONT COLOR="#B22222">//For Canonicalization function.
</FONT></I><I><FONT COLOR="#B22222">//#include &lt;locale&gt;                     //Needed for std::toupper()
</FONT></I><I><FONT COLOR="#B22222">//const std::locale loc;              // The current locale. Needed for locale-dependent string transformations.
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;boost/algorithm/string.hpp&gt;</FONT></B> //A faster way to get a toupper() function (boost::to_upper).


<I><FONT COLOR="#B22222">//#include &lt;regex&gt;                    //Fuck you, silent compiler failing.
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;boost/regex.hpp&gt;</FONT></B>

                      <I><FONT COLOR="#B22222">//--------------------------------------------
</FONT></I>                      <I><FONT COLOR="#B22222">//--------------      NOTE       -------------
</FONT></I>                      <I><FONT COLOR="#B22222">//--------------------------------------------
</FONT></I>                      <I><FONT COLOR="#B22222">//  Ensure this file is compiled with the    -
</FONT></I>                      <I><FONT COLOR="#B22222">//  -lregex flag!                            -
</FONT></I>                      <I><FONT COLOR="#B22222">//--------------------------------------------
</FONT></I>                      <I><FONT COLOR="#B22222">//--------------------------------------------
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B> //Includes namespace constants, function decl.'s, etc..
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>   //Needed for error functions (for debugging) and isininc macro.




<I><FONT COLOR="#B22222">//From: http://daringfireball.net/2010/07/improved_regex_for_matching_urls .
</FONT></I><I><FONT COLOR="#B22222">// (?i)\b((?:[a-z][\w-]+:(?:/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}/)(?:[^\s()&lt;&gt;]+|\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\))+(?:\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\)|[^\s`!()\[\]{};:'&quot;.,&lt;&gt;??????~@~\?~@~]?~@~X?~@~Y]))
</FONT></I><I><FONT COLOR="#B22222">// but note that some characters (inconveniently) need to be escaped in the source.
</FONT></I><I><FONT COLOR="#B22222">//const boost::regex regex_all_urls( &quot;\(\?i)\\b\(\(\?:\[a-z]\[\\w-]+:\(\?:/{1,3}|\[a-z0-9%])|www\\d{0,3}\[.]|\[a-z0-9.-]+\[.]\[a-z]{2,4}/)\(\?:\[^\\s\()&lt;&gt;]+|\\\(\(\[^\\s\()&lt;&gt;]+|\(\\\(\[^\\s\()&lt;&gt;]+\\)))*\\))+\(\?:\\\(\(\[^\\s\()&lt;&gt;]+|\(\\\(\[^\\s\()&lt;&gt;]+\\)))*\\)|\[^\\s`!\()\\\[\\]{};:'\\\&quot;.,&lt;&gt;\??????~@~\?~@~]?~@~X?~@~Y]))&quot; , boost::regex::icase );
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> boost::regex regex_all_urls( R<B><FONT COLOR="#BC8F8F">&quot;***((?i)\b((?:[a-z][\w-]+:(?:/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}/)(?:[^\s()&lt;&gt;]+|\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\))+(?:\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\)|[^\s`!()\[\]{};:'&quot;</FONT></B>.,&lt;&gt;??????~@~\?~@~]?~@~X?~@~Y])))***<B><FONT COLOR="#BC8F8F">&quot;, boost::regex::icase );


//(?i)\b((?:https?://|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}/)(?:[^\s()&lt;&gt;]+|\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\))+(?:\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\)|[^\s`!()\[\]{};:'&quot;</FONT></B>.,&lt;&gt;??????~@~\?~@~]?~@~X?~@~Y]))
<I><FONT COLOR="#B22222">//const boost::regex regex_all_http_urls( &quot;\(\?i)\\b\(\(\?:https\?://|www\\d{0,3}\[.]|\[a-z0-9.\\-]+\[.]\[a-z]{2,4}/)\(\?:\[^\\s\()&lt;&gt;]+|\\\(\(\[^\\s\()&lt;&gt;]+|\(\\\(\[^\\s\()&lt;&gt;]+\\)))*\\))+\(\?:\\\(\(\[^\\s\()&lt;&gt;]+|\(\\\(\[^\\s\()&lt;&gt;]+\\)))*\\)|\[^\\s`!\()\\\[\\]{};:'\\\&quot;.,&lt;&gt;\??????~@~\?~@~]?~@~X?~@~Y]))&quot; , boost::regex::icase );
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> boost::regex regex_all_http_urls( R<B><FONT COLOR="#BC8F8F">&quot;***((?i)\b((?:https?://|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}/)(?:[^\s()&lt;&gt;]+|\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\))+(?:\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\)|[^\s`!()\[\]{};:'&quot;</FONT></B>.,&lt;&gt;??????~@~\?~@~]?~@~X?~@~Y])))***<B><FONT COLOR="#BC8F8F">&quot;, boost::regex::icase );

const boost::regex regex_a_number( &quot;</FONT></B>[0-9.-eE]*<B><FONT COLOR="#BC8F8F">&quot;, boost::regex::icase );



#ifndef YGOR_STRING_TURN_OFF_USER_LITERALS
//-------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------ Handy User-Literals ----------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------
//Handy (char *) to (std::string) user-literal. Use like: 
//     std::string test = &quot;</FONT></B>Ygor string<B><FONT COLOR="#BC8F8F">&quot;_s + &quot;</FONT></B>Other string<B><FONT COLOR="#BC8F8F">&quot;_s;
//     test += &quot;</FONT></B>foo<B><FONT COLOR="#BC8F8F">&quot;_s + &quot;</FONT></B>ba\0r<B><FONT COLOR="#BC8F8F">&quot;_s + std::string(&quot;</FONT></B>baz<B><FONT COLOR="#BC8F8F">&quot;);  //Will give 'fooba\0rbaz'
std::string operator &quot;</FONT></B><B><FONT COLOR="#BC8F8F">&quot; _s(const char* str, size_t len){
    return std::string(str,len);
}
#endif

//-------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------- String Type Conversions --------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------
//This function will take the string buffer, copy it to a buffer of type T, and pass out ownership of the new buffer.
// The type T need not match the type of std::string's underlying char_t. The onus is on the user to interpret it.
//
//NOTE: The 'size' parameter is filled with the size of data in the array. The units are in T's. In other words,
// the number of *bytes* of data is size*sizeof(T).
template &lt;class T&gt; std::unique_ptr&lt;T[]&gt; str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size){
    std::unique_ptr&lt;T[]&gt; out;
    if(OK != nullptr) *OK = false;
    if(size == nullptr){
        FUNCWARN(&quot;</FONT></B>Passed a nullptr instead of a space to store buffer size. Bailing<B><FONT COLOR="#BC8F8F">&quot;);
        if(OK == nullptr) FUNCERR(&quot;</FONT></B>Cannot signal error through OK ptr. Cannot <B><FONT COLOR="#A020F0">continue</FONT></B><B><FONT COLOR="#BC8F8F">&quot;);
        return std::move(out);
    }
    *size = 0U;
    const auto l_size = in.size(); //Size of string in bytes.

    //Check if the data (appears) to be able to be represented by an array of T's. I don't think this
    // will ever be a problem, because std::string's underlying char type is always a single byte.
    // Leaving this here in case the code is adapted to something else... 
    const auto quotient = l_size/sizeof(T);
    if(static_cast&lt;long long int&gt;(quotient*sizeof(T)) != static_cast&lt;long long int&gt;(l_size) ){
        //NOTE: This is probably not a real problem. In principle, we should just allocate a little more room
        // and let the user handle the divisibility issue themselves. However, in the use cases intended for
        // this code, it is probably better to make it harder for the user to make a mistake. If this 
        // functionality is actually needed, consider either a companion function, a settable parameter, or,
        // in a pinch, try adding a few more elements until the numbers work out.
        FUNCWARN(&quot;</FONT></B>Data cannot be represented as the specified type. File is of size <B><FONT COLOR="#BC8F8F">&quot; &lt;&lt; l_size &lt;&lt; &quot;</FONT></B>b and <B><FONT COLOR="#228B22">template</FONT></B> has size <B><FONT COLOR="#BC8F8F">&quot; &lt;&lt; sizeof(T) &lt;&lt; &quot;</FONT></B>b<B><FONT COLOR="#BC8F8F">&quot;);
        if(OK == nullptr) FUNCERR(&quot;</FONT></B>Cannot signal error through OK ptr. Cannot <B><FONT COLOR="#A020F0">continue</FONT></B><B><FONT COLOR="#BC8F8F">&quot;);
        return std::move(out);
    }

    out.reset( new T [l_size/sizeof(T)] );      //Allocate space for the entire block to be pulled into memory.
    memcpy((void *)(out.get()), (void *)(in.data()), l_size);
    *size = static_cast&lt;uint64_t&gt;(l_size/sizeof(T));
    if(OK != nullptr) *OK = true;
    return std::move(out);
}
#ifdef YGORSTRING_CC_COMMON_TEMPLATE_INSTANTIATIONS
template std::unique_ptr&lt;uint8_t[]&gt;  str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size);
template std::unique_ptr&lt;uint16_t[]&gt; str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size);
template std::unique_ptr&lt;uint32_t[]&gt; str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size);
template std::unique_ptr&lt;uint64_t[]&gt; str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size);
template std::unique_ptr&lt;int8_t[]&gt;   str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size);
template std::unique_ptr&lt;int16_t[]&gt;  str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size);
template std::unique_ptr&lt;int32_t[]&gt;  str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size);
template std::unique_ptr&lt;int64_t[]&gt;  str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size);
template std::unique_ptr&lt;char[]&gt;     str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size);
template std::unique_ptr&lt;float[]&gt;    str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size);
template std::unique_ptr&lt;double[]&gt;   str_to_buf(bool *OK, const std::string &amp;in, uint64_t *size);
#endif

//-------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------ Self-contained N-gram routines -----------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------
//Note: By &quot;</FONT></B>N-gram<B><FONT COLOR="#BC8F8F">&quot;, here we mean that a string like &quot;</FONT></B>some string<B><FONT COLOR="#BC8F8F">&quot; would be split into the following N-grams:
//                     &quot;</FONT></B>some string<B><FONT COLOR="#BC8F8F">&quot;   ---&gt;   {som, ome, str, tri, rin, ing}
// note that these N-grams do NOT cross whitespace. Other than splitting words, whitespace is ignored.
// To have N-grams which WOULD cross whitespace (but still ignore it,) one will need to move the internal
// while loop outside of the outer loop for these routines (but it shouldn't be too difficult to adjust!) 
//
std::map&lt;std::string,float&gt; NGrams_With_Occurence(const std::string &amp;thestring, long int numb_of_ngrams, long int length_of_ngrams, const unsigned char &amp;type){
    //Pass in numb_of_ngrams = -1 to generate ALL ngrams.
    //Note that the computation is truncated when numb_of_ngrams has been reached - there is *no* selectivity in the output upon truncation.
    std::map&lt;std::string,float&gt; output;
    long int ngrams_generated = 0;
    std::stringstream inss(thestring);
    std::string theword;
    while( inss.good() ){
        inss &gt;&gt; theword;

        if( (type &amp; NGRAMS::CHARS) == NGRAMS::CHARS){   //Character N-grams. These are of a (user) specified length.
            while( static_cast&lt;long int&gt;(theword.size()) &gt;= length_of_ngrams ){
                if( (ngrams_generated &gt;= numb_of_ngrams) &amp;&amp; (numb_of_ngrams != -1) ) return output;

                //Push back the current Ngram. Remove the first character for the next cycle. 
                ++ngrams_generated;
                output[theword.substr(0,length_of_ngrams)] += 1.0f;
                theword.erase( theword.begin() );
            }

        }else if((type &amp; NGRAMS::WORDS) == NGRAMS::WORDS){ //Word N-grams. These are NOT of a (user) specified length.
            if(ngrams_generated &lt;= numb_of_ngrams){
                if(theword.size() &gt; 0){
                    output[theword] += 1.0f;
                    ++ngrams_generated;
                }
            }else{
                return output;
            }
        }
    }
    return output;
}

//TODO:  fix the numb_of_ngrams ignoring in the NGRAMS::WORDS case. (and for the above function.)

std::set&lt;std::string&gt; NGrams(const std::string &amp;thestring, long int numb_of_ngrams, long int length_of_ngrams, const unsigned char &amp;type){
    //Pass in numb_of_ngrams = -1 to generate ALL ngrams.
    //Note that the computation is truncated when numb_of_ngrams has been reached - there is *no* selectivity in the output upon truncation.
    std::set&lt;std::string&gt; output;
    long int ngrams_generated = 0;
    std::stringstream inss(thestring);
    std::string theword;
    while( inss.good() ){
        inss &gt;&gt; theword;
        if( (type &amp; NGRAMS::CHARS) == NGRAMS::CHARS){   //Character N-grams. These are of a (user) specified length.
            while( static_cast&lt;long int&gt;(theword.size()) &gt;= length_of_ngrams ){
                if( (ngrams_generated &gt;= numb_of_ngrams) &amp;&amp; (numb_of_ngrams != -1) ) return output;

                //Push back the current Ngram. Remove the first character for the next cycle. 
                ++ngrams_generated;
                output.insert( theword.substr(0,length_of_ngrams) );
                theword.erase( theword.begin() );
            }

        }else if((type &amp; NGRAMS::WORDS) == NGRAMS::WORDS){ //Word N-grams. These are NOT of a (user) specified length.
            if(ngrams_generated &lt;= numb_of_ngrams){
                if(theword.size() &gt; 0){
                    output.insert(theword);
                    ++ngrams_generated;
                }
            }else{
                return output;
            }
        }
    }
    return output;
}

std::set&lt;std::string&gt; NGram_Matches(const std::set&lt;std::string&gt; &amp;A, const std::set&lt;std::string&gt; &amp;B){
    std::set&lt;std::string&gt; output;
    std::set_intersection(A.cbegin(), A.cend(), B.cbegin(), B.cend(), std::inserter(output,output.begin()));  
    return output;
}

long int NGram_Match_Count(const std::set&lt;std::string&gt; &amp;A, const std::set&lt;std::string&gt; &amp;B){
    return static_cast&lt;long int&gt;( (NGram_Matches(A,B)).size() );
}

//-------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------- Substring and Subsequence routines ----------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------
//Returns the longest common sequential substring. ie. 'ABCDEF' and 'ACDEF' gives 'CDEF'.
std::string LongestCommonSubstring(const std::string &amp;A, const std::string &amp;B){
    if(A.empty() || B.empty()) return &quot;</FONT></B><B><FONT COLOR="#BC8F8F">&quot;;
    if(B.size() &gt; A.size()) return LongestCommonSubstring(B,A); //Less memory usage.

    std::vector&lt;std::string&gt; curr(B.size(),&quot;</FONT></B><B><FONT COLOR="#BC8F8F">&quot;), prev(B.size(),&quot;</FONT></B><B><FONT COLOR="#BC8F8F">&quot;), forswap;
    std::string out;
    for(size_t i = 0; i &lt; A.size(); ++i){
        for(size_t j = 0; j &lt; B.size(); ++j){
            if(A[i] != B[j]){
                if(out.size() &lt; curr[j].size()) out = curr[j];
                curr[j].clear();
            }else{
                if(i == 0 || j == 0){
                    curr[j].clear();
                }else{
                    curr[j] = prev[j-1];
                }
                curr[j] += A[i];
            }
        }
        forswap = std::move(curr);
        curr = std::move(prev);
        prev = std::move(forswap);
    }

    for(size_t i = 0; i &lt; curr.size(); ++i){
        if(out.size() &lt; curr[i].size()) out = curr[i];
        if(out.size() &lt; prev[i].size()) out = prev[i];
    }
    return out;
}

//Returns the longest common subsequence. ie. 'ABCDEF' and 'ACDEF' gives 'ACDEF'.
std::string LongestCommonSubsequence(const std::string &amp;A, const std::string &amp;B){

    FUNCERR(&quot;</FONT></B>HAVE NOT YET IMPLEMENTED THIS ROUTINE!<B><FONT COLOR="#BC8F8F">&quot;);

    return &quot;</FONT></B><B><FONT COLOR="#BC8F8F">&quot;;
}



//-------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------- Common text transformations ------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------
//This function transforms a given string into the 'canonical' format. This *should* involve handling
// spurious whitespace and transforming to a specific encoding. Future work can fine-tune this, though.
// All strings 'from the wild' are passed through this filter.
std::string &amp; Canonicalize_String(std::string &amp;in, const unsigned char &amp;opts){
    //This function can be used as a filter OR as a pass-in-and-act-on-it function.

    //Transform to all upper case.
    if( (opts &amp; CANONICALIZE::TO_UPPER) == CANONICALIZE::TO_UPPER ){
        //for (size_t i=0; i&lt;in.length(); ++i) in[i] = toupper(in[i],loc);  // using the C++ &lt;locale&gt; way.
        boost::to_upper(in);  // Using the Boost way.
    }

    //Localization, transformation to particular encoding.
    if( (opts &amp; CANONICALIZE::LOCALIZE) == CANONICALIZE::LOCALIZE ){
        // ...
    }


    //Whitespace filter. Works for beginning, end, and interim whitespaces.
    if( (opts &amp; CANONICALIZE::TRIM) == CANONICALIZE::TRIM ){
        //stringstream &gt;&gt; will spit out an empty string if there is trailing space. This routine *requires* such space!
        std::stringstream ss(in+&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;);
        if(!ss.good()) return in;
        in.clear();
        std::string temp;
        ss &gt;&gt; temp;
        do{
            if(!temp.empty()) in += temp;
            ss &gt;&gt; temp;
            if(!temp.empty() &amp;&amp; ss.good()) in += &quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;;
        }while(ss.good());
    }

    //Whitespace filter. Works for beginning, end, and interim whitespaces.
    if( (opts &amp; CANONICALIZE::TRIM_ENDS) == CANONICALIZE::TRIM_ENDS ){
        const std::string whitespace(&quot;</FONT></B> \t<B><FONT COLOR="#BC8F8F">&quot;); //\f\v\n\r&quot;</FONT></B>); <I><FONT COLOR="#B22222">//Consider vertical tabs and newlines too? Don't assume so...
</FONT></I>
        <I><FONT COLOR="#B22222">//Trailing.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> last_non = in.find_last_not_of(whitespace);
        <B><FONT COLOR="#A020F0">if</FONT></B>(last_non != std::string::npos){
            in.erase(last_non+1);
        }<B><FONT COLOR="#A020F0">else</FONT></B>{ <I><FONT COLOR="#B22222">//All whitespace!
</FONT></I>            in.clear();
        }

        <I><FONT COLOR="#B22222">//Preceeding.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> first_non = in.find_first_not_of(whitespace);
        <B><FONT COLOR="#A020F0">if</FONT></B>(first_non != std::string::npos){
            in.erase(0,first_non);
        }<B><FONT COLOR="#A020F0">else</FONT></B>{ <I><FONT COLOR="#B22222">//All whitespace!
</FONT></I>            in.clear();
        }
    }

    <I><FONT COLOR="#B22222">//Remove ALL whitespace, leaving a single, long, whitespace-less string (in the order they originally were in.)
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( (opts &amp; CANONICALIZE::TRIM_ALL) == CANONICALIZE::TRIM_ALL ){
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream inss(in + <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>);
        in.clear();
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string theword;
        <B><FONT COLOR="#A020F0">while</FONT></B>(inss.good()){
            inss &gt;&gt; theword;
            <B><FONT COLOR="#A020F0">if</FONT></B>(!theword.empty() &amp;&amp; inss.good()) in += theword;
        }
    }

    <I><FONT COLOR="#B22222">//Remove all non-[ A-Za-z] characters.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( (opts &amp; CANONICALIZE::TO_AZ) == CANONICALIZE::TO_AZ ){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.begin(); it != in.end(); ++it) <B><FONT COLOR="#A020F0">if</FONT></B>( (*it) != <B><FONT COLOR="#BC8F8F">' '</FONT></B>){
            <B><FONT COLOR="#A020F0">if</FONT></B>( !(isininc(<B><FONT COLOR="#BC8F8F">'A'</FONT></B>,*it,<B><FONT COLOR="#BC8F8F">'Z'</FONT></B>) || isininc(<B><FONT COLOR="#BC8F8F">'a'</FONT></B>,*it,<B><FONT COLOR="#BC8F8F">'z'</FONT></B>)) ){ <I><FONT COLOR="#B22222">// !( ((*it) &gt;= 'A') &amp;&amp; ((*it) &lt;= 'Z') )  &amp;&amp; !( ((*it) &gt;= 'a') &amp;&amp; ((*it) &lt;= 'z') ) ){
</FONT></I>                in.erase(it);
                --it;
            }
        }
    }

    <I><FONT COLOR="#B22222">//Remove all non-[ 0-9-.] characters.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( (opts &amp; CANONICALIZE::TO_NUM) == CANONICALIZE::TO_NUM ){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.begin(); it != in.end(); ++it) <B><FONT COLOR="#A020F0">if</FONT></B>( (*it) != <B><FONT COLOR="#BC8F8F">' '</FONT></B>){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!( isininc(<B><FONT COLOR="#BC8F8F">'1'</FONT></B>,*it,<B><FONT COLOR="#BC8F8F">'9'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'0'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'.'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'-'</FONT></B>)  )){
                in.erase(it);
                --it;
            }
        }
    }

    <I><FONT COLOR="#B22222">//Remove all non-[ A-Za-z0-9-.]
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( (opts &amp; CANONICALIZE::TO_NUMAZ) == CANONICALIZE::TO_NUMAZ ){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.begin(); it != in.end(); ++it) <B><FONT COLOR="#A020F0">if</FONT></B>( (*it) != <B><FONT COLOR="#BC8F8F">' '</FONT></B>){
            <B><FONT COLOR="#A020F0">if</FONT></B>(!( isininc(<B><FONT COLOR="#BC8F8F">'1'</FONT></B>,*it,<B><FONT COLOR="#BC8F8F">'9'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'0'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'.'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'-'</FONT></B>) || isininc(<B><FONT COLOR="#BC8F8F">'A'</FONT></B>,*it,<B><FONT COLOR="#BC8F8F">'Z'</FONT></B>) || isininc(<B><FONT COLOR="#BC8F8F">'a'</FONT></B>,*it,<B><FONT COLOR="#BC8F8F">'z'</FONT></B>) )){
                in.erase(it);
                --it;
            }
        }
    }

    <I><FONT COLOR="#B22222">//Common replacements (ie. a '_' instead of a ' ', etc..)
</FONT></I>
    <I><FONT COLOR="#B22222">// ...
</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> in;
}

<I><FONT COLOR="#B22222">//Prefer this function to the other. Eventually, move the other function here and remove it.
</FONT></I><I><FONT COLOR="#B22222">// I don't think it works out being any faster to deal with references because of r-values.
</FONT></I>std::string Canonicalize_String2(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> &amp;mask){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string temp(in);
    Canonicalize_String(temp, mask);
    <B><FONT COLOR="#A020F0">return</FONT></B> temp;
}

<I><FONT COLOR="#B22222">//Attempt to ~intelligently replace non-simple chars like spaces and commas.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This function is incomplete because it should be added to as annoyances are found.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Do NOT depend on any specific format of string being emitted from this function, 
</FONT></I><I><FONT COLOR="#B22222">//      except that they will probably be suitable for a filename and easy bash interpretation.
</FONT></I>std::string Detox_String(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out(in);

    <I><FONT COLOR="#B22222">//Replace annoying characters with underscores.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = out.begin(); it != out.end(); ++it){
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">','</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">' '</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'\''</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'\&quot;'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'('</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">')'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'{'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'}'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'|'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'+'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'~'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'!'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'#'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'@'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'$'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'%'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'&amp;'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'^'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">':'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">';'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'&lt;'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'&gt;'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'?'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'*'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'`'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">'\\'</FONT></B>) || (*it == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>)) *it = <B><FONT COLOR="#BC8F8F">'_'</FONT></B>;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>(out.size() &lt;= 1) <B><FONT COLOR="#A020F0">return</FONT></B> out;

    <I><FONT COLOR="#B22222">//Condense all underscore runs to a single underscore.
</FONT></I>    <B><FONT COLOR="#228B22">auto</FONT></B> it1 = out.begin();
    <B><FONT COLOR="#A020F0">while</FONT></B>(it1 != out.end()){
        <B><FONT COLOR="#228B22">auto</FONT></B> it2 = std::next(it1,1);
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it1 == <B><FONT COLOR="#BC8F8F">'_'</FONT></B>) &amp;&amp; (*it2 == <B><FONT COLOR="#BC8F8F">'_'</FONT></B>)){
            out.erase(it2);
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            ++it1;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//Removes lowest filename or dir (via '/'), returns parent directory 
</FONT></I><I><FONT COLOR="#B22222">// with trailing slash intact.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: No check is performed to see if EITHER given or outgoing paths
</FONT></I><I><FONT COLOR="#B22222">//       are legitimate. 
</FONT></I><I><FONT COLOR="#B22222">//NOTE: On failure, an empty string is returned.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine does not know about the filesystem, nor '.', './',
</FONT></I><I><FONT COLOR="#B22222">//       or '../'. If these are required, explicitly provide them!
</FONT></I><I><FONT COLOR="#B22222">//       (If they were added, an arbitrary number of '../' could be 
</FONT></I><I><FONT COLOR="#B22222">//       added - probably not useful for most purposes.) 
</FONT></I><I><FONT COLOR="#B22222">//NOTE: If the full path is required, but input is not controlled, try
</FONT></I><I><FONT COLOR="#B22222">//       using `basename` or similar (See YgorFilesDirs). ((This will 
</FONT></I><I><FONT COLOR="#B22222">//       only work when the file/path in question actually exists.))
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//EXAMPLES:
</FONT></I><I><FONT COLOR="#B22222">//    '/some/file'  --&gt; '/some/'
</FONT></I><I><FONT COLOR="#B22222">//    '/some/path/' --&gt; '/some/'
</FONT></I><I><FONT COLOR="#B22222">//    'some/path/'  --&gt; 'some/'
</FONT></I><I><FONT COLOR="#B22222">//    '/some/'      --&gt; '/'
</FONT></I><I><FONT COLOR="#B22222">//    '/'           --&gt; ''  (failure - no parent)
</FONT></I><I><FONT COLOR="#B22222">//    'file'        --&gt; ''  (failure - we don't do '.' or '..')
</FONT></I><I><FONT COLOR="#B22222">//    '../file'     --&gt; '../'
</FONT></I><I><FONT COLOR="#B22222">//    './file'      --&gt; './'
</FONT></I><I><FONT COLOR="#B22222">//    '../../../'   --&gt; '../../'
</FONT></I><I><FONT COLOR="#B22222">//    './.././'     --&gt; './../'
</FONT></I>std::string Get_Parent_Directory(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;path){
    <I><FONT COLOR="#B22222">//Trim the edges. Probably not strictly needed...
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out(Canonicalize_String2(path,CANONICALIZE::TRIM_ENDS));
    <B><FONT COLOR="#A020F0">if</FONT></B>(out.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> out; <I><FONT COLOR="#B22222">//Failure.    
</FONT></I>
    <I><FONT COLOR="#B22222">//Reverse the string.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::reverse(out.begin(), out.end());
   
    <I><FONT COLOR="#B22222">//If the first char is a slash, remove if.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(out[0] == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>) out.erase(0,1);
    <B><FONT COLOR="#A020F0">if</FONT></B>(out.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> out; <I><FONT COLOR="#B22222">//Failure.    
</FONT></I>
    <I><FONT COLOR="#B22222">//Remove everything up until the first '/' is found.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> first = out.find(<B><FONT COLOR="#BC8F8F">'/'</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(first != std::string::npos){
        out.erase(0,first); <I><FONT COLOR="#B22222">//Leaves '/' intact.
</FONT></I>    }<B><FONT COLOR="#A020F0">else</FONT></B>{ <I><FONT COLOR="#B22222">//No slash found. This is a failure.
</FONT></I>        out.clear();
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(out.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> out; <I><FONT COLOR="#B22222">//Failure.    
</FONT></I>
    <I><FONT COLOR="#B22222">//Reverse the string.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::reverse(out.begin(), out.end());
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//Returns substr after last '/'. If no '/', returns input string.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine knows nothing about the filesystem. The file need not exist, 
</FONT></I><I><FONT COLOR="#B22222">// and the path could be bogus; this routine doesn't care. It just works on '/'s.
</FONT></I>std::string Get_Bare_Filename(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;fullname){
    <I><FONT COLOR="#B22222">//Get the location of the last '/'.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> size_t indx_last = fullname.find_last_of(<B><FONT COLOR="#BC8F8F">'/'</FONT></B>);

    <B><FONT COLOR="#A020F0">if</FONT></B>(indx_last == std::string::npos) <B><FONT COLOR="#A020F0">return</FONT></B> fullname;
    <B><FONT COLOR="#A020F0">return</FONT></B> fullname.substr(indx_last + 1);
}


<I><FONT COLOR="#B22222">//Compare sections of two strings for equality. After safely pulling out the sections, perform canonicalization on the
</FONT></I><I><FONT COLOR="#B22222">// segments before comparison. This is useful for ignoring case and whitespace, for example.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The from_X and to_X numbers are zero-based. They can safely be out of range; the comparison will 
</FONT></I><I><FONT COLOR="#B22222">//      safely fail.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: If the user asks for a range, both strings MUST satisfy the range in order to attempt comparison.
</FONT></I><I><FONT COLOR="#B22222">//      For example, if A = &quot;abc&quot; and B = &quot;abc&quot; but the user has both from_X = 0 and both to_X = 3, then this
</FONT></I><I><FONT COLOR="#B22222">//      function will return FALSE. Why? Because the user specified that the matching section must be exactly
</FONT></I><I><FONT COLOR="#B22222">//      four characters in length (i.e., the 0th, 1st, 2nd, and 3rd characters).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Be careful with the from_X and to_X numbers. They are applied AFTER the canononicalization!
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Safely_Compare_Strings</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;A, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> from_A, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> to_A, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> mask_A, 
                            <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;B, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> from_B, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> to_B, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> mask_B){

    <B><FONT COLOR="#228B22">const</FONT></B> std::string AA = Canonicalize_String2(A,mask_A);
    <B><FONT COLOR="#228B22">const</FONT></B> std::string BB = Canonicalize_String2(B,mask_B);

    <B><FONT COLOR="#A020F0">if</FONT></B>( (to_A == from_A) &amp;&amp; (to_B == from_B) ) <B><FONT COLOR="#A020F0">return</FONT></B> true; <I><FONT COLOR="#B22222">//Both are the empty string ... they match!
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>( (to_A &lt; from_A) || (to_B &lt; from_B) ) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>( (to_A + 1) &gt; AA.size() ) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>( (to_B + 1) &gt; BB.size() ) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#228B22">const</FONT></B> std::string AAA = AA.substr(from_A, (to_A - from_A) + 1);
    <B><FONT COLOR="#228B22">const</FONT></B> std::string BBB = BB.substr(from_B, (to_B - from_B) + 1);

    <B><FONT COLOR="#A020F0">return</FONT></B> (AAA == BBB);
}



<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//------------------------------------------------ Math expression transformations ----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//This function removes redundant parenthesis on the outer edges of an expression.
</FONT></I><I><FONT COLOR="#B22222">// eg.   ((((x+(y+z)))))   ---&gt;    x+(y+z)
</FONT></I><I><FONT COLOR="#B22222">// eg.      (a+b)(a+b)     ---&gt;  (a+b)(a+b)
</FONT></I>std::string Remove_Unneeded_Surrounding_Parenthesis(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">char</FONT></B> L, <B><FONT COLOR="#228B22">char</FONT></B> R){
    <B><FONT COLOR="#A020F0">if</FONT></B>(in.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> in;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out(in);
    <B><FONT COLOR="#A020F0">while</FONT></B>( (out.front() == L) &amp;&amp; (out.back() == R) ){
        <I><FONT COLOR="#B22222">//We use depths or 'levels' to denote how deep we are nested.
</FONT></I>        <I><FONT COLOR="#B22222">// If the level goes below 0, we cannot chop off outer parenthesis.
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">//Note: level == openparens-1.
</FONT></I>        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> level(0);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = ++(out.begin()); (it != --(out.end())) &amp;&amp; (level &gt;= 0); ++it){
            <B><FONT COLOR="#A020F0">if</FONT></B>(*it == L) ++level;
            <B><FONT COLOR="#A020F0">if</FONT></B>(*it == R) --level;
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>(level &lt; 0) <B><FONT COLOR="#A020F0">break</FONT></B>;
        out = out.substr(1, (out.size()-1)-1);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}

<I><FONT COLOR="#B22222">//This function explicitly wraps objects separated by commas into parenthesis-delimited blocks.
</FONT></I><I><FONT COLOR="#B22222">// Only touches commas at the top-level parenthesis depth level.
</FONT></I><I><FONT COLOR="#B22222">// eg.    (1+1-2,atan2(x,y),z)   ---&gt;   (1+1-2),(atan2(x,y)),(z)
</FONT></I><I><FONT COLOR="#B22222">// eg.     1+1-2,atan2(x,y),z    ---&gt;   (1+1-2),(atan2(x,y)),(z)
</FONT></I><I><FONT COLOR="#B22222">// eg.   ((1+1-2,atan2(x,y),z))  ---&gt;   (1+1-2),(atan2(x,y)),(z)
</FONT></I>std::string Wrap_Comma_Separated_Stuff_At_Same_Depth(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">char</FONT></B> L, <B><FONT COLOR="#228B22">char</FONT></B> R){
    <I><FONT COLOR="#B22222">//Troublesome expressions like: if(1+1-2,x,y) will get split up into incorrect trees
</FONT></I>    <I><FONT COLOR="#B22222">// unless the commas are enclosed with parenthesis. 
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//This function scans the input and tries to wrap objects separated by commas (at 
</FONT></I>    <I><FONT COLOR="#B22222">// the same depth) in parenthesis.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    <B><FONT COLOR="#228B22">const</FONT></B> std::string inn(Remove_Unneeded_Surrounding_Parenthesis(in, L, R));

    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> parendepth(0);
    <B><FONT COLOR="#228B22">bool</FONT></B> foundcommas = false;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = inn.begin(); it != inn.end(); ++it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(*it == L)  ++parendepth;
        <B><FONT COLOR="#A020F0">if</FONT></B>(*it == R)  --parendepth;
        <B><FONT COLOR="#A020F0">if</FONT></B>((*it == <B><FONT COLOR="#BC8F8F">','</FONT></B>) &amp;&amp; (parendepth == 0)){
            out += std::string(1,R) + <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B>_s + std::string(1,L);
            foundcommas = true;
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            out += *it;
        }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(foundcommas) <B><FONT COLOR="#A020F0">return</FONT></B> std::string(1,L) + out + std::string(1,R);
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(out);
}


<I><FONT COLOR="#B22222">//Looks for unmatched pairs of input. Typically used with '(' and ')', or other parenthesis. 
</FONT></I><I><FONT COLOR="#B22222">// Will work for quotations too.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// eg.    ((x+y))  ---&gt; false
</FONT></I><I><FONT COLOR="#B22222">// eg.    )(x+y)(  ---&gt; false
</FONT></I><I><FONT COLOR="#B22222">// eg.    [(x+y])  ---&gt; false
</FONT></I><I><FONT COLOR="#B22222">// eg.    ((x+y)   ---&gt; true
</FONT></I><I><FONT COLOR="#B22222">//Note: Will not find unpaired/balanced chars like '([x)]'!
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Contains_Unmatched_Char_Pairs</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">char</FONT></B> L, <B><FONT COLOR="#228B22">char</FONT></B> R){
  <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> parens(0);
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.begin(); it != in.end(); ++it){
      <B><FONT COLOR="#A020F0">if</FONT></B>( *it == L ) ++parens;
      <B><FONT COLOR="#A020F0">if</FONT></B>( *it == R ) --parens;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> (parens != 0);
}

<I><FONT COLOR="#B22222">//Removes all occurences of any of the characters in `chars' from the front of `in'. 
</FONT></I><I><FONT COLOR="#B22222">// Removal stops as soon as a non-`chars' character is encountered.
</FONT></I>std::string Remove_Preceeding_Chars(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;chars){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out(in);
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::reverse(out.begin(),out.end()); <I><FONT COLOR="#B22222">//Reverse the input. Preceeding =&gt; trailing.
</FONT></I>    out = Remove_Trailing_Chars(out,chars);
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::reverse(out.begin(),out.end()); <I><FONT COLOR="#B22222">//Restore the original order, sans any preceeding chars.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//Removes all occurences of any of the characters in `chars' from the back of `in'. 
</FONT></I><I><FONT COLOR="#B22222">// Removal stops as soon as a non-`chars' character is encountered.
</FONT></I>std::string Remove_Trailing_Chars(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;chars){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out(in);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = out.rbegin(); it != out.rend();   ){
        <I><FONT COLOR="#B22222">//Look for the current character in the blacklist (i.e., `chars').
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(chars.find(*it) != std::string::npos){
            <I><FONT COLOR="#B22222">//This is a character which should be trimmed.
</FONT></I>            out.pop_back(); <I><FONT COLOR="#B22222">//out.erase(it);
</FONT></I>            it = out.rbegin();
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <I><FONT COLOR="#B22222">//This is the first non`chars' character. Time to bail.
</FONT></I>            <B><FONT COLOR="#A020F0">break</FONT></B>;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}



<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------- Common text conversions --------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I>std::string inttostring(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> number){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;
    ss &lt;&lt; number;
    <B><FONT COLOR="#A020F0">return</FONT></B> ss.str();
}

std::string floattostring(<B><FONT COLOR="#228B22">float</FONT></B> number){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;
    ss &lt;&lt; number;
    <B><FONT COLOR="#A020F0">return</FONT></B> ss.str();
}

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;  std::string Xtostring(T numb){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;
    ss &lt;&lt; numb;
    <B><FONT COLOR="#A020F0">return</FONT></B> ss.str();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORSTRING_CC_COMMON_TEMPLATE_INSTANTIATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::string Xtostring&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string Xtostring&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string Xtostring&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string Xtostring&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string Xtostring&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string Xtostring&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;(<B><FONT COLOR="#228B22">float</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string Xtostring&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(<B><FONT COLOR="#228B22">double</FONT></B>);

    <B><FONT COLOR="#228B22">template</FONT></B>&lt;&gt; std::string Xtostring&lt;std::string&gt;(std::string in){ <B><FONT COLOR="#A020F0">return</FONT></B> in; }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;   std::string XtoPreciseString(T numb){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;
    ss &lt;&lt; std::setprecision(500) &lt;&lt; numb;
    <B><FONT COLOR="#A020F0">return</FONT></B> ss.str();
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORSTRING_CC_COMMON_TEMPLATE_INSTANTIATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> std::string XtoPreciseString&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string XtoPreciseString&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string XtoPreciseString&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string XtoPreciseString&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string XtoPreciseString&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string XtoPreciseString&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string XtoPreciseString&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;(<B><FONT COLOR="#228B22">float</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> std::string XtoPreciseString&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(<B><FONT COLOR="#228B22">double</FONT></B>);

    <B><FONT COLOR="#228B22">template</FONT></B>&lt;&gt; std::string XtoPreciseString&lt;std::string&gt;(std::string in){ <B><FONT COLOR="#A020F0">return</FONT></B> in; }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;   T stringtoX(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;text){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss(text);
    T temp;
    ss &gt;&gt; temp;
    <B><FONT COLOR="#A020F0">return</FONT></B> temp;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORSTRING_CC_COMMON_TEMPLATE_INSTANTIATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B>                    stringtoX&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>                   stringtoX&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>                      stringtoX&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>             stringtoX&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>                 stringtoX&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>            stringtoX&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>        stringtoX&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>   stringtoX&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);

    <B><FONT COLOR="#228B22">template</FONT></B>&lt;&gt; std::string stringtoX&lt;std::string&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){ <B><FONT COLOR="#A020F0">return</FONT></B> in; }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt; <B><FONT COLOR="#228B22">bool</FONT></B> Is_String_An_X(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;text){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss(text);
    T d;
    <B><FONT COLOR="#A020F0">if</FONT></B>(ss &gt;&gt; d){
        <I><FONT COLOR="#B22222">//Test if there is no more data remaining. If there is, then the string is NOT a 'T'.
</FONT></I>        ss.peek();
        <B><FONT COLOR="#A020F0">if</FONT></B>(ss.eof()){
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORSTRING_CC_COMMON_TEMPLATE_INSTANTIATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B>  Is_String_An_X&lt;<B><FONT COLOR="#228B22">float</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B>  Is_String_An_X&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B>  Is_String_An_X&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B>  Is_String_An_X&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B>  Is_String_An_X&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B>  Is_String_An_X&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B>  Is_String_An_X&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B>  Is_String_An_X&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;);

    <B><FONT COLOR="#228B22">template</FONT></B>&lt;&gt; <B><FONT COLOR="#228B22">bool</FONT></B> Is_String_An_X&lt;std::string&gt;(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){ <B><FONT COLOR="#A020F0">return</FONT></B> true; }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//This is useful for parsing a config file. Provide a key like &quot;aval = &quot; and if the line is &quot;aval = 6&quot; then you'll
</FONT></I><I><FONT COLOR="#B22222">// get a 6 back. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine will ONLY alter the output's contents on success.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This routine will not handle quotation marks. The RHS of the line must be 'bare'.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Your choice of canonicalization will be reflected in the output. If you TO_UPPER the input,
</FONT></I><I><FONT COLOR="#B22222">//      any output will also be TO_UPPER'd. (Working around this here would be quite tricky. It would
</FONT></I><I><FONT COLOR="#B22222">//      be much easier to do in your context-aware code, if required.)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The canonicalization will happen ASAP. Ensure your keys reflect this. (i.e., if you are trimming all
</FONT></I><I><FONT COLOR="#B22222">//      consecutive whitespace to a single space, ensure your key is written as &quot;your key = &quot; instead of
</FONT></I><I><FONT COLOR="#B22222">//      &quot;your key =&quot; - the very last space may be significant, dependending on what you're doing!)
</FONT></I><I><FONT COLOR="#B22222">// 
</FONT></I><I><FONT COLOR="#B22222">//      For example, passing the key &quot;    someval =  &quot; with flag '::TRIM_ALL' will give identical outcome as
</FONT></I><I><FONT COLOR="#B22222">//      passing &quot;someval=&quot;. Be aware of this when specifying your keys!
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">GetValueIfKeyMatches</FONT></B>(T *out, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;key,  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> key_mask, 
                                  <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;line, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> line_mask){
    <B><FONT COLOR="#A020F0">if</FONT></B>(out == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed a nullptr - no way return matches. Cannot continue&quot;</FONT></B>);

<I><FONT COLOR="#B22222">//    if(line.size() &lt;= key.size()) return false;
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// If we do the canonicalization in the comparison, we have to redo it again right after if true.
</FONT></I><I><FONT COLOR="#B22222">//    if(!Safely_Compare_Strings(line,0,key.size()-1,line_mask,
</FONT></I><I><FONT COLOR="#B22222">//                                key,0,key.size()-1, key_mask) ) return false;
</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> std::string key_C = Canonicalize_String2(key,key_mask);
    <B><FONT COLOR="#228B22">const</FONT></B> std::string lineC = Canonicalize_String2(line,line_mask);

    <B><FONT COLOR="#A020F0">if</FONT></B>(lineC.size() &lt;= key_C.size()) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#A020F0">if</FONT></B>(!Safely_Compare_Strings(lineC,0,key_C.size()-1,0,
                               key_C,0,key_C.size()-1,0) ) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    <B><FONT COLOR="#228B22">const</FONT></B> std::string remaining_line = lineC.substr(key_C.size());
    <B><FONT COLOR="#A020F0">if</FONT></B>(!Is_String_An_X&lt;T&gt;(remaining_line)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    *out = stringtoX&lt;T&gt;(remaining_line);
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">YGORSTRING_CC_COMMON_TEMPLATE_INSTANTIATIONS</FONT>
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> GetValueIfKeyMatches(<B><FONT COLOR="#228B22">float</FONT></B>                  *, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> GetValueIfKeyMatches(<B><FONT COLOR="#228B22">double</FONT></B>                 *, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> GetValueIfKeyMatches(<B><FONT COLOR="#228B22">int</FONT></B>                    *, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> GetValueIfKeyMatches(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>           *, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> GetValueIfKeyMatches(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>               *, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> GetValueIfKeyMatches(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>          *, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> GetValueIfKeyMatches(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>      *, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> GetValueIfKeyMatches(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> *, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>);
    <B><FONT COLOR="#228B22">template</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> GetValueIfKeyMatches(std::string            *, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>



<I><FONT COLOR="#B22222">//This function takes a string (i.e. an array of chars), cycles through looking for un-printable characters, and 
</FONT></I><I><FONT COLOR="#B22222">// converts them to hex for easy printing. This is a one-way function, and we cannot go backward! 
</FONT></I><I><FONT COLOR="#B22222">// Output is for human consumption only!
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This function will destroy carriage returns, newlines, tabs, etc... This is intentional.
</FONT></I>std::string Convert_Unprintables_to_Hex(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.begin(); it != in.end(); ++it){
        <B><FONT COLOR="#228B22">int</FONT></B> v(static_cast&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(static_cast&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;(*it)));
        <B><FONT COLOR="#A020F0">if</FONT></B>(isininc(32,v,126)){
            ss &lt;&lt; *it;
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            ss &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;(0x&quot;</FONT></B> &lt;&lt; std::hex &lt;&lt; v &lt;&lt; std::dec &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ss.str();
}

<I><FONT COLOR="#B22222">//This function escapes a chunk of static text. The output is properly quoted with either ' or &quot;s,
</FONT></I><I><FONT COLOR="#B22222">// and anything which needs to be escaped will be.
</FONT></I>std::string Quote_Static_for_Bash(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out(<B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B>);
<I><FONT COLOR="#B22222">//    out += &quot;'&quot;;
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.begin(); it != in.end(); ++it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(*it == <B><FONT COLOR="#BC8F8F">'\''</FONT></B>){
            out += R<B><FONT COLOR="#BC8F8F">&quot;***('\'')***&quot;</FONT></B>;
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            out += *it;
        }
    }
<I><FONT COLOR="#B22222">//    out += &quot;'&quot;;
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> out + <B><FONT COLOR="#BC8F8F">'&quot;'</FONT></B>;
}

<I><FONT COLOR="#B22222">//This function escapes a chunk of possibly-expandable text. The output is possibly quoted with &quot;s,
</FONT></I><I><FONT COLOR="#B22222">// and anything which needs to be escaped will be.
</FONT></I>std::string Quote_Expandable_for_Bash(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out(<B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.begin(); it != in.end(); ++it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(*it == <B><FONT COLOR="#BC8F8F">'&quot;'</FONT></B>){
            out += R<B><FONT COLOR="#BC8F8F">&quot;***(\&quot;)***&quot;</FONT></B>;
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            out += *it;
        }
    }
<I><FONT COLOR="#B22222">//    out += '&quot;';
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> out + <B><FONT COLOR="#BC8F8F">'&quot;'</FONT></B>;
}


<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------- Generic String-related Routines -----------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//This function looks very similar to one in YgorMisc.h/cc! It should replace it eventually!
</FONT></I>std::string Generate_Random_String_of_Length(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> len){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> std::string alphanum(R<B><FONT COLOR="#BC8F8F">&quot;***(0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz)***&quot;</FONT></B>);
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::random_device rd;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::default_random_engine gen(rd()); <I><FONT COLOR="#B22222">//Seed with a true random number.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::uniform_int_distribution&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; dist(0,alphanum.length()-1);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;len; ++i) out += alphanum[dist(gen)];
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//This function will taken a vector of strings (typically, a tokenized string) and lineate it into a single string.
</FONT></I>std::string Lineate_Vector(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::string&gt; &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;separator){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = in.begin(); it != in.end(); ){
        out += *it;
        ++it;
        <B><FONT COLOR="#A020F0">if</FONT></B>(it != in.end()) out += separator;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}



<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//---------------------------------------------------- Basic parsing routines ---------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I>

<I><FONT COLOR="#B22222">//This function takes a string (s), a delimiter, and a vector (elems) and splits the string into tokens.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Use the function below (&quot;split&quot; with two arguments) for a version which does not require a vector as input,
</FONT></I><I><FONT COLOR="#B22222">// but is slower (and more costly.)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//The character BEHAVIOUR denotes how the delimiter should be handled. 
</FONT></I><I><FONT COLOR="#B22222">//   d - To drop the delimiter altogether, 
</FONT></I><I><FONT COLOR="#B22222">//   l - Keep the delimiter on the left side of the break (last character of the line,)
</FONT></I><I><FONT COLOR="#B22222">//   r - Put the delimiter on the right side of the break (first character of next line.)
</FONT></I>std::vector&lt;std::string&gt; &amp;BYOVectorSplit(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;s, <B><FONT COLOR="#228B22">char</FONT></B> delim, std::vector&lt;std::string&gt; &amp;elems, <B><FONT COLOR="#228B22">char</FONT></B> BEHAVIOUR){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss(s);
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string item;
    size_t count = 0;

    <B><FONT COLOR="#A020F0">while</FONT></B>(std::getline(ss, item, delim)){
        <B><FONT COLOR="#A020F0">if</FONT></B>(item.size() != 0){
            <B><FONT COLOR="#A020F0">if</FONT></B>(BEHAVIOUR == <B><FONT COLOR="#BC8F8F">'d'</FONT></B>){
                elems.push_back(item);
            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(BEHAVIOUR == <B><FONT COLOR="#BC8F8F">'l'</FONT></B>){
                elems.push_back(item + delim);
            }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(BEHAVIOUR == <B><FONT COLOR="#BC8F8F">'r'</FONT></B>){
                <B><FONT COLOR="#A020F0">if</FONT></B>(count == 0){
                    elems.push_back(item);
                }<B><FONT COLOR="#A020F0">else</FONT></B>{
                    elems.push_back(delim + item);
                }
            }
        }
        ++count;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> elems;
}

std::vector&lt;std::string&gt; SplitStringToVector(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;s, <B><FONT COLOR="#228B22">char</FONT></B> delim, <B><FONT COLOR="#228B22">char</FONT></B> BEHAVIOUR){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; elems;
    <B><FONT COLOR="#A020F0">return</FONT></B> BYOVectorSplit(s, delim, elems, BEHAVIOUR);
}

std::vector&lt;std::string&gt; SplitStringToVector(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;s, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;delim, <B><FONT COLOR="#228B22">char</FONT></B> BEHAVIOUR){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; out;

    <I><FONT COLOR="#B22222">//First, we append the delimiter to the end of the string.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> boost::regex regex( delim );

    <I><FONT COLOR="#B22222">//Iterate over all the non-matches. The '-1&quot; means iterate over non-matches.
</FONT></I>    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::sregex_token_iterator iter( s.begin(), s.end(), regex, -1 );
    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::sregex_token_iterator end;

    <I><FONT COLOR="#B22222">//Iterate over matches, storing them if they 
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>( ; iter != end; ++iter ){
        out.push_back( *iter );
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(out.size() == 0) <B><FONT COLOR="#A020F0">return</FONT></B> out;

    <B><FONT COLOR="#A020F0">if</FONT></B>(BEHAVIOUR == <B><FONT COLOR="#BC8F8F">'d'</FONT></B>){
        <B><FONT COLOR="#A020F0">return</FONT></B> out;
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(BEHAVIOUR == <B><FONT COLOR="#BC8F8F">'l'</FONT></B>){
        <I><FONT COLOR="#B22222">//Append the delimiter to the end of all elements (except the last, where we have inserted an extra one.)
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it=out.begin(); it!=--(out.end()); ++it) *it += delim;
        <B><FONT COLOR="#A020F0">return</FONT></B> out;
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(BEHAVIOUR == <B><FONT COLOR="#BC8F8F">'r'</FONT></B>){
        <I><FONT COLOR="#B22222">//Append the delimiter to the beginning of all elements (except the first, where there was no preceeding one.)
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it=++(out.begin()); it!=out.end(); ++it) *it = delim + *it;
        <B><FONT COLOR="#A020F0">return</FONT></B> out;
    }
 
    FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;BEHAVIOUR = &quot;</FONT></B> &lt;&lt; BEHAVIOUR &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; not recognized. Treating as 'd' and continuing&quot;</FONT></B>);       
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::vector&lt;std::string&gt; SplitVector(<B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::string&gt; &amp;s, <B><FONT COLOR="#228B22">char</FONT></B> delim, <B><FONT COLOR="#228B22">char</FONT></B> BEHAVIOUR){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; elems;
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;s.size(); ++i){
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; temp = SplitStringToVector(s[i], delim, BEHAVIOUR);
        elems.insert(elems.end(), temp.begin(), temp.end());
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> elems;
}

<I><FONT COLOR="#B22222">//This function replaces occurences of some regex in a string with some replacement text.
</FONT></I>std::string ReplaceAllInstances(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;regex, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;replacement){
    <B><FONT COLOR="#228B22">const</FONT></B> boost::regex boost_regex(regex.c_str(), boost::regex::icase );
    <B><FONT COLOR="#A020F0">return</FONT></B> regex_replace( in, boost_regex, replacement );
}

<I><FONT COLOR="#B22222">//This function removes all instances of the input characters from the provided string.
</FONT></I>std::string PurgeCharsFromString(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, std::string purge_chars){
    size_t i=0;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out(in);
    <B><FONT COLOR="#A020F0">do</FONT></B>{
        <I><FONT COLOR="#B22222">//Notice that for a match to happen it is enough that one of the characters matches 
</FONT></I>        <I><FONT COLOR="#B22222">// in the string (any of them). To search for an entire sequence of characters use 
</FONT></I>        <I><FONT COLOR="#B22222">// find instead.
</FONT></I>        i = out.find_first_of(purge_chars, i);
        <B><FONT COLOR="#A020F0">if</FONT></B>( i == std::string::npos ) <B><FONT COLOR="#A020F0">break</FONT></B>;

        out.erase( out.begin() + i );
    }<B><FONT COLOR="#A020F0">while</FONT></B>(true);
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


std::vector&lt;std::string&gt; GetUrls( std::vector&lt;std::string&gt; &amp;in ){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; urls;
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;in.size(); ++i){
        <B><FONT COLOR="#5F9EA0">boost</FONT></B>::sregex_token_iterator iter(in[i].begin(), in[i].end(), regex_all_http_urls, 0);
        <B><FONT COLOR="#5F9EA0">boost</FONT></B>::sregex_token_iterator end;
        <B><FONT COLOR="#A020F0">for</FONT></B>( ; iter != end; ++iter ) {
            urls.push_back( *iter );
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> urls;
}

std::vector&lt;std::string&gt; GetUrls( <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in ){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; temp;
    temp.push_back(in);
    <B><FONT COLOR="#A020F0">return</FONT></B> GetUrls( temp );
}

std::string GetFirstNumber(std::string &amp;in){
    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::sregex_token_iterator iter(in.begin(), in.end(), regex_a_number, 0);
    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::sregex_token_iterator end;

    <I><FONT COLOR="#B22222">//--- FYI:
</FONT></I>    <I><FONT COLOR="#B22222">//Although we only return the first (non-empty) string, we could equally well use this code to iterate
</FONT></I>    <I><FONT COLOR="#B22222">// through ALL matches found (and thus return a vector or something.)
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>( ; iter != end; ++iter ){
        <B><FONT COLOR="#A020F0">if</FONT></B>(iter-&gt;length() != 0){
            <B><FONT COLOR="#A020F0">return</FONT></B> *iter;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;-1&quot;</FONT></B>;
}

std::string GetFirstRegex(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;source, boost::regex &amp;regex_the_query){
    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::smatch match;
    
    <I><FONT COLOR="#B22222">//Returns TRUE if there was a match.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(boost::regex_search(source, match, regex_the_query)){ <I><FONT COLOR="#B22222">//, boost::match_extra)){
</FONT></I>        <I><FONT COLOR="#B22222">//Check for sub-matches (ie. parenthesis within the regex query string.)
</FONT></I>        <I><FONT COLOR="#B22222">//
</FONT></I>        <I><FONT COLOR="#B22222">//For now, we will do something silly and only return the last sub-match, instead of a list of all submatches.
</FONT></I>        <I><FONT COLOR="#B22222">// This is a handicap, but in principle one could just redo the regex and iterate over the sub-match part, 
</FONT></I>        <I><FONT COLOR="#B22222">// eventually picking them all up. This is costly, but easy to think about.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = match.size()-1; i&gt;=0; --i){
            <B><FONT COLOR="#5F9EA0">std</FONT></B>::string submatch(match[i].first, match[i].second);
            <B><FONT COLOR="#A020F0">return</FONT></B> submatch;
        }
    }  
    <B><FONT COLOR="#A020F0">return</FONT></B> std::string();
}

std::string GetFirstRegex(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;source, std::string query){
    <I><FONT COLOR="#B22222">//Make a regex unit from the query.
</FONT></I>    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::regex regex_the_query( query.c_str(), boost::regex::icase );
    <B><FONT COLOR="#A020F0">return</FONT></B> GetFirstRegex(source, regex_the_query);
}

std::string GetFirstRegex(std::vector&lt;std::string&gt; &amp;source, std::string query){
    <I><FONT COLOR="#B22222">//Make a regex unit from the query.
</FONT></I>    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::regex regex_the_query( query.c_str(), boost::regex::icase );

    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;source.size(); ++i){
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string dumb = GetFirstRegex(source[i], regex_the_query);
        <B><FONT COLOR="#A020F0">if</FONT></B>(dumb != <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B> dumb;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::string();
}


std::vector&lt;std::string&gt; GetAllRegex(std::vector&lt;std::string&gt; &amp;source, boost::regex &amp;regex_the_query){
    FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;This function has been found to be invalid - Swap the GetAllRegex2 codes into this code to see if anything changes!&quot;</FONT></B>);
    #pragma message <B><FONT COLOR="#BC8F8F">&quot;Warning - This function has been found to be invalid - Swap the GetAllRegex2 codes into this code to see if anything changes!&quot;</FONT></B>

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; outgoing;
    <B><FONT COLOR="#228B22">const</FONT></B> boost::sregex_token_iterator end;

    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0; i&lt;source.size(); ++i){
        <I><FONT COLOR="#B22222">//Perform the matching/finding. We get an iterator over matches.
</FONT></I>        <B><FONT COLOR="#5F9EA0">boost</FONT></B>::sregex_token_iterator iter(source[i].begin(), source[i].end(), regex_the_query, 0);

        <I><FONT COLOR="#B22222">//Iterate over matches, storing them if they 
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>( ; iter != end; ++iter ){
            <B><FONT COLOR="#A020F0">if</FONT></B>((*iter).length() != 0){
                outgoing.push_back( *iter );
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> outgoing;
}

std::vector&lt;std::string&gt; GetAllRegex(std::vector&lt;std::string&gt; &amp;source, std::string query){
    <I><FONT COLOR="#B22222">//Make a regex unit from the query.
</FONT></I>    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::regex regex_the_query( query.c_str(), boost::regex::icase );
    <B><FONT COLOR="#A020F0">return</FONT></B> GetAllRegex(source, regex_the_query);
}

std::vector&lt;std::string&gt; GetAllRegex(std::string &amp;source, std::string query){
    <I><FONT COLOR="#B22222">//Make a regex unit from the query.
</FONT></I>    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::regex regex_the_query( query.c_str(), boost::regex::icase );

    <I><FONT COLOR="#B22222">//Encapsulate the source string into a vector.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; encapsed_source;
    encapsed_source.push_back( source );

    <B><FONT COLOR="#A020F0">return</FONT></B> GetAllRegex(encapsed_source, regex_the_query);
}



std::vector&lt;std::string&gt; GetAllRegex2(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;source, std::string query){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; out;
    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::regex regex_the_query( query.c_str(), boost::regex::icase );
    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::sregex_iterator it(source.begin(), source.end(), regex_the_query);
    <B><FONT COLOR="#5F9EA0">boost</FONT></B>::sregex_iterator end;
    <B><FONT COLOR="#A020F0">for</FONT></B>( ; it != end; ++it){
        <B><FONT COLOR="#A020F0">for</FONT></B>(decltype((*it).size()) i = 1; i &lt; (*it).size(); ++i){ <I><FONT COLOR="#B22222">//The Zeroth contains the entire match (not the matchs enclosed in parenthesis!)
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>((*it)[i].matched) out.push_back( (*it)[i].str());
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//This function goes through a vector of strings, finds a matching line, and returns the Nth line below the match.
</FONT></I>std::string GetLineNBelow( std::vector&lt;std::string&gt; &amp;source, std::string query, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N){
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(source.size()); ++i){
        <B><FONT COLOR="#A020F0">if</FONT></B>( std::string::npos != (source[i]).find(query) ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(((i+N) &gt;= 0) &amp;&amp; ((i+N) &lt; static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(source.size()))){
                <B><FONT COLOR="#A020F0">return</FONT></B> source[i+N];
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> std::string();
}


<I><FONT COLOR="#B22222">//This function (lazily) matches regex on a vector and returns the elements within the matches (endpoints inclusive.)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Same-line matching is NOT handled properly. It would be better to handle same-line matching with a string input.
</FONT></I>std::vector&lt;std::vector&lt;std::string&gt; &gt; GetSubVectorFromTo( std::vector&lt;std::string&gt; &amp;in, std::string from, std::string to){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;std::string&gt; &gt; matches;  <I><FONT COLOR="#B22222">//&lt;--- this is the output. Each element is a subvector of the source between endpoints.
</FONT></I>    size_t i = 0;
    <B><FONT COLOR="#228B22">const</FONT></B> boost::regex regex_from(from.c_str(), boost::regex::icase );
    <B><FONT COLOR="#228B22">const</FONT></B> boost::regex regex_to(to.c_str(), boost::regex::icase );

    <B><FONT COLOR="#A020F0">while</FONT></B>(i &lt; in.size()){
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; subvector;
    
        <I><FONT COLOR="#B22222">//Look for the first tag.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>( ; i&lt;in.size(); ++i){
            <B><FONT COLOR="#A020F0">if</FONT></B>( boost::regex_search(in[i], regex_from) ){
               subvector.push_back( in[i] ); 
               ++i;                                        <I><FONT COLOR="#B22222">//NOTE: This routine will not properly handle single-line matches!!!
</FONT></I>               <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }
    
        <I><FONT COLOR="#B22222">//Grab each line until the second tag is found (or the end is hit.)
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>( ; i&lt;in.size(); ++i){
            subvector.push_back( in[i] );
            <B><FONT COLOR="#A020F0">if</FONT></B>( boost::regex_search(in[i], regex_to) ){         
               ++i;                                        <I><FONT COLOR="#B22222">//NOTE: This routine will not properly handle single-line matches!!!
</FONT></I>               <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }
        matches.push_back( subvector );
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> matches;
}


<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------- URL-handling routines ---------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//Found at http://www.codeguru.com/cpp/cpp/algorithms/strings/article.php/c12759/URI-Encoding-and-Decoding.htm
</FONT></I>std::string Basic_Encode_URL(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; in){
   <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> DEC2HEX[16 + 1] = <B><FONT COLOR="#BC8F8F">&quot;0123456789ABCDEF&quot;</FONT></B>;
   <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> * pSrc = (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *)in.c_str();
   <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> SRC_LEN = in.length();
   <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> * <B><FONT COLOR="#228B22">const</FONT></B> pStart = <B><FONT COLOR="#A020F0">new</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>[SRC_LEN * 3];
   <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> * pEnd = pStart;
   <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> * <B><FONT COLOR="#228B22">const</FONT></B> SRC_END = pSrc + SRC_LEN;
   <B><FONT COLOR="#A020F0">for</FONT></B> (; pSrc &lt; SRC_END; ++pSrc)
   {
      <B><FONT COLOR="#A020F0">if</FONT></B> (pSrc != nullptr)
         *pEnd++ = *pSrc;
      <B><FONT COLOR="#A020F0">else</FONT></B>
      {
         <I><FONT COLOR="#B22222">// escape this char
</FONT></I>         *pEnd++ = <B><FONT COLOR="#BC8F8F">'%'</FONT></B>;
         *pEnd++ = DEC2HEX[*pSrc &gt;&gt; 4];
         *pEnd++ = DEC2HEX[*pSrc &amp; 0x0F];
      }
   }
   <B><FONT COLOR="#5F9EA0">std</FONT></B>::string sResult((<B><FONT COLOR="#228B22">char</FONT></B> *)pStart, (<B><FONT COLOR="#228B22">char</FONT></B> *)pEnd);
   <B><FONT COLOR="#A020F0">delete</FONT></B> [] pStart;
   <B><FONT COLOR="#A020F0">return</FONT></B> sResult;
}


std::string Basic_Decode_URL(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out(in);
    <I><FONT COLOR="#B22222">// FIXME ??    See: http://www.w3schools.com/tags/ref_entities.asp
</FONT></I>
    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;[%]7C&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;|&quot;</FONT></B>);
    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;[%]26&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&amp;&quot;</FONT></B>);
    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;[%]3A&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;:&quot;</FONT></B>);
    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;[%]2F&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;/&quot;</FONT></B>);
    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;[%]3F&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;?&quot;</FONT></B>);
    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;[%]3D&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;=&quot;</FONT></B>);

    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;&amp;[Qq][Uu][Oo][Tt];&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B>);
    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;&amp;#34;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B>);

    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;&amp;[Aa][Pp][Oo][Ss];&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B>);
    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;&amp;#39;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B>);

    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;&amp;[Aa][Mm][Pp];&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&amp;&quot;</FONT></B>);
    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;&amp;#38;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&amp;&quot;</FONT></B>);

    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;&amp;[Ll][Tt];&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&lt;&quot;</FONT></B>);
    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;&amp;#60;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&lt;&quot;</FONT></B>);

    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;&amp;[Gg][Tt];&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&gt;&quot;</FONT></B>);
    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;&amp;#62;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&gt;&quot;</FONT></B>);

    <I><FONT COLOR="#B22222">//This one should be last of the rule-replacement rules.
</FONT></I>    out = ReplaceAllInstances(out, <B><FONT COLOR="#BC8F8F">&quot;[%]25&quot;</FONT></B>   , <B><FONT COLOR="#BC8F8F">&quot;%&quot;</FONT></B>);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string out2;
    <B><FONT COLOR="#228B22">char</FONT></B> ch;
    <B><FONT COLOR="#228B22">int</FONT></B> i, ii;
    <B><FONT COLOR="#A020F0">for</FONT></B>(i=0; i&lt;(<B><FONT COLOR="#228B22">int</FONT></B>)(out.length()); i++){
        <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B>(out[i])==37){
<I><FONT COLOR="#B22222">//            sscanf(out.substr(i+1,2).c_str(), &quot;%x&quot;, &amp;ii);
</FONT></I>            sscanf(out.substr(i+1,2).c_str(), <B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;ii);
            ch = static_cast&lt;<B><FONT COLOR="#228B22">char</FONT></B>&gt;(ii);
            out2 += ch;
            i = i+2;
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            out2 += out[i];
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out2;
}

<I><FONT COLOR="#B22222">//Decode GET/POST form URI-encoding into an explicit vector format. Useful for servers handling form data.
</FONT></I>std::vector&lt;std::vector&lt;std::string&gt;&gt; Basic_Decode_Form_URL(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;std::string&gt;&gt; out;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; shuttle;    <I><FONT COLOR="#B22222">//shuttle drains into out.
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string cshuttle;                <I><FONT COLOR="#B22222">//cshuttle drains into shuttle.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> std::string dec = Basic_Decode_URL(in);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = dec.begin(); it != dec.end(); ++it){
        <B><FONT COLOR="#A020F0">if</FONT></B>(*it == <B><FONT COLOR="#BC8F8F">'+'</FONT></B>){
            cshuttle.push_back(<B><FONT COLOR="#BC8F8F">' '</FONT></B>);
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>(*it == <B><FONT COLOR="#BC8F8F">'&amp;'</FONT></B>){ <I><FONT COLOR="#B22222">//Statement separator.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(!cshuttle.empty()) shuttle.push_back(cshuttle);
            cshuttle.clear();

            <B><FONT COLOR="#A020F0">if</FONT></B>(!shuttle.empty()) out.push_back(shuttle);
            shuttle.clear();
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>(*it == <B><FONT COLOR="#BC8F8F">'='</FONT></B>){ <I><FONT COLOR="#B22222">//Statement operator.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(!cshuttle.empty()) shuttle.push_back(cshuttle);
            cshuttle.clear();
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
        <B><FONT COLOR="#A020F0">if</FONT></B>(*it == <B><FONT COLOR="#BC8F8F">'?'</FONT></B>){ <I><FONT COLOR="#B22222">//Form data opener. I don't think this can occur more than once..
</FONT></I>            <I><FONT COLOR="#B22222">//Example:  ...somepage.html?a=b&amp;c=d...
</FONT></I>            cshuttle.clear();
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
        cshuttle += *it;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(!cshuttle.empty()) shuttle.push_back(cshuttle);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!shuttle.empty()) out.push_back(shuttle);
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//----------------------------------------------------- Text Reflow Routines ----------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//-------------------------------------------------------------------------------------------------------------------------------
</FONT></I>
<I><FONT COLOR="#B22222">//This function takes a chunk of text, removes spurious newlines, and returns long strings delineated into paragraphs.
</FONT></I><I><FONT COLOR="#B22222">// It assumes that anything with two or more consecutive newlines is a paragraph boundary.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The vector contains one paragraph per element.
</FONT></I>std::vector&lt;std::string&gt; Break_Text_Into_Paragraphs(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> broken = SplitStringToVector(in, <B><FONT COLOR="#BC8F8F">&quot;\n\n&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">'d'</FONT></B>);
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; out;

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> s_it = broken.begin(); s_it != broken.end(); ++s_it){
<I><FONT COLOR="#B22222">//        out.push_back( PurgeCharsFromString(*s_it, &quot;\n&quot;) );   //Assumes that words might be split into parts on the line ending/beginning.
</FONT></I>        out.push_back( ReplaceAllInstances(*s_it, <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>) );  <I><FONT COLOR="#B22222">//Assumes that words are not split - each line ends with a complete word.
</FONT></I>    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">/*
//Breaks some reflowed text into a text blob (inserting &quot;\n\n&quot; between paragraphs and &quot;\n&quot; between lines).
std::string Break_Paragraphs_Into_Text(const std::vector&lt;std::string&gt; &amp;in){
    std::string out;

    for(auto l_it = in.begin(); l_it != in.end(); ++l_it){
        if(l_it != in.begin()) out += &quot;\n&quot;;
        out += *l_it;
    }

    return out;
}
*/</FONT></I>

<I><FONT COLOR="#B22222">//Returns a broken vector which fits within the given max width.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Takes a single line. Knows nothing about paragraphs.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: If a single word is longer than the line length, it will NOT be broken into two parts - it will be 
</FONT></I><I><FONT COLOR="#B22222">// longer than the maximum line length!
</FONT></I>std::vector&lt;std::string&gt; Reflow_Line_to_Fit_Width_Left_Just(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> W, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> indent){
    <B><FONT COLOR="#A020F0">if</FONT></B>(<I><FONT COLOR="#B22222">/*(indent &lt; 0) ||*/</FONT></I> (W &lt;= 0)) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Given impossible width/indentation values. Cannot proceed&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(YGORABS(indent) &gt;= (W-1)) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Given ridiculous width/indentation values. Refusing to proceed&quot;</FONT></B>);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; out;

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream inss(in);
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string shtl;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string theindent, negindent;
    <B><FONT COLOR="#A020F0">if</FONT></B>(indent &gt;= 0) theindent = std::string( indent, <B><FONT COLOR="#BC8F8F">' '</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(indent &lt;  0) negindent = std::string(-indent, <B><FONT COLOR="#BC8F8F">' '</FONT></B>); <I><FONT COLOR="#B22222">//Indents everything except the first line.
</FONT></I>
    <B><FONT COLOR="#228B22">bool</FONT></B> firstrun = true;
    <B><FONT COLOR="#A020F0">while</FONT></B>( inss.good() ){
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string theword;
        inss &gt;&gt; theword;

        <B><FONT COLOR="#A020F0">if</FONT></B>(firstrun == true){
            theword = theindent + theword;
        }
       
        <B><FONT COLOR="#A020F0">if</FONT></B>(firstrun &amp;&amp; shtl.empty()){
            shtl += theword;
 
        }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl.size() + theword.size() + 1) &gt; W){
            out.push_back(shtl);
            shtl.clear();
            shtl += negindent + theword;

<I><FONT COLOR="#B22222">//        }else if(firstrun &amp;&amp; shtl.empty()){ 
</FONT></I><I><FONT COLOR="#B22222">//            shtl += theword;
</FONT></I>
        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            shtl += <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>_s + theword;
        }

        firstrun = false;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(!shtl.empty()) out.push_back(shtl);
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//Returns a broken vector of possibly multiple paragraphs which fits within the given max width and is indented.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Takes a linear collection of paragraphs. Assumes paragraphs are separated by &quot;\n\n&quot;.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: If a single word is longer than the line length, it will NOT be broken into two parts - it will be 
</FONT></I><I><FONT COLOR="#B22222">// longer than the maximum line length!
</FONT></I>std::vector&lt;std::string&gt; Reflow_Text_to_Fit_Width_Left_Just(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> W, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> indent){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; out;

    <I><FONT COLOR="#B22222">//Break each paragraph into its own single line.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> broken_des = Break_Text_Into_Paragraphs(in);

    <I><FONT COLOR="#B22222">//Cycle over each paragraph, reflowing the text and inserting the indent.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = broken_des.begin(); p_it != broken_des.end(); ++p_it){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> reflowed = Reflow_Line_to_Fit_Width_Left_Just(*p_it, W, indent);

        <I><FONT COLOR="#B22222">//Drop a break (empty horizontal line) between paragraphs if between two paragraphs.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(p_it != broken_des.begin()) out.push_back(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);

        <I><FONT COLOR="#B22222">//Cycle over the lines and push them into the output vector.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> l_it = reflowed.begin(); l_it != reflowed.end(); ++l_it) out.push_back( *l_it );
    }


    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<I><FONT COLOR="#B22222">//Returns a broken vector composed of (possibly multiple) paragraphs which are laid side-by-side. 
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Takes (two) linear collections of paragraphs. Assumes paragraphs are separated by &quot;\n\n&quot;.
</FONT></I><I><FONT COLOR="#B22222">//NOTE: If a single word is longer than the line length, it will NOT be broken into two parts - it will be 
</FONT></I><I><FONT COLOR="#B22222">// longer than the maximum line length!
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The width of the separator is NOT accounted for. This is the user's job.
</FONT></I>std::vector&lt;std::string&gt; Reflow_Adjacent_Texts_to_Fit_Width_Left_Just(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;inL, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> WL, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> indentL,
                                                                      <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;sep,
                                                                      <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;inR, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> WR, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> indentR){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; outL, outR, out;

    <I><FONT COLOR="#B22222">//Break each paragraph into its own single line.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> broken_desL = Break_Text_Into_Paragraphs(inL);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> broken_desR = Break_Text_Into_Paragraphs(inR);

    <I><FONT COLOR="#B22222">//Cycle over each paragraph, reflowing the text and inserting the indent.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = broken_desL.begin(); p_it != broken_desL.end(); ++p_it){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> reflowed = Reflow_Line_to_Fit_Width_Left_Just(*p_it, WL, indentL);

        <I><FONT COLOR="#B22222">//Drop a break (empty horizontal line) between paragraphs if between two paragraphs.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(p_it != broken_desL.begin()) outL.push_back(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);

        <I><FONT COLOR="#B22222">//Cycle over the lines and push them into the output vector.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> l_it = reflowed.begin(); l_it != reflowed.end(); ++l_it) outL.push_back( *l_it );
    }
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> p_it = broken_desR.begin(); p_it != broken_desR.end(); ++p_it){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> reflowed = Reflow_Line_to_Fit_Width_Left_Just(*p_it, WR, indentR);

        <I><FONT COLOR="#B22222">//Drop a break (empty horizontal line) between paragraphs if between two paragraphs.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>(p_it != broken_desR.begin()) outR.push_back(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);

        <I><FONT COLOR="#B22222">//Cycle over the lines and push them into the output vector.
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> l_it = reflowed.begin(); l_it != reflowed.end(); ++l_it) outR.push_back( *l_it );
    }

    <I><FONT COLOR="#B22222">//Assemble the pieces. Ensure the number of rows match for each text block.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> max_rows = (outL.size() &gt; outR.size()) ? outL.size() : outR.size();
    <B><FONT COLOR="#A020F0">while</FONT></B>(outL.size() &lt; max_rows) outL.push_back(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">while</FONT></B>(outR.size() &lt; max_rows) outR.push_back(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = outL.begin(); it != outL.end(); ++it){
        <I><FONT COLOR="#B22222">//Pad the left with spaces.
</FONT></I>        <B><FONT COLOR="#A020F0">while</FONT></B>(static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(it-&gt;size()) &lt; WL) *it += <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> itL = outL.begin(), itR = outR.begin(); (itL != outL.end()) &amp;&amp; (itR != outR.end()); ++itL, ++itR){
        out.push_back( *itL + sep + *itR );
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<I><FONT COLOR="#B22222">//Centers a given line to a specified width by padding the left side with ' 's.
</FONT></I>std::string Reflow_Line_Align_Center(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> W){
    <I><FONT COLOR="#B22222">//Check if the string is larger than the specified width. If so, we cannot possibly center it any better :/.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(in.size()) &gt; W) <B><FONT COLOR="#A020F0">return</FONT></B> in;

    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> space = (W - static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(in.size()))/2; <I><FONT COLOR="#B22222">//+-1 !  :)
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> std::string(space, <B><FONT COLOR="#BC8F8F">' '</FONT></B>) + in;
}

</PRE>
<HR>
<A NAME="file39">
<H1>YgorTime.cc 39/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file38">prev</A>][<A HREF="#file40">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorTime.cc - Simple routines for dealing with time.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/time.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ctime&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;limits&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorSerialize.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorTime.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------- time_mark class - a simple class for holding timestamps --------------------------------------
</FONT></I><I><FONT COLOR="#B22222">//--------------------------------------------------------------------------------------------------------------------------------
</FONT></I><B><FONT COLOR="#0000FF">time_mark::time_mark</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){ 
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Set_current_time();
}

<B><FONT COLOR="#0000FF">time_mark::time_mark</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;T) : When(T.When) { }

<B><FONT COLOR="#0000FF">time_mark::~time_mark</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){ }

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">time_mark::Set_current_time</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::time(&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When);
}

std::string time_mark::Dump_as_string(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//NOTE: Months and hours are 1-12, days are 1-31, but minutes and seconds are 0-59.
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: In the future, update to use the std::put_time and std::get_time commands.
</FONT></I>    <I><FONT COLOR="#B22222">//NOTE: If this needs to be changed, update this-&gt;Theo_Max_Serialization_Size. Consider making a new serialization version.
</FONT></I>    <B><FONT COLOR="#228B22">struct</FONT></B> tm lt;
    <B><FONT COLOR="#A020F0">if</FONT></B>(localtime_r(&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When, &amp;lt) == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;localtime_r produced an error - unable to continue&quot;</FONT></B>);
<I><FONT COLOR="#B22222">//    if(gmtime_r(&amp;this-&gt;When, &amp;lt) == nullptr) FUNCERR(&quot;localtime_r produced an error - unable to continue&quot;);
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream ss(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);

    <I><FONT COLOR="#B22222">//The previously-preferred way. It was easy to parse because of all the landmarks, but made little sense for most
</FONT></I>    <I><FONT COLOR="#B22222">// practical purposes (including funneling date strings through bash, which was painful).
</FONT></I>    <I><FONT COLOR="#B22222">//
</FONT></I>    <I><FONT COLOR="#B22222">//Format: year/month/day-hour:minute:second
</FONT></I>    <I><FONT COLOR="#B22222">//Format: `date +%Y\/%m\/%d-%H:%M:%S`  (slightly different because all numbers have preceeding 0's if needed. Will interoperate, I think) 
</FONT></I>    <I><FONT COLOR="#B22222">//ss &lt;&lt; (lt.tm_year+1900) &lt;&lt; &quot;/&quot; &lt;&lt; (lt.tm_mon+1)  &lt;&lt; &quot;/&quot; &lt;&lt; lt.tm_mday   &lt;&lt; &quot;-&quot;;
</FONT></I>    <I><FONT COLOR="#B22222">//ss &lt;&lt; lt.tm_hour        &lt;&lt; &quot;:&quot; &lt;&lt; lt.tm_min      &lt;&lt; &quot;:&quot; &lt;&lt; lt.tm_sec;
</FONT></I>
    <I><FONT COLOR="#B22222">//The presently-preferred way. Fixed-width numbers with a simple separator for the human.
</FONT></I>    <I><FONT COLOR="#B22222">//Format: `date +%Y%m%d-%H%M%S` or &quot;YearMonthDay-HourMinuteSecond&quot;. Example: &quot;20131105-130535&quot;
</FONT></I>    ss &lt;&lt; (lt.tm_year + 1900);
    ss &lt;&lt; ((lt.tm_mon + 1) &lt; 10 ? <B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>) &lt;&lt; (lt.tm_mon + 1);
    ss &lt;&lt; (lt.tm_mday &lt; 10 ? <B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>) &lt;&lt; lt.tm_mday &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>;
    ss &lt;&lt; (lt.tm_hour &lt; 10 ? <B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>) &lt;&lt; lt.tm_hour;
    ss &lt;&lt; (lt.tm_min &lt; 10 ? <B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>) &lt;&lt; lt.tm_min;
    ss &lt;&lt; (lt.tm_sec &lt; 10 ? <B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>) &lt;&lt; lt.tm_sec;
    <B><FONT COLOR="#A020F0">return</FONT></B> ss.str();
}

<I><FONT COLOR="#B22222">//This routine is used in this-&gt;Read_from_string(...). It properly handles a fixed-width
</FONT></I><I><FONT COLOR="#B22222">// scheme, like where 'Jan. 25th, 2014 - 1:01:01 am' is represented as: '20140125-010101'.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//Returns true iff the string held a date/time in the afformentioned format (and nothing
</FONT></I><I><FONT COLOR="#B22222">// else). 
</FONT></I><B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Glean_date_time_from_string</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in, <B><FONT COLOR="#228B22">struct</FONT></B> tm *ttm){
    <B><FONT COLOR="#A020F0">if</FONT></B>(ttm == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Passed in an invalid struct tm pointer. This is a programming error&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(in.size() != 15) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//Fixed-width!
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string shtl;

    <I><FONT COLOR="#B22222">//Set the unused (or possibly irrelevant/unknown) flags to -1, as per:
</FONT></I>    <I><FONT COLOR="#B22222">// &quot;The mktime function converts the broken-down time, expressed as local time, in
</FONT></I>    <I><FONT COLOR="#B22222">//  the structure pointed to by timeptr into a calendar time value with the same
</FONT></I>    <I><FONT COLOR="#B22222">//  encoding as that of the values returned by the time function. The original
</FONT></I>    <I><FONT COLOR="#B22222">//  values of the tm_wday and tm_yday components of the structure are ignored, and
</FONT></I>    <I><FONT COLOR="#B22222">//  the original values of the other components are not restricted to the ranges
</FONT></I>    <I><FONT COLOR="#B22222">//  indicated above. On successful completion, the values of the tm_wday and
</FONT></I>    <I><FONT COLOR="#B22222">//  tm_yday components of the structure are set appropriately, and the other
</FONT></I>    <I><FONT COLOR="#B22222">//  components are set to represent the specified calendar time, but with their
</FONT></I>    <I><FONT COLOR="#B22222">//  values forced to the ranges indicated above; the final value of tm_mdayis not
</FONT></I>    <I><FONT COLOR="#B22222">//  set until tm_mon and tm_year are determined.&quot;
</FONT></I>    ttm-&gt;tm_isdst = ttm-&gt;tm_wday = ttm-&gt;tm_yday = -1;

    <I><FONT COLOR="#B22222">//Substrings:
</FONT></I>    <I><FONT COLOR="#B22222">// Sample string:  `2  0  1  4  0  1  2  5  -  1  2  3  4   5  6'
</FONT></I>    <I><FONT COLOR="#B22222">// Character num:   0  1  2  3  4  5  6  7  8  9 10  11 12  13 14
</FONT></I>    <I><FONT COLOR="#B22222">//                  ----------  ----  ----     ----  -----  -----
</FONT></I>    <I><FONT COLOR="#B22222">//                      Y        M     D        H     M     S
</FONT></I>
    shtl = in.substr(0,4);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!Is_String_An_X&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    ttm-&gt;tm_year = (stringtoX&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl) - 1900);
    shtl = Remove_Preceeding_Chars(in.substr(4,2),<B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!Is_String_An_X&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    ttm-&gt;tm_mon = (stringtoX&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl) - 1);
    shtl = Remove_Preceeding_Chars(in.substr(6,2),<B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!Is_String_An_X&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    ttm-&gt;tm_mday = stringtoX&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl);

    <B><FONT COLOR="#A020F0">if</FONT></B>(in.substr(8,1) != <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B> false;

    shtl = Remove_Preceeding_Chars(in.substr(9,2),<B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!Is_String_An_X&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    ttm-&gt;tm_hour = stringtoX&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl);
    shtl = Remove_Preceeding_Chars(in.substr(11,2),<B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!Is_String_An_X&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    ttm-&gt;tm_min = stringtoX&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl);
    shtl = Remove_Preceeding_Chars(in.substr(13,2),<B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!Is_String_An_X&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    ttm-&gt;tm_sec = stringtoX&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(shtl);

    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}


<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">time_mark::Read_from_string</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;in){
    <B><FONT COLOR="#228B22">struct</FONT></B> tm lt;
    lt.tm_year = lt.tm_mon = lt.tm_mday = lt.tm_hour = lt.tm_min = lt.tm_sec = -1;

    <I><FONT COLOR="#B22222">//We also make sure no other struct members remain untouched. This caused an annoying
</FONT></I>    <I><FONT COLOR="#B22222">// bug which altered read times during the call to mktime(...).
</FONT></I>    lt.tm_isdst = -1; <I><FONT COLOR="#B22222">//Indicates that info about daylight saving's time should be looked up during mktime(...) call.
</FONT></I>    lt.tm_wday = lt.tm_yday = -1; <I><FONT COLOR="#B22222">//Stores the day of the week and day of the year.
</FONT></I>
    <I><FONT COLOR="#B22222">//The fixed-width format, like: '20140125-012345'. 
</FONT></I>    <I><FONT COLOR="#B22222">// date '+%Y%m%_d-%_H%_M%_S'
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(Glean_date_time_from_string(in,&amp;lt)){
        <I><FONT COLOR="#B22222">//Spit it out.
</FONT></I>        <I><FONT COLOR="#B22222">//FUNCINFO(&quot;Y=&quot; &lt;&lt; lt.tm_year+1900 &lt;&lt; &quot;, M=&quot; &lt;&lt; lt.tm_mon+1 &lt;&lt; &quot;, D=&quot; &lt;&lt; lt.tm_mday &lt;&lt; &quot;, H=&quot; &lt;&lt; lt.tm_hour &lt;&lt; &quot;, m=&quot; &lt;&lt; lt.tm_min &lt;&lt; &quot;, S=&quot; &lt;&lt; lt.tm_sec);
</FONT></I>
    <I><FONT COLOR="#B22222">//The preferred format: `date +%Y%m%d-%H%M%S` or &quot;YearMonthDay-HourMinuteSecond&quot;. Example: &quot;20131105-130535&quot;
</FONT></I>    <I><FONT COLOR="#B22222">// Note: that strptime has a lot of trouble with preceeding '0's! It will not properly handle fixed-width
</FONT></I>    <I><FONT COLOR="#B22222">//       date and time!
</FONT></I>    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(strptime(in.c_str(), <B><FONT COLOR="#BC8F8F">&quot;%Y%m%d-%H%M%S&quot;</FONT></B>, &amp;lt) != nullptr){
        <I><FONT COLOR="#B22222">//Spit it out.
</FONT></I>        <I><FONT COLOR="#B22222">//FUNCINFO(&quot;Y=&quot; &lt;&lt; lt.tm_year+1900 &lt;&lt; &quot;, M=&quot; &lt;&lt; lt.tm_mon+1 &lt;&lt; &quot;, D=&quot; &lt;&lt; lt.tm_mday &lt;&lt; &quot;, H=&quot; &lt;&lt; lt.tm_hour &lt;&lt; &quot;, m=&quot; &lt;&lt; lt.tm_min &lt;&lt; &quot;, S=&quot; &lt;&lt; lt.tm_sec);
</FONT></I>
<I><FONT COLOR="#B22222">//    //Works fine, but only handles the preferential format (nothing extra).
</FONT></I><I><FONT COLOR="#B22222">//    const auto nums = GetAllRegex2(in, &quot;([0-9]{2,4})[/]([0-9]{1,2})[/]([0-9]{1,2})[-]([0-9]{1,2})[:]([0-9]{1,2})[:]([0-9]{1,2})&quot;);
</FONT></I><I><FONT COLOR="#B22222">//    if(nums.size() == 6){
</FONT></I><I><FONT COLOR="#B22222">//        lt.tm_year = Is_String_An_X&lt;int&gt;(nums[0]) ? (stringtoX&lt;int&gt;(nums[0]) - 1900) : -1;
</FONT></I><I><FONT COLOR="#B22222">//        lt.tm_mon  = Is_String_An_X&lt;int&gt;(nums[1]) ? (stringtoX&lt;int&gt;(nums[1]) - 1)    : -1;
</FONT></I><I><FONT COLOR="#B22222">//        lt.tm_mday = Is_String_An_X&lt;int&gt;(nums[2]) ?  stringtoX&lt;int&gt;(nums[2])         : -1;
</FONT></I><I><FONT COLOR="#B22222">//        lt.tm_hour = Is_String_An_X&lt;int&gt;(nums[3]) ?  stringtoX&lt;int&gt;(nums[3])         : -1;
</FONT></I><I><FONT COLOR="#B22222">//        lt.tm_min  = Is_String_An_X&lt;int&gt;(nums[4]) ?  stringtoX&lt;int&gt;(nums[4])         : -1;
</FONT></I><I><FONT COLOR="#B22222">//        lt.tm_sec  = Is_String_An_X&lt;int&gt;(nums[5]) ?  stringtoX&lt;int&gt;(nums[5])         : -1;
</FONT></I>
    <I><FONT COLOR="#B22222">//The previously preferred format: `date +%Y\/%m\/%d-%H:%M:%S`. Regex for matching it: 
</FONT></I>    <I><FONT COLOR="#B22222">// ([0-9]{2,4})[/]([0-9]{1,2})[/]([0-9]{1,2})[-]([0-9]{1,2})[:]([0-9]{1,2})[:]([0-9]{1,2})
</FONT></I>    <I><FONT COLOR="#B22222">// Example: '2013/07/16-21:19:13'
</FONT></I>    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(strptime(in.c_str(), <B><FONT COLOR="#BC8F8F">&quot;%Y/%m/%d-%H:%M:%S&quot;</FONT></B>, &amp;lt) != nullptr){ <I><FONT COLOR="#B22222">//NOTE: Does not handle month or day = '0'...
</FONT></I>        <I><FONT COLOR="#B22222">//Worked.
</FONT></I>
    <I><FONT COLOR="#B22222">//The style of Salivary Flow measurement data. Format: '17-Mar-2009' There is no time info here.
</FONT></I>    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(strptime(in.c_str(), <B><FONT COLOR="#BC8F8F">&quot;%d-%b-%Y&quot;</FONT></B>, &amp;lt) != nullptr){
        <I><FONT COLOR="#B22222">//Worked.
</FONT></I>        lt.tm_hour = lt.tm_min = lt.tm_sec = 0;

    <I><FONT COLOR="#B22222">//The format used as an example in the strpcopy manual. Seems nice enough...
</FONT></I>    <I><FONT COLOR="#B22222">// Example: '6 Dec 2001 12:33:45'
</FONT></I>    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(strptime(in.c_str(), <B><FONT COLOR="#BC8F8F">&quot;%d %b %Y %H:%M:%S&quot;</FONT></B>, &amp;lt) != nullptr){
        <I><FONT COLOR="#B22222">//Worked.
</FONT></I>

    <I><FONT COLOR="#B22222">//}else if( ....        &lt;---add more here. Consider just piping to shell to use GNU date, which handles all sorts of neat formats automagically...
</FONT></I>    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        <I><FONT COLOR="#B22222">//Error - did not understand format...
</FONT></I>        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Could not make sense of the stringified date/time&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <I><FONT COLOR="#B22222">//Verify no parameter has been left unset.   
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>((lt.tm_year == -1) || (lt.tm_mon == -1) || (lt.tm_mday == -1) || (lt.tm_hour == -1) || (lt.tm_min == -1) || (lt.tm_sec == -1)){
        FUNCWARN(<B><FONT COLOR="#BC8F8F">&quot;Time string reading failed for some unknown reason. Perhaps the string parsed but wasn't a valid date?&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When = mktime(&amp;lt);
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When == -1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

time_mark &amp; time_mark::<B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;rhs){
    <B><FONT COLOR="#A020F0">if</FONT></B>(<B><FONT COLOR="#A020F0">this</FONT></B> == &amp;rhs) <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When = rhs.When;
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
}
<B><FONT COLOR="#228B22">bool</FONT></B> time_mark::<B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When == rhs.When);
}
<B><FONT COLOR="#228B22">bool</FONT></B> time_mark::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When &lt; rhs.When);
}
<B><FONT COLOR="#228B22">bool</FONT></B> time_mark::<B><FONT COLOR="#A020F0">operator</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When &gt; rhs.When);
}
<B><FONT COLOR="#228B22">bool</FONT></B> time_mark::<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;=(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When &lt;= rhs.When);
}
<B><FONT COLOR="#228B22">bool</FONT></B> time_mark::<B><FONT COLOR="#A020F0">operator</FONT></B>&gt;=(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When &gt;= rhs.When);
}

time_mark <B><FONT COLOR="#0000FF">time_mark::One_Day_Earlier_Than</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;T) <B><FONT COLOR="#228B22">const</FONT></B> {
    time_mark out(T);
    out.When -= 24*60*60; 
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
time_mark <B><FONT COLOR="#0000FF">time_mark::One_Day_Later_Than</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;T) <B><FONT COLOR="#228B22">const</FONT></B> { 
    time_mark out(T);
    out.When += 24*60*60;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

time_mark <B><FONT COLOR="#0000FF">time_mark::Less_By_Seconds</FONT></B>(int64_t dt) <B><FONT COLOR="#228B22">const</FONT></B> {
    time_mark out(*<B><FONT COLOR="#A020F0">this</FONT></B>);
    out.When -= dt;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
time_mark <B><FONT COLOR="#0000FF">time_mark::More_By_Seconds</FONT></B>(int64_t dt) <B><FONT COLOR="#228B22">const</FONT></B> {
    time_mark out(*<B><FONT COLOR="#A020F0">this</FONT></B>);
    out.When += dt;
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

<I><FONT COLOR="#B22222">//Earliest time_mark occuring on the same day.
</FONT></I>time_mark <B><FONT COLOR="#0000FF">time_mark::Same_Day_Earliest</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    time_mark out(*<B><FONT COLOR="#A020F0">this</FONT></B>);
    <B><FONT COLOR="#228B22">struct</FONT></B> tm A;
    <B><FONT COLOR="#A020F0">if</FONT></B>(localtime_r(&amp;out.When, &amp;A) == nullptr){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;localtime_r produced an error - unable to continue&quot;</FONT></B>)
    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((A.tm_year == -1) || (A.tm_mon == -1) || (A.tm_mday == -1)
          || (A.tm_hour == -1) || (A.tm_min == -1) || (A.tm_sec  == -1) ){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Cannot determine earliest same-day time from input&quot;</FONT></B>);
    }

    <I><FONT COLOR="#B22222">//Set the hour and minutes to their minimum value.
</FONT></I>    A.tm_hour = 0;
    A.tm_min  = 0;
    A.tm_sec  = 0;

    out.When = mktime(&amp;A);
    <B><FONT COLOR="#A020F0">if</FONT></B>(out.When == -1){
        FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;Could not produce the earliest same-day time for unknown reasons&quot;</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

time_mark <B><FONT COLOR="#0000FF">time_mark::Same_Day_Latest</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    time_mark out(*<B><FONT COLOR="#A020F0">this</FONT></B>);
    out.Advance_One_Day();
    out = out.Same_Day_Earliest();
    out.Regress_By_Seconds(1);
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">time_mark::Regress_One_Day</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){ <I><FONT COLOR="#B22222">//aka &quot;rewind&quot;
</FONT></I>    *<B><FONT COLOR="#A020F0">this</FONT></B> = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;One_Day_Earlier_Than(*<B><FONT COLOR="#A020F0">this</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">time_mark::Advance_One_Day</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>){
    *<B><FONT COLOR="#A020F0">this</FONT></B> = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;One_Day_Later_Than(*<B><FONT COLOR="#A020F0">this</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">time_mark::Regress_By_Seconds</FONT></B>(int64_t dt){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When -= static_cast&lt;time_t&gt;(dt);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">time_mark::Advance_By_Seconds</FONT></B>(int64_t dt){
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When += static_cast&lt;time_t&gt;(dt);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
}


<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">time_mark::Is_within_X_seconds</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;in, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> X) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> A = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> B = static_cast&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(in.When);
    <B><FONT COLOR="#A020F0">return</FONT></B> (YGORABS(A - B) &lt;= X);
}

time_t <B><FONT COLOR="#0000FF">time_mark::Diff_in_Seconds</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Returns:  (in.sec - this-&gt;sec). If input is further in the future, result will be positive.
</FONT></I>    <I><FONT COLOR="#B22222">//Note: This difference does not include fractional seconds. It has resolution of 1s.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> in.When - <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When;
}
time_t <B><FONT COLOR="#0000FF">time_mark::Diff_in_Days</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {
    <I><FONT COLOR="#B22222">//Returns:  (in.days - this-&gt;days). If input is further in the future, result will be positive.
</FONT></I>    <I><FONT COLOR="#B22222">//Note: This difference does not include fractional days. It has resolution of 1day.
</FONT></I><I><FONT COLOR="#B22222">/*
    struct tm A,B;
    if(localtime_r(&amp;this-&gt;When, &amp;A) == nullptr) FUNCERR(&quot;localtime_r produced an error - unable to continue&quot;)
    if(localtime_r(&amp;in.When, &amp;B)    == nullptr) FUNCERR(&quot;localtime_r produced an error - unable to continue&quot;)
    if((A.tm_mday == -1) || (B.tm_mday == -1)) return false; //Error in the data.
    return B.tm_mday - A.tm_mday;
*/</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> dsec = static_cast&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Diff_in_Seconds(in));
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> spd  = 60.0*60.0*24.0; <I><FONT COLOR="#B22222">//&quot;Seconds per day&quot;
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> static_cast&lt;time_t&gt;(dsec/spd);
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">time_mark::Have_same_day</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> {  <I><FONT COLOR="#B22222">//Compares ONLY the day (the number) - not the year, month, etc..
</FONT></I>    <B><FONT COLOR="#228B22">struct</FONT></B> tm A,B;
    <B><FONT COLOR="#A020F0">if</FONT></B>(localtime_r(&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When, &amp;A) == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;localtime_r produced an error - unable to continue&quot;</FONT></B>)
    <B><FONT COLOR="#A020F0">if</FONT></B>(localtime_r(&amp;in.When, &amp;B)    == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;localtime_r produced an error - unable to continue&quot;</FONT></B>)
    <B><FONT COLOR="#A020F0">if</FONT></B>((A.tm_mday == -1) || (B.tm_mday == -1)) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//Error in the data.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> A.tm_mday == B.tm_mday;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">time_mark::Occur_on_same_day</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> time_mark &amp;in) <B><FONT COLOR="#228B22">const</FONT></B> { 
    <B><FONT COLOR="#228B22">struct</FONT></B> tm A,B;
    <B><FONT COLOR="#A020F0">if</FONT></B>(localtime_r(&amp;<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;When, &amp;A) == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;localtime_r produced an error - unable to continue&quot;</FONT></B>)
    <B><FONT COLOR="#A020F0">if</FONT></B>(localtime_r(&amp;in.When, &amp;B)    == nullptr) FUNCERR(<B><FONT COLOR="#BC8F8F">&quot;localtime_r produced an error - unable to continue&quot;</FONT></B>)

    <B><FONT COLOR="#A020F0">if</FONT></B>((A.tm_mday == -1) || (B.tm_mday == -1) 
       || (A.tm_mon == -1) || (B.tm_mon == -1)
       || (A.tm_year == -1) || (B.tm_year == -1) ) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">//Error in the data.
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> (A.tm_mday == B.tm_mday) &amp;&amp; (A.tm_mon == B.tm_mon) &amp;&amp; (A.tm_year == B.tm_year);
}



<I><FONT COLOR="#B22222">//Serialize (deeply) to buffer starting at *offset. Buffer can be nullptr or passed in, but 
</FONT></I><I><FONT COLOR="#B22222">// other params must be appropriately set (if applicable) and always NOT-nullptr. On 
</FONT></I><I><FONT COLOR="#B22222">// failure, *OK set to false.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Input:
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   - *OK       - Optional - Used to indicate success or failure. In absence, program is 
</FONT></I><I><FONT COLOR="#B22222">//                             terminated on failure.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   - *in       - Optional - If provided, serialization is deposited into buffer (starting
</FONT></I><I><FONT COLOR="#B22222">//                             at *offset), *offset is advanced to the back of the 
</FONT></I><I><FONT COLOR="#B22222">//                             serialized data, and *buf_size is treated as the maximum 
</FONT></I><I><FONT COLOR="#B22222">//                             size of the buffer (and is not altered).
</FONT></I><I><FONT COLOR="#B22222">//                             If not provided, an appropriate amount of space will be 
</FONT></I><I><FONT COLOR="#B22222">//                             allocated using the default allocator prior to serialization.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   - *offset   - Required - Used by the user to tell where to begin serialization (often
</FONT></I><I><FONT COLOR="#B22222">//                             at 0) and by this routine to tell the user where the next
</FONT></I><I><FONT COLOR="#B22222">//                             available byte is after serialization is complete.
</FONT></I><I><FONT COLOR="#B22222">//                             If &quot;in&quot; buffer is nullptr, *offset is set to 0 prior to
</FONT></I><I><FONT COLOR="#B22222">//                             serialization.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   - *buf_size - Required - If &quot;in&quot; buffer is non-nullptr, this must hold the number of
</FONT></I><I><FONT COLOR="#B22222">//                             allocated bytes, and it will not be altered. 
</FONT></I><I><FONT COLOR="#B22222">//                             If &quot;in&quot; buffer is nullptr, this will afterward hold the 
</FONT></I><I><FONT COLOR="#B22222">//                             number of allocated bytes (which may be &gt;= the amount of 
</FONT></I><I><FONT COLOR="#B22222">//                             data serialized).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The buffer may be larger than the serialized content, thus allowing many serialized 
</FONT></I><I><FONT COLOR="#B22222">// instances in one large buffer. The semantics of this are up to the user.
</FONT></I>std::unique_ptr&lt;uint8_t[]&gt; 
<B><FONT COLOR="#0000FF">time_mark::Serialize</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t *buf_size) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    SERIALIZE_WARNFAIL_OR_DIE((buf_size == nullptr), OK, <B><FONT COLOR="#BC8F8F">&quot;Passed an invalid *buf_size.&quot;</FONT></B>,std::move(in));
    SERIALIZE_WARNFAIL_OR_DIE((offset == nullptr), OK, <B><FONT COLOR="#BC8F8F">&quot;Passed an invalid *offset.&quot;</FONT></B>,std::move(in));

    <I><FONT COLOR="#B22222">//If the buffer is not yet allocated, allocate an appropriately-sized buffer.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(in == nullptr){
        *buf_size = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Theo_Max_Serialization_Size();
        in.reset( <B><FONT COLOR="#A020F0">new</FONT></B> uint8_t[ *buf_size ] );
        *offset = 0;
    }
    
    <B><FONT COLOR="#228B22">bool</FONT></B> l_OK;

    <I><FONT COLOR="#B22222">/*
    //------ &lt;Version 1 @ 20130905&gt; -------
    //Verify that the double representation is standard.
    l_OK = (std::numeric_limits&lt;double&gt;::is_iec559 &amp;&amp;
           (std::numeric_limits&lt;double&gt;::max_exponent == 1024) &amp;&amp;
           (std::numeric_limits&lt;double&gt;::digits == 53) &amp;&amp;
           (std::numeric_limits&lt;double&gt;::radix == 2));
    SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,&quot;Non-standard platform double representation.&quot;,std::move(in));

    //Version number.
    const uint64_t version = 1;
    in = SERIALIZE::Put_Size(&amp;l_OK,std::move(in),offset,*buf_size, version);
    SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,&quot;Unable to Put version.&quot;,std::move(in));

    //When.
    in = SERIALIZE::Put(&amp;l_OK,std::move(in),offset,*buf_size, this-&gt;When);
    SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,&quot;Unable to Put this-&gt;When.&quot;,std::move(in));
    //------ &lt;/Version 1 @ 20130905&gt; -------
    */</FONT></I>

    <I><FONT COLOR="#B22222">//------ &lt;Version 2 @ 20131017&gt; -------
</FONT></I>    <I><FONT COLOR="#B22222">//Verify that the double representation is standard.
</FONT></I>    l_OK = (std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::is_iec559 &amp;&amp;
           (std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::max_exponent == 1024) &amp;&amp;
           (std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::digits == 53) &amp;&amp;
           (std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::radix == 2));
    SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,<B><FONT COLOR="#BC8F8F">&quot;Non-standard platform double representation.&quot;</FONT></B>,std::move(in));

    <I><FONT COLOR="#B22222">//Version number.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> uint64_t version = 2;
    in = SERIALIZE::Put_Size(&amp;l_OK,std::move(in),offset,*buf_size, version);
    SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,<B><FONT COLOR="#BC8F8F">&quot;Unable to Put version.&quot;</FONT></B>,std::move(in));

    <I><FONT COLOR="#B22222">//When (in std::string format).
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> stringified = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Dump_as_string();
    in = SERIALIZE::Put(&amp;l_OK,std::move(in),offset,*buf_size, stringified);
    SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,<B><FONT COLOR="#BC8F8F">&quot;Unable to Put stringified this-&gt;When.&quot;</FONT></B>,std::move(in));
    <I><FONT COLOR="#B22222">//------ &lt;/Version 2 @ 20131017&gt; -------
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}

<I><FONT COLOR="#B22222">//Deserialize (deeply) from buffer starting at *offset. Contrary to the counterpart
</FONT></I><I><FONT COLOR="#B22222">// Serialize function, this function requires a valid buffer to deserialize from.
</FONT></I><I><FONT COLOR="#B22222">// Thus, all parameters (except *OK) are required.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//This routine will overwrite *this.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The buffer may be larger than the serialized content, thus allowing many 
</FONT></I><I><FONT COLOR="#B22222">// serialized instances in one large buffer. The semantics of this are up to the user.
</FONT></I><I><FONT COLOR="#B22222">// This routine will only deserialize the data beginning at *offset.
</FONT></I>std::unique_ptr&lt;uint8_t[]&gt; 
<B><FONT COLOR="#0000FF">time_mark::Deserialize</FONT></B>(<B><FONT COLOR="#228B22">bool</FONT></B> *OK, std::unique_ptr&lt;uint8_t[]&gt; in, uint64_t *offset, uint64_t buf_size){
    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = false;
    SERIALIZE_WARNFAIL_OR_DIE((offset == nullptr), OK, <B><FONT COLOR="#BC8F8F">&quot;Passed an invalid *offset.&quot;</FONT></B>,std::move(in));

    <B><FONT COLOR="#228B22">bool</FONT></B> l_OK;
    uint64_t version;
    in = SERIALIZE::Get_Size(&amp;l_OK,std::move(in),offset,buf_size, &amp;(version));
    SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,<B><FONT COLOR="#BC8F8F">&quot;Unable to Get version.&quot;</FONT></B>,std::move(in));

    <B><FONT COLOR="#A020F0">if</FONT></B>(version == 1){
        <I><FONT COLOR="#B22222">/*
        //------ &lt;Version 1 @ 20130905&gt; -------
        //Verify that the double representation is standard.
        l_OK = (std::numeric_limits&lt;double&gt;::is_iec559 &amp;&amp;
               (std::numeric_limits&lt;double&gt;::max_exponent == 1024) &amp;&amp;
               (std::numeric_limits&lt;double&gt;::digits == 53) &amp;&amp;
               (std::numeric_limits&lt;double&gt;::radix == 2));
        SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,&quot;Non-standard platform double representation.&quot;,std::move(in));
        //When. This version uses raw std::time_t. Bad: different on 32 and 64 bit test machines.
        in = SERIALIZE::Get(&amp;l_OK,std::move(in),offset,buf_size, &amp;(this-&gt;When));
        SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,&quot;Unable to Get this-&gt;When.&quot;,std::move(in));
        //------ &lt;/Version 1 @ 20130905&gt; -------
        */</FONT></I>
        l_OK = false;
        SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,<B><FONT COLOR="#BC8F8F">&quot;Can't handle v1 serialization. Functionality was removed.&quot;</FONT></B>,std::move(in));

    }<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(version == 2){
        <I><FONT COLOR="#B22222">//------ &lt;Version 2 @ 20131017&gt; -------
</FONT></I>        <I><FONT COLOR="#B22222">//Verify that the double representation is standard.
</FONT></I>        l_OK = (std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::is_iec559 &amp;&amp;
               (std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::max_exponent == 1024) &amp;&amp;
               (std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::digits == 53) &amp;&amp;
               (std::numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::radix == 2));
        SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,<B><FONT COLOR="#BC8F8F">&quot;Non-standard platform double representation.&quot;</FONT></B>,std::move(in));

        <I><FONT COLOR="#B22222">//When (in std::string format).
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string stringified;
        in = SERIALIZE::Get(&amp;l_OK,std::move(in),offset,buf_size, &amp;stringified);
        SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,<B><FONT COLOR="#BC8F8F">&quot;Unable to Get stringified this-&gt;When.&quot;</FONT></B>,std::move(in));

        l_OK = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;Read_from_string(stringified);
        SERIALIZE_WARNFAIL_OR_DIE(!l_OK,OK,<B><FONT COLOR="#BC8F8F">&quot;Unable to interpret stringified this-&gt;When as valid date.&quot;</FONT></B>,std::move(in));
        <I><FONT COLOR="#B22222">//------ &lt;/Version 2 @ 20131017&gt; -------
</FONT></I>
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
        SERIALIZE_WARNFAIL_OR_DIE(false,OK,<B><FONT COLOR="#BC8F8F">&quot;Version not recognized.&quot;</FONT></B>,std::move(in));
    }

    <B><FONT COLOR="#A020F0">if</FONT></B>(OK != nullptr) *OK = true;
    <B><FONT COLOR="#A020F0">return</FONT></B> std::move(in);
}

<I><FONT COLOR="#B22222">//Returns the (maximum) number of bytes required to serialize *this (at this moment).
</FONT></I><I><FONT COLOR="#B22222">// Alteration of *any* of the members will probably void the estimate. Re-compute if 
</FONT></I><I><FONT COLOR="#B22222">// uncertain.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//This procedure depends strongly on the serialization procedure. Remember to keep it 
</FONT></I><I><FONT COLOR="#B22222">// up to date and versioned!
</FONT></I>uint64_t <B><FONT COLOR="#0000FF">time_mark::Theo_Max_Serialization_Size</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
    uint64_t max_tot_size = 0;
    <I><FONT COLOR="#B22222">/*
    //------ &lt;Version 1.0 @ 20130905&gt; -------
    max_tot_size += SERIALIZE::max_vw_size; //Version stamp. 
    max_tot_size += sizeof(std::time_t); //Raw this-&gt;When value. 
    //------ &lt;/Version 1.0 @ 20130905&gt; -------
    */</FONT></I>
    <I><FONT COLOR="#B22222">//------ &lt;Version 2 @ 20131017&gt; -------
</FONT></I>    max_tot_size += SERIALIZE::max_vw_size; <I><FONT COLOR="#B22222">//Version stamp. 
</FONT></I>    max_tot_size += 15; <I><FONT COLOR="#B22222">//Size of stringified this-&gt;When. 
</FONT></I>    <I><FONT COLOR="#B22222">//------ &lt;/Version 2 @ 20131017&gt; -------
</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> max_tot_size;
}

</PRE>
<HR>
<A NAME="file40">
<H1>YgorURITools.cc 40/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file39">prev</A>][<A HREF="#file41">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//YgorURITools.cc - A collection of &quot;shaky-at-best&quot; routines for doing common things with URI's/URL's.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorURITools.h&quot;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htmlcxx/html/ParserDom.h&quot;</FONT></B>


std::string Request_URL(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;url){
    <I><FONT COLOR="#B22222">//std::string cmd = &quot;wget --quiet  --convert-links --level=1 --no-cache &quot;_s;
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string cmd = <B><FONT COLOR="#BC8F8F">&quot;wget --quiet                  --level=1 --no-cache &quot;</FONT></B>_s;
    cmd += <B><FONT COLOR="#BC8F8F">&quot; --user-agent=&quot;</FONT></B>_s;
    cmd += Quote_Static_for_Bash(<B><FONT COLOR="#BC8F8F">&quot;Mozilla/5.0 (X11; Linux i686) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;</FONT></B>);
    cmd += <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>_s + Quote_Static_for_Bash(url) + <B><FONT COLOR="#BC8F8F">&quot; -O - &quot;</FONT></B>_s;
    <B><FONT COLOR="#A020F0">return</FONT></B> Execute_Command_In_Pipe(cmd);
}



<I><FONT COLOR="#B22222">//This is a helper function for the htmlcxx library. Originally found at 
</FONT></I><I><FONT COLOR="#B22222">// http://stackoverflow.com/questions/5081181/htmlcxx-c-crawling-html?rq=1 on September 1st, 2012,
</FONT></I><I><FONT COLOR="#B22222">// this version is modified to recursively get the text from ALL child nodes.
</FONT></I><B><FONT COLOR="#228B22">static</FONT></B> std::string get_child_content(tree&lt;htmlcxx::HTML::Node&gt; <B><FONT COLOR="#228B22">const</FONT></B> &amp;dom, tree&lt;htmlcxx::HTML::Node&gt;::iterator <B><FONT COLOR="#228B22">const</FONT></B> &amp;parent){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string result;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">unsigned</FONT></B> i=0; i&lt;dom.number_of_children(parent); i++ ){
        <B><FONT COLOR="#228B22">auto</FONT></B> it = dom.child(parent,i);
        <B><FONT COLOR="#A020F0">if</FONT></B>(!it-&gt;isTag() &amp;&amp; !it-&gt;isComment()){
            result += it-&gt;text();
<I><FONT COLOR="#B22222">//-----------------------
</FONT></I><I><FONT COLOR="#B22222">//Modified part.
</FONT></I><I><FONT COLOR="#B22222">//        }
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            result += get_child_content(dom, it);
        }
<I><FONT COLOR="#B22222">//-----------------------
</FONT></I>
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> result;
}


<I><FONT COLOR="#B22222">//Pull all links from an HTML string. Each link is accompanied with the raw text found between the tags.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This will NOT pull all URL's from HTML - only bonafide links (which are in valid &lt;A HREF=&quot;...&quot;&gt;
</FONT></I><I><FONT COLOR="#B22222">// tags.) For getting SRC=&quot;...&quot; urls, use the Get_All_Tag_Attributes() below.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: This is a specialization of the more general routine Get_Tags_Attributes(....).
</FONT></I>std::list&lt;std::pair&lt;std::string, std::string&gt; &gt; Get_Links(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;source){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt; &gt; out;

    <I><FONT COLOR="#B22222">//Parse the page.
</FONT></I>    <B><FONT COLOR="#5F9EA0">htmlcxx</FONT></B>::HTML::ParserDom parser;
    <B><FONT COLOR="#228B22">auto</FONT></B> dom = parser.parseTree(source);

    <I><FONT COLOR="#B22222">//Cycle through the tree of nodes and dump all links.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = dom.begin(); it != dom.end(); ++it){

        <I><FONT COLOR="#B22222">//Check if the tag is an &lt;a href=&quot;...&quot;&gt; -like tag.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>((it-&gt;isTag()) &amp;&amp; (strcasecmp(it-&gt;tagName().c_str(), <B><FONT COLOR="#BC8F8F">&quot;A&quot;</FONT></B>) == 0)){
            it-&gt;parseAttributes();
            <B><FONT COLOR="#228B22">const</FONT></B> std::string thelink = it-&gt;attribute(<B><FONT COLOR="#BC8F8F">&quot;href&quot;</FONT></B>).second;
            <B><FONT COLOR="#228B22">const</FONT></B> std::string thetext = get_child_content(dom, it);
 
            <B><FONT COLOR="#A020F0">if</FONT></B>(!thelink.empty()){
                out.push_back( { thelink, thetext } );
            }
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}



<I><FONT COLOR="#B22222">//Pull all given tags' attributes from an HTML string. Each link is accompanied with the raw text found within the tag.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: The terminology 'tag', 'attribute', and 'text' mean:
</FONT></I><I><FONT COLOR="#B22222">//              ... &lt; TAG ... ATTR=&quot;...&quot; ...&gt;   TEXT  &lt;/TAG&gt;
</FONT></I><I><FONT COLOR="#B22222">// for which we will return:        ^^^   and   ^^^^. 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//NOTE: Leave &quot;tag&quot; empty to match all tags.
</FONT></I>std::list&lt;std::pair&lt;std::string, std::string&gt; &gt; Get_Tags_Attributes(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;source, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;tag, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;attr){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt; &gt; out;

    <I><FONT COLOR="#B22222">//Parse the page.
</FONT></I>    <B><FONT COLOR="#5F9EA0">htmlcxx</FONT></B>::HTML::ParserDom parser;
    <B><FONT COLOR="#228B22">auto</FONT></B> dom = parser.parseTree(source);

    <I><FONT COLOR="#B22222">//Cycle through the tree of nodes and dump all links.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = dom.begin(); it != dom.end(); ++it){

        <I><FONT COLOR="#B22222">//Check if the tag matches.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>((it-&gt;isTag()) &amp;&amp;  (tag.empty() || (strcasecmp(it-&gt;tagName().c_str(), tag.c_str()) == 0)) ){
            it-&gt;parseAttributes();
            <B><FONT COLOR="#228B22">const</FONT></B> std::string theattr = it-&gt;attribute(attr.c_str() ).second;
            <B><FONT COLOR="#228B22">const</FONT></B> std::string thetext = get_child_content(dom, it);

            <I><FONT COLOR="#B22222">//NOTE: Some tags may not contain any text. Do not filter on absence of text!
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(!theattr.empty()){
                out.push_back( { theattr, thetext } );
            }
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<I><FONT COLOR="#B22222">//Clean up links by attempting to decode URL-encodings and inserting a base name for relative links.
</FONT></I>std::list&lt;std::pair&lt;std::string, std::string&gt; &gt; Clean_Links(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::pair&lt;std::string, std::string&gt; &gt; &amp;thelinks, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;base){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt; &gt; fixedlinks;

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> up_it = thelinks.begin(); up_it != thelinks.end(); ++up_it){

        <I><FONT COLOR="#B22222">//The link is the first element, the text is the second.
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string thelink = up_it-&gt;first;
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string thetext = up_it-&gt;second;

        <I><FONT COLOR="#B22222">//Attempt to convert URL-encoded links to their original.
</FONT></I>        thelink = Basic_Decode_URL(thelink);
        <B><FONT COLOR="#A020F0">if</FONT></B>(thelink.empty()) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        thetext = Basic_Decode_URL(thetext);

        <I><FONT COLOR="#B22222">//Attempt to convert links to absolute form.
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B>((thelink[0] == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>) || (thelink[0] == <B><FONT COLOR="#BC8F8F">'#'</FONT></B>) || (thelink[0] == <B><FONT COLOR="#BC8F8F">'?'</FONT></B>)){
            thelink = base + thelink;

        <I><FONT COLOR="#B22222">//Otherwise it is probably an absolute link.
</FONT></I>        }<B><FONT COLOR="#A020F0">else</FONT></B>{
            <I><FONT COLOR="#B22222">//Do nothing?
</FONT></I>        }

        <I><FONT COLOR="#B22222">//Push back the link.
</FONT></I>        fixedlinks.push_back( { thelink, thetext } );
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> fixedlinks;
}

<I><FONT COLOR="#B22222">//Remove duplicate links. Prefer those links with non-empty descriptions, but otherwise remove the first.
</FONT></I>std::list&lt;std::pair&lt;std::string, std::string&gt;&gt; Remove_Duplicate_Links(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::pair&lt;std::string, std::string&gt;&gt; &amp;thelinks){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string,std::string&gt;&gt; out(thelinks);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it = ++(out.begin()); it != out.end();   ){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> it2 = out.begin(); it2 != it;   ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(it-&gt;first == it2-&gt;first){
                <B><FONT COLOR="#A020F0">if</FONT></B>(!(it-&gt;second.empty())){
                    it2 = out.erase(it2);
                }<B><FONT COLOR="#A020F0">else</FONT></B>{
                    it = out.erase(it);
                    --it; <I><FONT COLOR="#B22222">//Go back so we can continue checking this duplicate.
</FONT></I>                }
            }<B><FONT COLOR="#A020F0">else</FONT></B>{
                ++it2;
            }
        }
        ++it;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<I><FONT COLOR="#B22222">//Filter links based on two regex criteria (one for the links, one for the text.)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//To omit a criteria, simply send an empty string.
</FONT></I>std::list&lt;std::pair&lt;std::string, std::string&gt; &gt; Filter_Whitelist_Links(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::pair&lt;std::string, std::string&gt; &gt; &amp;thelinks, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;link_regex, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;text_regex){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt; &gt; out;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> up_it = thelinks.begin(); up_it != thelinks.end(); ++up_it){
        <I><FONT COLOR="#B22222">//The link is the first element, the text is the second.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> std::string thelink = up_it-&gt;first;
        <B><FONT COLOR="#228B22">const</FONT></B> std::string thetext = up_it-&gt;second;
        <B><FONT COLOR="#A020F0">if</FONT></B>(!link_regex.empty() &amp;&amp; (GetFirstRegex(thelink, link_regex)).empty()) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>(!text_regex.empty() &amp;&amp; (GetFirstRegex(thetext, text_regex)).empty()) <B><FONT COLOR="#A020F0">continue</FONT></B>;

        <I><FONT COLOR="#B22222">//Push back the link.
</FONT></I>        out.push_back( { thelink, thetext } );
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

std::list&lt;std::pair&lt;std::string, std::string&gt; &gt; Filter_Blacklist_Links(<B><FONT COLOR="#228B22">const</FONT></B> std::list&lt;std::pair&lt;std::string, std::string&gt; &gt; &amp;thelinks, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;link_regex, <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;text_regex){
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::list&lt;std::pair&lt;std::string, std::string&gt; &gt; out;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> up_it = thelinks.begin(); up_it != thelinks.end(); ++up_it){
        <I><FONT COLOR="#B22222">//The link is the first element, the text is the second.
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> std::string thelink = up_it-&gt;first;
        <B><FONT COLOR="#228B22">const</FONT></B> std::string thetext = up_it-&gt;second;
        <B><FONT COLOR="#A020F0">if</FONT></B>(!link_regex.empty() &amp;&amp; !(GetFirstRegex(thelink, link_regex)).empty()) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>(!text_regex.empty() &amp;&amp; !(GetFirstRegex(thetext, text_regex)).empty()) <B><FONT COLOR="#A020F0">continue</FONT></B>;

        <I><FONT COLOR="#B22222">//Push back the link.
</FONT></I>        out.push_back( { thelink, thetext } );
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}


<I><FONT COLOR="#B22222">//Attempt to guess a (reasonable) mime type. The goal is to only implement things I need!
</FONT></I>std::string Guess_Mime_Type(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename){
    <I><FONT COLOR="#B22222">//Some simple ones. These *could* be removed if desired, but are probably beneficial to have around.
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!GetFirstRegex(filename, R<B><FONT COLOR="#BC8F8F">&quot;***([.][cC][sS][sS]$)***&quot;</FONT></B>).empty()) <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;text/css&quot;</FONT></B>;    
    <B><FONT COLOR="#A020F0">if</FONT></B>(!GetFirstRegex(filename, R<B><FONT COLOR="#BC8F8F">&quot;***([.][cC][sS][vV]$)***&quot;</FONT></B>).empty()) <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;text/csv&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!GetFirstRegex(filename, R<B><FONT COLOR="#BC8F8F">&quot;***([.][hH][tT][mM][lL]$)***&quot;</FONT></B>).empty()) <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;text/html&quot;</FONT></B>;

    <B><FONT COLOR="#A020F0">if</FONT></B>(!GetFirstRegex(filename, R<B><FONT COLOR="#BC8F8F">&quot;***([.][jJ][sS]$)***&quot;</FONT></B>).empty()) <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;application/javascript&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B>(!GetFirstRegex(filename, R<B><FONT COLOR="#BC8F8F">&quot;***([.][gG][zZ]$)***&quot;</FONT></B>).empty()) <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;application/gzip&quot;</FONT></B>;

    <B><FONT COLOR="#A020F0">if</FONT></B>(!GetFirstRegex(filename, R<B><FONT COLOR="#BC8F8F">&quot;***([.][mM][pP]4$)***&quot;</FONT></B>).empty()) <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;application/mp4&quot;</FONT></B>;


    <I><FONT COLOR="#B22222">// ...
</FONT></I>
    <I><FONT COLOR="#B22222">//Appeal to a higher authority.
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> std::string out = Execute_Command_In_Pipe(<B><FONT COLOR="#BC8F8F">&quot; file -b --mime-type -- &quot;</FONT></B>_s + Quote_Static_for_Bash(filename) + <B><FONT COLOR="#BC8F8F">&quot; | tr -d '\\\n' &quot;</FONT></B>_s);

    <I><FONT COLOR="#B22222">//Overrides.
</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}
</PRE>
<HR>
<A NAME="file41">
<H1>YgorVIDEOTools.cc 41/41</H1>
[<A HREF="#top">top</A>][<A HREF="#file40">prev</A>][next]
<PRE>
<I><FONT COLOR="#B22222">//YgorVIDEOTools.cc - A collection of routines for dealing with video and video files.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;utility&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorMisc.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorString.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorFilesDirs.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;YgorVIDEOTools.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">//Returns the W and H (in pixels) of a video file. If an error is encountered, we return two -1's.
</FONT></I>std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; YgorVIDEOTools_Get_Video_Dimensions(<B><FONT COLOR="#228B22">const</FONT></B> std::string &amp;filename){
    <B><FONT COLOR="#228B22">auto</FONT></B> out = std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(-1,-1);
<I><FONT COLOR="#B22222">//    if(Does_File_Exist_And_Can_Be_Read(filename)){ //Let's handle urls too!
</FONT></I>        <B><FONT COLOR="#5F9EA0">std</FONT></B>::string command;
<I><FONT COLOR="#B22222">//FUNCWARN(&quot;Need to verify this timeout code is working OK&quot;);
</FONT></I><I><FONT COLOR="#B22222">//        command += &quot;timeout --kill-after=10s --preserve-status 60s -- &quot;;
</FONT></I>        command += <B><FONT COLOR="#BC8F8F">&quot;mplayer -identify -frames 0 -vc null -vo null -ao null &quot;</FONT></B>; <I><FONT COLOR="#B22222">//Sometimes it locks up and uses 100% cpu until you kill it...
</FONT></I>
        command += Quote_Static_for_Bash(filename);
        command += <B><FONT COLOR="#BC8F8F">&quot; 2&gt;/dev/null&quot;</FONT></B>;

        <B><FONT COLOR="#228B22">const</FONT></B> std::string info = Execute_Command_In_Pipe(command);

        <B><FONT COLOR="#228B22">const</FONT></B> std::string W = GetFirstRegex(info, <B><FONT COLOR="#BC8F8F">&quot;ID_VIDEO_WIDTH=([0-9]{2,})&quot;</FONT></B>);
        <B><FONT COLOR="#228B22">const</FONT></B> std::string H = GetFirstRegex(info, <B><FONT COLOR="#BC8F8F">&quot;ID_VIDEO_HEIGHT=([0-9]{2,})&quot;</FONT></B>);

        <B><FONT COLOR="#A020F0">if</FONT></B>(Is_String_An_X&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(W) &amp;&amp; Is_String_An_X&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(H)){
            out = std::pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(stringtoX&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(W), stringtoX&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt;(H));
        }
<I><FONT COLOR="#B22222">//    }        
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> out;
}

</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.6</A>.</ADDRESS>
</BODY>
</HTML>
